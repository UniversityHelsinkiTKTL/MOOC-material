<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fi" lang="fi">
        <head>
                <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
          <title>Ohjelmoinnin perusteet ja jatkokurssi, kevät 2012</title>
                <link rel="stylesheet" href="stylesheets/common.css" type="text/css" media="screen, print" />
                <link rel="stylesheet" href="stylesheets/menu.css" type="text/css" media="screen" />

                <script type="text/javascript" src="javascripts/jquery-1.7.1.min.js"></script>

					<script type="text/javascript" src="javascripts/exercises-test.js"></script>
					<script type="text/javascript" src="javascripts/common-new.js"></script>

                <script type="text/javascript" src="javascripts/jquery.easing.js"></script>
                <script type="text/javascript" src="javascripts/shjs/sh_main.min.js"></script>
                <script type="text/javascript" src="javascripts/shjs/sh_java.min.js"></script>
                <link rel="stylesheet" href="stylesheets/shjs/sh_style.css" type="text/css" media="screen, print" />
                <link rel="stylesheet" href="stylesheets/exercises.css" type="text/css" media="screen, print" />
        </head>

        <body>

    <h1>Advanced programming course</h1>

<p>Arto Vihavainen ja Matti Luukkainen</p>

		<div id="toc" class="menu" data-first-chapter-index="1" data-first-exercise-index="109">
		  <div id="materiaali_toc"></div>
		  <div id="tehtavat_toc"></div>
		</div>

    <p><strong><big>Note for the reader</big></strong></p>

    <p>This is direct continuation to the programming basics course <a href="../ohpe/index.html">material.</a></p>

		<p>This material is meant for the Helsinki University Department of Computer Science fall 2012 programming basics and advanced programming course. The material is based on springs of 2012, 2011 an 2010 course materials, of which content has been affected by Matti Paksula, Antti Laaksonen, Pekka Mikkola, Juhana Laurinharju, Martin Pärtel, Joel Kaasinen ja Mikael Nousiainen.</p>

    <p>Read the material so that you do all of the examples you read yourself. It's worth making small changes to the examples and observe how the changes affect the program. At first you might think that doing the examples yourself too and editing them would slow down your learning. However this isn't true at all. As far as we know, no one has yet learned to program by just reading (or by just listening to a lecture). Learning is based substantially on actively doing and growing a routine. The examples and especially doing your own  experiments are one of the best ways to truly internalize the read text.</p>

    <p>Try to do assignments, or at least to try them out as you read the text. If you can't get an assignment pass right off the bat, don't get depressed, since you'll be always able to get help with the assignment at the workshop.</p>

    <p>The text isn't meant to be just readen once. You'll most certainly have to return to parts you've already read, or to assignments you've already done. This text doesn't contain everything essential related to programming. As a matter of fact no book exists that would have everything essential. So you will in every case - on your programming career - have to find information on your own. The excersises of the course already hold some instructions on how and where you'd be able to find useful information.</p>

    <p>To some parts we've also attached screencasts, by watching the videos you'll be able to see how the code is written instead of just reading ready-made code.</p>

    <p></p>

    <p>The course picks up where the programming basics left off and actually everything learned on the programming basics course are now assumed to be known. It's a good idea to go and check the <a href="../ohpe/index.html">material</a> of the programming basics course.</p>


    <p><em>Note!</em> On this course we use a programming environment known as <a href="http://netbeans.org/">NetBeans</a>. The instructions for using NetBeans and the assignment server you can find <a href="netbeans.html">here</a>.</p>

<div class="tyhja"></div>

<div class="viikkoraja">Week 1</div>



<h2>Recapping the programming basics</h2>

    <p>In this chapter we briefly recap a few concepts we became familiar with in the programming basics. The programming basics course material can be gotten more familiar with <a href="../ohpe/index.html">here</a>.</p>

<p>
Rusty programming skills can also be refreshed with the help of the excersises found <a href="http://www.cs.helsinki.fi/group/java/s12/ohpe/materiaali-ohpekertaus.html">here</a>.
</p>

    <h3>Program, commands and variables</h3>

    <p>A computer program consists of a serie of commands that a computer runs one at a time, from top to down. The commands always have a predefined structure and semantics. In Java - the programming language we use on the course - the commands are read from top to down, left to right. Programming courses are traditionally started by introducing a program that prints the string <code>Hello World!</code> . Below is a command written in Java that prints the <code>Hello World!</code> string.</p>

<pre class="sh_java">
        System.out.println("Hello World!");
</pre>

    <p>In the command the method <code>println</code> - that is related to the variable of  the <code>System</code> class - gets called which prints the string passed in to it as a parameter, and after that a linebreak. The method is given the string <code>Hello World!</code> as a paramter, consequently the program prints out <code>Hello World!</code> followed by a linebreak.</p>

    <p>Variables can be related to the program that can be used as part of the functionality of the program. Below is a program which introduces the variable <code>length</code> of the interger type to which is set the value 197 on the next line. After this the value <code>179</code> of the variable <code>length</code> is printed.</p>

<pre class="sh_java">
        int length;
        length = 179;
        System.out.println(length);
</pre>

    <p>Above the execution of the program would happen a line at a time. First the line <code>int length;</code> is executed, in which the variable <code>length</code> is introduced. Next the line <code>length = 179;</code> is executed, in which we set the value <code>179</code> to the variable that was introduced on the previous line. After this the line <code>System.out.println(length);</code> is run, in which we call the print method we saw earlier, to this method we give the variable <code>length</code> as a parameter. The method prints the content - the value - of the variable <code>length</code>, which is <code>179</code>.</p>

    <p>In the program above we really wouldn't have to introduce the variable <code>length</code> on one line and then set it's value on the next line. The introduction of a variable and setting it's value can be done on the same line.</p>

<pre class="sh_java">
        int length = 179;
</pre>

    <p>When executing the line above the variable <code>length</code> is first introduced and as it is introduced the value <code>179</code> is set to it.</p>

    <p>In reality all information within a computer is represented as a series of bits - ones and zeroes. Variables are an abstraction offered by the programming language with which we can handle different values more easily. The variables are used to store values and to maintain the state of the program. In Java, we have the primitive variable types <code>int</code> (integer), <code>double</code> (floating-point), <code>boolean</code> (truth value), <code>char</code> (character), and the reference type variables <code>String</code> (character string), <code>ArrayList</code> (array) and all classes. We'll return to primitive data type variables and to reference type variables and their differences later.</p>


<h3>Comparing variables and reading input</h3>

    <p>The functionality of programs is built with the help of control structures. Control structures make different functions possible depending on the variables of the program. Below an example of a <code>if-else if-else</code> control structure, in which a different function is made depending on result of the comparison. In the example a string <code>Accelerate</code> is printed if the value of the variable <code>speed</code> is smaller than 110 and the string <code>Break</code>, if the <code>speed</code> is greater than 120, and <code>Cruising</code> in other cases.</p>

<pre class="sh_java">
        int speed = 105;

        if(nopeus < 110) {
            System.out.println("Accelerate");
        } else if (speed > 120) {
            System.out.println("Break");
        } else {
            System.out.println("Cruising");
        }
</pre>

        <p>Because in the example above the value of the variable <code>speed</code> is 105, the program will always print the string <code>Accelerate</code>. Remember that the comparison of strings is done with the <code>equals</code> method that is related to the string. Below is an example in which an object created from Java's <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html" target="_blank">Scanner</a> class is used to read the input of an user. The program checks if the strings entered by the user are equal.</p>

<pre class="sh_java">
        Scanner reader = new Scanner(System.in);

        System.out.print("Enter the first string: ");
        String first = reader.nextLine();

        System.out.print("Enter the second string: ");
        String second = reader.nextLine();

        System.out.println();

        if (first.equals(second)) {
            System.out.println("The strings you entered are the same!");
        } else {
            System.out.println("The strings you entered weren't the same!");
        }
</pre>

        <p>The functionality of the program depends on the user's input. Below an example, the red text is user input.</p>

<pre>
Enter the first string: <font color="red">carrot</font>
Enter the second string: <font color="red">lettuce</font>

The strings you entered weren't the same!
</pre>

<h3>Loops</h3>

        <p>Repetition is often required in programs. First we make a so called while-true-break -loop, which we run until the user inputs the string <code>password</code>. The sentence <code>while(true)</code> begins the loop, which then will be repeated until it runs in to the keyword <code>break</code>.</p>

<pre class="sh_java">
        Scanner reader = new Scanner(System.in);

        while(true) {
            System.out.print("Enter password: ");
            String password = reader.nextLine();

            if(password.equals("password")) {
                break;
            }
        }

        System.out.println("Thanks!");
</pre>


<pre>
Enter password: <font color="red">carrot</font>
Enter password: <font color="red">password</font>
Thanks!
</pre>


        <p>You can also set a comparison to a while loop instead of the boolean <code>true</code>. Below the user input is printed so that there's stars above and belwo it.</p>

<pre class="sh_java">
        Scanner reader = new Scanner(System.in);

        System.out.print("Enter string: ");
        String characterString = reader.nextLine();

        int starNumber = 0;
        while(starNumber &lt; characterString.length()) {
            System.out.print("*");
            starNumber = starNumber + 1;
        }
        System.out.println();

        System.out.println(characterString);

        starNumber = 0;
        while(starNumber &lt; characterString.length()) {
            System.out.print("*");
            starNumber = starNumber + 1;
        }
        System.out.println();
</pre>


<pre>
Enter string: <font color="red">carrot</font>
******
carrot
******
</pre>

        <p>The example above should make you feel a little bad inside. The bad feels hopefully are because you see that the example violates the rules learned in the programming basics. The example has unneccessary repetition and should be removed with the help of methods.</p>

        <p>In addition to the while-loop we also have two versions of the for-loop at our disposal. The newer for-loop is used for going through lists.</p>

<pre class="sh_java">
        ArrayList&lt;String&gt; greets = new ArrayList&lt;String&gt;();
        greets.add("Hei");
        greets.add("Hallo");
        greets.add("Hi");

        for(String greet: greets) {
            System.out.println(greet);
        }
</pre>

<pre>
Hei
Hallo
Hi
</pre>

        <p>The more traditional for-loop is used in situations similiar to where you would use a <code>while</code>-loop. It can, for example, be used to go through arrays. In the following example all values in the array <code>values</code> will be multiplied by two and then finally printed using the newer for-loop.</p>

<pre class="sh_java">
        int[] values = new int[] {1, 2, 3, 4, 5, 6};

        for (int i = 0; i &lt; values.length; i++) {
            values[i] = values[i] * 2;
        }

        for (int value : values) {
            System.out.println(value);
        }
</pre>

<pre>
2
4
6
8
10
12
</pre>

        <p>The traditional for-loop is very useful in cases where we go through indexes one at a time. The loop below will go through the characters of a character string one by one and prints the character string <code>Hip!</code> every time we encounter the character <code>a</code>.</p>

<pre class="sh_java">
        String characterString = "saippuakauppias";
        for (int i = 0; i &lt; characterString.length(); i++) {
            if (characterString.charAt(i) == 'a') {
                System.out.println("Hip!");
            }
        }
</pre>

<pre>
Hip!
Hip!
Hip!
Hip!
</pre>

<h3>Methods</h3>

    <p>Methods are a way of chopping up the functionality of a program in to smaller entireties. All Java programs start their execution from the main program method, which is defined with the sentence <code>public static void main(String[] args)</code>. The sentence defines a static method - that is a method related to the class - which receives a character string array as it's parameter.</p>

    <p>The programmed defines methods to abstractify the functionalities of the program. When programming, one should try to achieve a situation, in which the program can be looked at from a <em>higher level</em>, in such a case the main program consists of calls to a group of self-defined, well named methods. The methods then specify the functionality of the program and perhaps are based on calls to other methods.</p> 

<p>Methods that are defined using the keyword <code>static</code>, are related to the <em>class</em> that holds the method and work as so called support methods. The methods that are defined without the keyword <code>static</code> are related to the instances - <em>the objects</em> - created from the class and can modify the state of that individual object.</p>

    <p>A method always has a visibility modifier (public, visible to 'everyone', private, only visible within it's class), a return type (void, returns nothing) and a name. In the following we create a method related to a class <code>public static void print(String characterString, int times)</code>, that prints a character string the defined amount of times. This time we use the method <code>System.out.print</code>, which works just like <code>System.out.println</code>, but doesn't print a linebreak.</p>

<pre class="sh_java">
    public static void print(String characterString, int times) {
        for (int i = 0; i &lt; times; i++) {
            System.out.print(characterString);
        }
    }
</pre>

    <p>The method above prints the character string it receives as a parameter the amount of times the integer - that was also passed in as a parameter - says.</p>

    <p>In the chapter related to loops we noticed that the code had some nasty copy-paste stuff in it. With the help of methods we can move the printing of stars to a separate method. We create a method <code>public static void printStars(int times)</code>, which prints the amount of stars it receives as a parameter. The method uses a <code>for</code> loop instead of a <code>while</code>.</p>

<pre class="sh_java">
    public static void printStars(int times) {
        for(int i = 0; i < kertaa; i++) {
            System.out.print("*");
        }
        System.out.println();
    }
</pre>

        <p>Metodia hyödyntäessä aiemmin kauhistusta aihettanut esimerkkimme näyttää seuraavalta.</p>

<pre class="sh_java">
        Scanner lukija = new Scanner(System.in);

        System.out.print("Syötä characterString: ");
        String characterString = reader.nextLine();

        printStars(characterString.length());
        System.out.println(characterString);
        printStars(characterString.length());
</pre>


    <h3>Class</h3>

    <p>Methods can abstract a program up to a certain point, but as the program becomes larger it's sensible to chop down the program even further in to smaller and more logical entirities. With the help of classes we can define higher level concepts of a program and functionalities related to those concepts. Every Java program requires a a class in order to work, so the <code>Hello World!</code> example wouldn't work without the class definition. A class is defined with the keywords <code>public class nameOfTheClass</code>.</p>

<pre class="sh_java">
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
</pre>

    <p>So in a program classes are used to define concepts and functionalities related to those concepts. Objects can be created from classes which are the embodiments of the classes. Every object related to a certain class has the same structure, but the variables related to the objects can be different. The methods of objects handle the state of the object, that is the variables of the object.</p>

    <p>Lets inspect the class <code>Book</code> below, the class has the object variables name (character string) and publishingYear (integer).</p>

<pre class="sh_java">
public class Book {
    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }
}
</pre>

    <p>The definition in the beginning <code>public class Book</code> tells the name of the class. This is followed by the definitions of object variables. Object variables are variables which for each of the objects created from the class are their own -- the object variable of one object are unrelated to the state of the same variable of another object. It's usually approperiate to hide the object variables from the users of the class, to define the visibility modifier <em>private</em> for them. If the visibility modifier is set to <em>public</em> the user of the object will be able to directly access the object variables.</p>

<p>Objects are created from a class with a <em>constructor</em>. Constructor is a method taht formats an object (creates the variables related to the object) and executes the commands that are within the constructor. The constructor is always named the same as the class that has the constructor in it. In the constructor <code>public Book(String name, int publishingYear)</code> a new object is created from the class <code>Book</code> and in to it's variables is set the values that were passed in as parameters.</p>

    <p>Two methods that handle the information in the object are also defined for the class above. The method <code>public String getName()</code> returns the name of the object in question. The method <code>public int getPublishingYear()</code> returns the publishing year of the object in question.</p>

    <h3>Object</h3>

    <p>Objects are created with the help of the constructor that is defined within a class. In the program code the costrucrtor is called with the <code>new</code> command, which returns a reference to the new object. Objects are instances created from classes. Lets inspect the program that creates two different books, after which it prints the values returned by the <code>getName</code> methods related to the objects.</p>

<pre class="sh_java">
        Book senseAndSensibility = new Book("Sense and Sensibility", 1811);
        Book prideAndPrejudice = new Book("Pride and Prejudice", 1813);

        System.out.println(senseAndSensibility.getName());
        System.out.println(prideAndPrejudice.getName());
</pre>

<pre>
Sense and Sensibility
Pride and Prejudice
</pre>

    <p>So each object has it's own internal state. The state is formed from object variables that are related to the object. Object variables can be both primitive type variables and reference type variables. If reference type variables are related to the objects it is possible that other objects also refers to the same objects! Lets visualize this with the bank example, in which there's accounts and persons.</p>

<pre class="sh_java">
public class Account {
    private String accountID;
    private int balanceAsCents;

    public Account(String accountID) {
        this.accountID = accountID;
        this.balanceAsCents = 0;
    }

    public void deposit(int sum) {
        this.balanceAsCents += sum;
    }

    public int getBalanceAsCents() {
        return this.balanceAsCents;
    }

    // .. other methods related to an account
}
</pre>

<pre class="sh_java">
import java.util.ArrayList;

public class Person {
    private String name;
    private ArrayList&lt;Account&gt; accounts;

    public Person(String name) {
        this.name = name;
        this.accounts = new ArrayList&lt;Account&gt;();
    }

    public void addAccount(Account account) {
        this.accounts.add(account);
    }

    public int moneyTotal() {
        int total = 0;
        for (Account account: this.accounts) {
            total += account.getBalanceAsCents();
        }

        return total;
    }

    // ... other methods related to a person
}
</pre>

    <p>Each object created from the <code>Person</code> class has it's own name and it's own list of accounts. Next, lets create two persons and two accounts. One of the accounts is owned by only one person and the other one is shared.</p>

<pre class="sh_java">
        Person matti = new Person("Matti");
        Person maija = new Person("Maija");

        Account salaryAccount = new Account("NORD-LOL");
        Account householdAccount = new Account("SAM-LOL");

        matti.addAccount(salaryAccount);
        matti.addAccount(householdAccount);
        maija.addAccount(householdAccount);

        System.out.println("Money on Matti's accounts: " + matti.moneyTotal());
        System.out.println("Money on Maija's accounts: " + maija.moneyTotal());
        System.out.println();

        salaryAccount.deposit(150000);

        System.out.println("Money on Matti's accounts: " + matti.moneyTotal());
        System.out.println("Money on Maija's accounts: " + maija.moneyTotal());
        System.out.println();

        householdAccount.deposit(10000);

        System.out.println("Money on Matti's accounts: " + matti.moneyTotal());
        System.out.println("Money on Maija's accounts: " + maija.moneyTotal());
        System.out.println();
</pre>

<pre>
Money on Matti's accounts: 0
Money on Maija's accounts: 0

Money on Matti's accounts: 150000
Money on Maija's accounts: 0

Money on Matti's accounts: 160000
Money on Maija's accounts: 10000
</pre>

        <p>First the accounts of both persons are empty. When money is added to the salaryAccount - to which <code>matti</code> has a reference to - the amount of money on Matti's accounts grows. When money is added to the householdAccount <em>the amount of money each person has grows</em>. This is because both Matti and Maija have the "access" to the householdAccount, so in each of the persons' object variable <code>accounts</code> there's a reference to the householdAccount.</p>


<h3>Ohjelmien rakenteesta</h3>

        <p>Ohjelmista tulee olla selkeitä niin ohjelmoijalle kuin muille ohjelmaa tarkasteleville. Selkeys saadaan aikaan sopivalla luokkarakenteella ja hyvien nimeämiskäytänteiden seuraamisella. Jokaisella luokalla tulee olla selkeä vastuu, johon liittyviä tehtäviä luokka hoitaa. Metodeja käytetään toiston vähentämiseen ja luokkien sisäisten toimintojen jäsentämiseen. Myös metodilla tulee olla selkeä vastuu eli metodien ei tule olla liian pitkiä ja liian montaa asiaa tekeviä. Liian montaa asiaa tekevät monimutkaiset metodit tuleekin pilkkoa useiksi pienemmiksi apumetodeiksi joita alkuperäinen metodi kutsuu Hyvät ohjelmoijat ohjelmoivat koodia, jota he ja heidän työkaverinsa ymmärtävät myös viikkoja koodin kirjoittamisen jälkeenkin.</p>

        <p>Ymmärrettävään koodiin liittyy niin kuvaava muuttujien, metodien ja luokkien nimentä kuin ohjelmakoodin ilmavuus ja johdonmukainen sisentäminen. Tutkitaan seuraavaa esimerkkiä käyttöliittymästä, jossa käyttäjä voi ostaa ja myydä esineitä. Vaikka esimerkissä ainoat ostettavat ja myytävät asiat ovat porkkanoita, eikä niistä pidetä kirjaa, voisi käyttöliittymää laajentaa esimerkiksi siten että sille annettaisiin myytävien tavaroiden varasto konstruktorin parametrina.</p>

<pre class="sh_java">
public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        while (true) {
            String komento = reader.nextLine();

            if (komento.equals("lopeta")) {
                break;
            } else if (komento.equals("osta")) {
                String luettu = null;
                while(true) {
                    System.out.print("Mitä ostetaan: ");
                    luettu = reader.nextLine();
                    if(luettu.equals("porkkana") {
                        break;
                    } else {
                        System.out.println("Ei löydy!");
                    }
                }

                System.out.println("Ostettu!");
            } else if (komento.equals("myy")) {
                String luettu = null;
                while(true) {
                    System.out.print("Mitä myydään: ");
                    luettu = reader.nextLine();
                    if(luettu.equals("porkkana") {
                        break;
                    } else {
                        System.out.println("Ei löydy!");
                    }
                }

                System.out.println("Myyty!");
            }
        }
    }
}
</pre>

        <p>Huomaamme esimerkissä heti monta ongelmakohtaa. Ensimmäinen pulma liittyy <code>kaynnista</code>-metodin sisällön suuruuteen. Huomaamme että metodia voi pienentää siirtämällä muiden komentojen kuin <code>lopeta</code>-komennon käsittelyn erilliseen metodiin.</p>

<pre class="sh_java">
public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        while (true) {
            String komento = reader.nextLine();

            if (komento.equals("lopeta")) {
                break;
            } else {
                hoidaKomento(komento);
            }
        }
    }

    public void hoidaKomento(String komento) {
        if (komento.equals("osta")) {
            String luettu = null;
            while(true) {
                System.out.print("Mitä ostetaan: ");
                luettu = reader.nextLine();
                if(luettu.equals("porkkana") {
                    break;
                } else {
                    System.out.println("Ei löydy!");
                }
            }

            System.out.println("Ostettu!");
        } else if (komento.equals("myy")) {
            String luettu = null;
            while(true) {
                System.out.print("Mitä myydään: ");
                luettu = reader.nextLine();
                if(luettu.equals("porkkana") {
                    break;
                } else {
                    System.out.println("Ei löydy!");
                }
            }

            System.out.println("Myyty!");
        }
    }
}
</pre>

        <p>Metodissa <code>hoidaKomento</code> on vielä toisteisuutta syötteen lukemiseen liittyen. Huomaamme että lukemisessa toistuu aina muutama characterString. Kun ostetaan kysytään "Mitä ostetaan: ", kun myydään kysytään "Mitä myydään: ". Molemmat lukemiskohdat odottavat characterStringa "porkkana" ja tulostavat "Ei löydy!" jos käyttäjä ei syötä characterStringa "Porkkana". Luodaan tätä varten erillinen metodi <code>public String lueKayttajalta(String kysymys)</code>, joka kysyy käyttäjältä haluttua characterStringa. Huomaa että jos käyttöliittymässämme olisi käytössä jonkinlainen varastonhallintaolio, vertaisimme sen sisältämiä esineitä käyttäjän syötteeseen porkkanan sijasta. </p>


<pre class="sh_java">
public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        while (true) {
            String komento = reader.nextLine();

            if (komento.equals("lopeta")) {
                break;
            } else {
                hoidaKomento(komento);
            }
        }
    }

    public void hoidaKomento(String komento) {
        if (komento.equals("osta")) {
            String luettu = lueKayttajalta("Mitä ostetaan: ");
            System.out.println("Ostettu!");
        } else if (komento.equals("myy")) {
            String luettu = lueKayttajalta("Mitä myydään: ");
            System.out.println("Myyty!");
        }
    }

    public String lueKayttajalta(String kysymys) {
        while(true) {
            System.out.print(kysymys);
            String luettu = reader.nextLine();

            if(luettu.equals("porkkana") {
                return luettu;
            } else {
                System.out.println("Ei löydy!");
            }
        }
    }
}
</pre>

        <p>Ohjelma on nyt pilkottu sopiviksi osiksi. Huomaamme kuitenkin että <code>kaynnista</code>-metodin yhteydessä on turha <code>else</code>-haara. Jos ohjelman suoritus päätyy <code>if</code>-haaraan, suoritetaan komento <code>break</code> ja poistutaan toistolauseesta. Voimme siis poistaa <code>else</code>-haaran jolloin <code>hoidaKomento</code>-metodin suorittaminen on omalla rivillään. Samanlainen tilanne on myös metodissa <code>lueKayttajalta</code>. Siistitään se myös samalla.</p>

<pre class="sh_java">
public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        while (true) {
            String komento = reader.nextLine();

            if (komento.equals("lopeta")) {
                break;
            }

            hoidaKomento(komento);
        }
    }

    public void hoidaKomento(String komento) {
        if (komento.equals("osta")) {
            String luettu = lueKayttajalta("Mitä ostetaan: ");
            System.out.println("Ostettu!");
        } else if (komento.equals("myy")) {
            String luettu = lueKayttajalta("Mitä myydään: ");
            System.out.println("Myyty!");
        }
    }

    public String lueKayttajalta(String kysymys) {
        while(true) {
            System.out.print(kysymys);
            String luettu = reader.nextLine();

            if(luettu.equals("porkkana") {
                return luettu;
            }

            System.out.println("Ei löydy!");
        }
    }
}
</pre>


        <p>Yllä kuvaavaamme ohjelman pilkkomista pienempiin osiin kutsutaan <em>refaktoroinniksi</em>. Refaktoroinnissa ohjelman toiminta pysyy samana, mutta sisäinen rakenne muuttuu selkeämmäksi ja ylläpidettävämmäksi. Nykyinen versiomme on huomattavasti selkeämpi alkuperäiseen ohjelmaan verrattuna. Ohjelmassa on toki vieläkin parannettavaa. Esimerkiksi metodin <code>hoidaKomento</code> voi pilkkoa ostamis- ja myymistoiminnallisuutta hoitaviin metodeihin.</p>

<pre class="sh_java">
public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        while (true) {
            String komento = reader.nextLine();

            if (komento.equals("lopeta")) {
                break;
            }

            hoidaKomento(komento);
        }
    }

    public void hoidaKomento(String komento) {
        if (komento.equals("osta")) {
            komentoOsta();
        } else if (komento.equals("myy")) {
            komentoMyy();
        }
    }

    public void komentoOsta() {
        String luettu = lueKayttajalta("Mitä ostetaan: ");
        System.out.println("Ostettu!");
    }

    public void komentoMyy() {
        String luettu = lueKayttajalta("Mitä myydään: ");
        System.out.println("Myyty!");
    }

    public String lueKayttajalta(String kysymys) {
        while(true) {
            System.out.print(kysymys);
            String luettu = reader.nextLine();

            if(luettu.equals("porkkana") {
                return luettu;
            }

            System.out.println("Ei löydy!");
        }
    }
}
</pre>

        <p> Nyt ohjelma on rakenteeltaan riittävän selkeä, metodit ovat kuvaavasti nimettyjä ja jokaisella metodilla on oma pieni tehtävä, josta metodi huolehtii. Huomaa että emme lisänneet refaktoroidessa ohjelmaan uutta toiminnallisuutta, muokkasimme vain rakennetta selkeämmäksi.</p>

        <h3>Ohjelmoinnista ja ennenkaikkea harjoittelun tärkeydestä</h3>

        <p>Tietääksemme kukaan ei ole oppinut ohjelmoimaan luentoja kuuntelemalla. Ohjelmointitaidon kehittymisen kannalta harjoittelu ja kertaaminen on tärkeää. Ohjelmointitaitoa on verrattu niin kielten puhumiseen kuin instrumentin soittamiseen, kummassakin kehittyy vain harjoittelemalla. Oikeastaan, esimerkiksi hyvät viulistit eivät ole hyviä <em>vain</em> sen takia, että he ovat harjoitelleet paljon. Harjoittelua motivoi myös se, että se on hauskaa. Samaa voi sanoa ohjelmoijista.</p>

        <p>Linus Torvaldsin sanoin <em>"Most good programmers do programming not because they expect to get paid or get adulation by the public, but because it is fun to program."</em>.</p>

        <p>Tohtori Luukkainen on kirjoittanut listan jota kannattaa seurata ohjelmoidessa ja siinä kehittyessä. Seuraa listan neuvoja kunnes osaat ne unissasikin.</p>

        <ul>
          <li> Etene pieni askel kerrallaan
            <ul>
              <li> Yritä pilkkoa ongelma osaongelmiin ja <strong>ratkaise vain yksi osaongelma kerrallaan</strong> </li>
              <li> Testaa aina että ohjelma on etenemässä oikeaan suuntaan eli että osaongelman ratkaisu meni oikein</li>
          </ul></li>
          <li> Kirjoita mahdollisimman "siistiä" koodia
            <ul>
              <li> sisennä koodi </li>
              <li> käytä kuvaavia muuttujien ja metodien nimiä</li>
              <li> älä tee liian pitkiä metodeja, edes mainia</li>
              <li> tee yhdessä metodissa vaan yksi asia</li>
              <li> <strong>poista koodistasi kaikki copy-paste</strong></li>
              <li> korvaa koodisi "huonot" ja epäsiistit osat siistillä koodilla</li>
          </ul></li>
        </ul>



        <h3>Näkyvyysmääreet</h3>

        <p>Olemme tähän mennessä käyttäneet kahta erilaista <em>näkyvyyteen</em> liittyvää avainsanaa metodien ja oliomuuttujien määrittelyssä. Avainsana <code>public</code> asettaa metodit ja muuttujat kaikille näkyviksi. Esimerkiksi luokan metodit ja konstruktorit merkitään usein määreellä public, jolloin niitä voi kutsua luokan ulkopuolelta.</p>

        <p>Avainsana <code>private</code> taas piilottaa metodit ja muuttujat luokan sisälle. Metodia, jolla on määre <code>private</code>, ei pysty kutsumaan luokan ulkopuolelta.</p>

<pre class="sh_java">
public class Book {
    private String name;
    private String sisalto;

    public Book(String name, String sisalto) {
        this.name = nimi;
        this.sisalto = sisalto;
    }

    public String getName() {
        return this.name;
    }

    public String getSisalto() {
        return this.sisalto;
    }

    // ...
}
</pre>

        <p>Yllä olevasta Book-luokasta luotujen olioiden tietoihin pääsee käsiksi vain kirjan julkisten metodien kautta. Private-määreellä merkityt oliomuuttujat ovat näkyvillä ja käsiteltävissä vain luokan sisäisessä koodissa. Jos kirjalla olisi private-määreellinen metodi, ei sitäkään voisi käyttää muualta kuin Book-luokan sisältä.</p>


        <p>Sitten itse asiaan, eli harjoitteluun!</p>

<div class="tehtavat" id="viikko7">

<NEXTWEEK></NEXTWEEK>

  <h3>Hymiöt</h3>

  <p>Laadi tehtavapohjan mukana tulevalle luokalle <code>Hymiot</code> apumetodi <code>private static void tulostaHymioityna(String characterString)</code>. Metodin tulee tulostaa annettu characterString hymiöillä ympyröitynä. Käytä hymiönä characterStringa <code>:)</code>.</p>

<pre class="sh_java">
tulostaHymioityna("\\:D/");
</pre>

<pre>
:):):):):)
:) \:D/ :)
:):):):):)
</pre>

  <p>Huomaa, että characterStringon on kirjoitettava \\ jotta saadaan tulostumaan merkki \.</p>

  <p><em>Huom!</em> Jos characterStringn pituus on pariton, tulee ylimääräinen välilyönti lisätä annetun characterStringn oikealle puolelle.</p>

<pre class="sh_java">
tulostaHymioityna("\\:D/");
tulostaHymioityna("87.");
</pre>

<pre>
:):):):):)
:) \:D/ :)
:):):):):)
:):):):):)
:) 87.  :)
:):):):):)
</pre>

  <p>Kannattaa ensin miettiä montako hymiötä minkäkin pituiselle characterStringlle tulee tulostaa. characterStringn pituuden saa selville siihen liittyvällä <code>length</code>-metodilla. Ala- ja ylärivin hymiöiden tulostamiseen auttaa toistolause, keskimmäisellä rivillä selviät normaalilla tulostuskomennolla. Pituuden parittomuuden voit tarkistaa jakojäännöksen avulla <code>characterString.length() % 2 == 1</code>.</p>

<h3>characterStringmuuntaja</h3>

  <p>Tässä tehtävässä luodaan characterStringmuuntaja, joka koostuu kahdesta luokasta. Luokka Muunnos muuttaa yksittäiset merkit toiseksi, Muuntaja sisältää joukon Muunnoksia ja muuttaa characterStringja sisältämiensä Muunnos-olioiden avulla.</p>

  <h4>Muunnos-luokka</h4>

  <p>Luo luokka <code>Muunnos</code>, jolla on seuraavat toiminnot:</p>

  <ul>
    <li> konstruktori <code>public Muunnos(char muunnettava, char muunnettu)</code> luo olion joka tekee muunnoksia merkiltä <code>muunnettava</code> merkille <code>muunnettu</code></li>
    <li> metodi <code>public String muunna(String characterString)</code> palauttaa muunnetun version annetusta characterStringsta</li>
  </ul>

  <p>Luokkaa käytetään seuraavalla tavalla:</p>

<pre class="sh_java">
  String sana = "porkkana";
  Muunnos muunnos1 = new Muunnos('a', 'b');
  sana = muunnos1.muunna(sana);

  System.out.println(sana);

  Muunnos muunnos2 = new Muunnos('k', 'x');
  sana = muunnos2.muunna(sana);

  System.out.println(sana);
</pre>

<p>Yllä oleva esimerkki tulostaisi:</p>

<pre>
  porkkbnb
  porxxbnb
</pre>

<p><strong>Vihje:</strong> voit tehdä merkkien korvaamisen kahdella tavalla, joko suoraan hyödyntäen luokan <code>String</code> metodia (etsi metodi itse!) tai käymällä characterStringn läpi merkki merkiltä ja samalla muodostaen muunnetun characterStringn.</p>

<p>Jos et käytä Stringin valmista metodia, niin kannattaa muistaa, että vaikka characterStringja vertaillaankin komennolla <code>equals</code> yksittäisiä merkkejä vertaillaan operaattorin == avulla:
</p>

<pre class="sh_java">
  String sana = "porkkana";

  String korvattuAat = ""; 
  for ( int i=0; i &lt; sana.length(); i++) {
     char merkki = sana.charAt(i);
     if ( merkki == 'a' ) {  
        korvattuAat += '*'
     }  else {
        korvattuAat += merkki;
     } 
  }

  System.out.println(korvattuAat);  // tulostu porkk*n*
</pre>

<h4>Muuntaja-luokka</h4>

  <p>Luo luokka <code>Muuntaja</code>, jolla on seuraavat toiminnot:</p>

  <ul>
    <li> konstruktori <code>public Muuntaja()</code> luo uuden muuntajan</li>
    <li> metodi <code>public void lisaaMuunnos(Muunnos muunnos)</code> lisää uuden muunnoksen muuntajaan</li>
    <li> metodi <code>public String muunna(String characterString)</code> suorittaa characterStringlle kaikki lisätyt muunnokset niiden lisäysjärjestyksessä ja palauttaa muunnetun characterStringn</li>
  </ul>

  <p>Luokkaa käytetään seuraavalla tavalla:</p>

<pre class="sh_java">
  Muuntaja skanditPois = new Muuntaja();
  skanditPois.lisaaMuunnos(new Muunnos('ä', 'a'));
  skanditPois.lisaaMuunnos(new Muunnos('ö', 'o'));
  System.out.println(skanditPois.muunna("ääliö älä lyö, ööliä läikkyy"));
</pre>

  <p>Yllä oleva esimerkki tulostaisi:</p>

<pre>
  aalio ala lyo, oolia laikkyy
</pre>

<p><strong>Vihje:</strong> Muunnokset kannattaa tallettaa Muuntajan oliomuuttujana olevalle listalle (samaan tyyliin kuin peruskurssilla talletettiin esim. pelaajat joukkueeseen, puhelinnumerot puhelinluetteloon tai kirjat kirjastoon). Muunnos suoritetaan siten, että muunnettavalle characterStringlle suoritetaan muunnokset yksi kerrallaan seuraavan esimerkin tapaan:</p>

<pre class="sh_java">
    ArrayList&lt;Muunnos&gt; muunnokset = new ArrayList&lt;Muunnos&gt;();

    muunnokset.add( new Muunnos('a', 'b') );
    muunnokset.add( new Muunnos('k', 'x') );
    muunnokset.add( new Muunnos('o', 'å') );

    String sana = "porkkana";

    for (Muunnos muunnos : muunnokset) {
        sana = muunnos.muunna(sana);
    }

    System.out.println(sana);  // tulostuu pårxxbnb
</pre>

<p><strong>MUISTUTUS</strong> kun lisäät ohjelmaasi ArrayList:in, Scanner:in tai Random:in ei Java tunnista luokkaa ellet "importoi" sitä lisäämällä ohjelmatiedoston alkuun:</p>

<pre class="sh_java">
import java.util.ArrayList;    // importoi ArrayListin
import java.util.*;            // importoi kaikki java.util:sissa olevat työkalut, mm. ArrayListin, Scannerin ja Randomin
</pre>

<h3>Laskin</h3>

  <p>Teemme tässä tehtävässä samantyylisen yksinkertaisen laskimen, joka oli jo ohjelmoinnin perusteiden viikon 1 materiaalissa. Tällä kertaa kiinnitämme kuitenkin huomiota ohjelman rakenteeseen. Erityisesti teemme <em>main</em>-metodista eli pääohjelmasta hyvin kevyen. Pääohjelmametodi ei tee oikeastaan mitään muuta kun käynistää ohjelman:</p>

<pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        Laskin laskin = new Laskin();
        laskin.kaynnista();
    }
}
</pre>

  <p>Pääohjelma siis ainoastaan luo varsinaisen sovelluslogiikan toteuttavan olion ja käynnistää sen. Tämä on oikea tyyli tehdä ohjelmia ja tulemme jatkossa usein pyrkimään tähän rakenteeseen.</p>

  <h4>Lukija</h4>

  <p>Kommunikoidakseen käyttäjän kanssa laskin tarvitsee Scanner-olion. Kuten olemme huomanneet, on kokonaislukujen lukeminen scannerilla hieman työlästä. Teemme nyt erillisen luokan <code>Lukija</code> joka kapseloi sisälleen Scanner-olion. </p>

  <p>Toteuta luokka <code>Lukija</code> ja lisää sille metodit</p>

  <ul>
    <li><code>public String luecharacterString()</code></li>
    <li><code>public int lueKokonaisluku()</code></li>
  </ul>

  <p>Lukijan sisällä tulee olla oliomuuttujana Scanner-olio jota metodit käyttävät ohjelmoinnin perusteista tuttuun tyyliin. Muistathan että kokonaislukujen lukemisessa kannattaa ensin lukea koko rivi, jonka jälkeen rivi tulee muuttaa kokonaisluvuksi. Tässä on hyödyksi <code>Integer</code>-luokan metodi <code>parseInt</code>.</p>

  <h4>Sovellusrunko</h4>

  <p>Laskin toimii seuraavan esimerkin mukaan:</p>

<pre>
komento: <font color="red">summa</font>
luku1: <font color="red">4</font>
luku2: <font color="red">6</font>
lukujen summa 10

komento: <font color="red">tulo</font>
luku1: <font color="red">3</font>
luku2: <font color="red">2</font>
lukujen tulo 6

komento: <font color="red">lopetus</font>
</pre>

  <p>Tee ohjelmaasi sovelluslogiikasta huolehtiva luokka <code>Laskin</code> ja sille metodi <code>public void kaynnista()</code> jonka sisältö on <strong>täsmälleen</strong> seuraava:</p>

<pre class="sh_java">
    public void kaynnista() {
        while (true) {
            System.out.print("komento: ");
            String komento = reader.luecharacterString();
            if (komento.equals("lopetus")) {
                break;
            }

            if (komento.equals("summa")) {
                summa();
            } else if (komento.equals("erotus")) {
                erotus();
            } else if (komento.equals("tulo")) {
                tulo();
            }
        }

        statistiikka();
    }
</pre>

  <p>Laskimellamme on operaatiot <code>summa, erotus, tulo</code>.</p>

  <p>Tee valmiiksi rungot metodeille <code>summa</code>, <code>erotus</code>, <code>tulo</code> ja <code>statistiikka</code>. Kaikkien tulee olla tyyppiä <code>private void</code>, eli metodit ovat vain laskimen sisäisessä käytössä.</p>

  <p>Lisää laskimelle oliomuuttuja jonka tyyppi on <code>Lukija</code>, ja luo lukija konstruktorissa. <em>Laskimessa ei saa olla erikseen Scanner-tyyppistä muuttujaa!</em></p>

  <h4>Sovelluslogiikan toteutus</h4>

  <p>Toteuta nyt metodit <code>summa</code>, <code>erotus</code> ja <code>tulo</code> siten, että ne toimivat yllä olevan esimerkin mukaan. Esimerkissä kysytään aina ensin komento, jonka jälkeen kysytään 2 lukua käyttäjältä, suoritetaan haluttu operaatio, ja tulostetaan operaation arvo. Huomaa, että lukujen kysyminen tapahtuu metodien<code>summa</code>, <code>erotus</code> ja <code>tulo</code> sisällä! Metodit käyttävät lukujen kysymiseen lukija-olioa. Metodien runko on siis seuraavanlainen:</p>

<pre class="sh_java">
    private void summa() {
       System.out.print("luku1: ");   
       int luku1 = // luetaan luku käyttäen lukija-olioa
       System.out.print("luku2: "); 
       int luku2 = // luetaan luku käyttäen lukija-olioa
       // tulostetaan tulos ylläolevan esimerkin tapaan
    }
</pre>

<h4>Statistiikka</h4>

  <p>Metodissa <code>kaynnista</code> olevan <code>while</code>-silmukan jälkeen kutsutaan metodia <code>statistiikka</code>. Metodin on tarkoitus tulostaa kuinka montaa kertaa laskinoliolla suoritettiin joku laskutoimenpide. Esim:</p>

<pre>
komento: <font color="red">summa</font>
luku1: <font color="red">4</font>
luku2: <font color="red">6</font>
lukujen summa 10

komento: <font color="red">tulo</font>
luku1: <font color="red">3</font>
luku2: <font color="red">2</font>
lukujen tulo 6

komento: <font color="red">lopetus</font>
Laskuja laskettiin 2
</pre>

  <p>Toteuta metodi <code>private void statistiikka()</code>, ja tee statistiikan keräämiseen tarvittavat muutokset muualle Laskin-luokan koodiin. </p>

  <p>Huom: jos ohjelmalle annetaan virheellinen komento (eli joku muu kuin summa, erotus, tulo, tai lopetus), ei laskin reagoi komentoon millään tavalla vaan jatkaa kysymällä seuraavaa komentoa. Statistiikka ei saa laskea virheellistä komentoa laskutoimenpiteeksi.</p>

<pre>
komento: <font color="red">integraali</font>
komento: <font color="red">erotus</font>
luku1: <font color="red">3</font>
luku2: <font color="red">2</font>
lukujen erotus 1

komento: <font color="red">lopetus</font>
Laskuja laskettiin 1
</pre>

<p><strong>Bonustehtävä (ei testata):</strong> Syötteen lukeminen toistuu samanlaisena kaikissa kolmessa laskuoperaation suorittavassa metodissa. Posta koodistasi toisteisuus sopivan apumetodin avulla. Metodi voi palauttaa käyttäjältä luetut 2 lukua esim. taulukossa. </p>

</div>


<h2>Alkeis- ja viitetyyppiset muuttujat</h2>

        <p>Java on vahvasti tyypitetty kieli, eli kaikilla sen muuttujilla on <em>tyyppi</em>. Muuttujien tyypit voidaan jakaa kahteen kategoriaan: <strong>alkeis- ja viitetyyppisiin muuttujiin</strong>. Kummankin kategorian tyypisillä muuttujilla on oma "lokero", joka sisältää niihin liittyvän tiedon. Alkeistyyppisillä muuttujilla lokeroon talletetaan muuttujien konkreettinen <em>arvo</em>, kun taas viitetyyppisten muuttujien lokero sisältää <em>viitteen</em> muuttujaan liittyvään konkreettiseen <em>olioon</em>.</p>

        <h3>Alkeistyyppiset muuttujat</h3>

        <p>Alkeistyyppisen muuttujan arvo tallennetaan muuttujaa varten luotuun lokeroon. Jokaisella alkeistyyppisellä muuttujalla on oma lokero ja oma arvo. Muuttujalle luodaan uusi lokero silloin kun se esitellään (esim. <code>int numero;</code>). Lokeroon asetetaan arvo sijoitusoperaatiolla <code>=</code>. Alla on esimerkki alkeistyyppisen int (kokonaisluku) -muuttujan esittelemisestä ja arvon asettamisesta samassa lausekkeessa.</p>

<pre class="sh_java">
int numero = 42;
</pre>

        <p>Alkeistyyppisiä muuttujia ovat muun muassa <code>int</code>, <code>double</code>, <code>char</code>, <code>boolean</code> sekä harvemmin käyttämämme <code>short</code>, <code>float</code>, <code>byte</code> ja <code>long</code>. Myös <code>void</code> on alkeistyyppi, mutta sillä ei ole omaa lokeroa tai arvoa. Void-tyyppiä käytetään silloin kun halutaan ilmaista että metodi ei palauta mitään arvoa.</p>

    <p>Esitellään seuraavaksi kaksi alkeistyyppistä muuttujaa ja asetetaan niihin arvot.</p>

<pre class="sh_java">
int vitonen = 5;
int kutonen = 6;
</pre>

        <p>Yllä esiteltyjen alkeistyyppisten muuttujien nimet ovat <code>vitonen</code> ja <code>kutonen</code>. Muuttujaa <code>vitonen</code> luodessa sitä varten luotuun <em>lokeroon</em> asetetaan arvo 5 (<code>int vitonen = 5;</code>). Muuttujaa <code>kutonen</code> luodessa sitä varten luotuun lokeroon asetetaan arvo 6 (<code>int kutonen = 6;</code>). Muuttujat <code>vitonen</code> ja <code>kutonen</code> ovat kumpikin <code>int</code>-tyyppisiä, eli kokonaislukuja.</p>

        <p>Alkeistyyppiset muuttujat voi visualisoida laatikkoina joiden sisälle kuhunkin muuttujaan liittyvä arvo on tallennettu:</p>

        <p><img src="img-ohja/vis/alkeis-vs-viittaus-vitonen-ja-kutonen.png" /></p>

        <p>Tarkastellaan seuraavaksi alkeistyyppisten muuttujien arvojen kopioitumista.</p>

<pre class="sh_java">
int vitonen = 5;
int kutonen = 6;

vitonen = kutonen; // muuttuja vitonen sisältää nyt arvon 6, eli arvon joka oli muuttujassa kutonen
kutonen = 64; // muuttuja kutonen sisältää nyt arvon 64

// muuttuja vitonen sisältää vieläkin arvon 6
</pre>

        <p>Yllä esitellään muuttujat <code>vitonen</code> ja <code>kutonen</code> ja asetetaan niihin arvot. Tämän jälkeen muuttujan <code>vitonen</code> lokeroon kopioidaan muuttujan <code>kutonen</code> lokeron sisältämä arvo (<code>vitonen = kutonen;</code>). Tässä vaiheessa muuttujan <code>vitonen</code> lokeroon kopioituu muuttujan <code>kutonen</code> sisältämä arvo. Jos muuttujan <code>kutonen</code> arvoa muutetaan tämän jälkeen, ei muuttujan <code>vitonen</code> sisältämä arvo muutu: muuttujan <code>vitonen</code> arvo on sen omassa lokerossa eikä liity muuttujan <code>kutonen</code> lokerossa olevaan arvoon millään tavalla. Lopputilanne kuvana.</p>

        <p><img src="img-ohja/vis/alkeis-vs-viittaus-vitonen-ja-kutonen-64.png" /></p>

        <h4>Alkeistyyppinen muuttuja metodin parametrina ja paluuarvona</h4>

        <p>Kun alkeistyyppinen muuttuja annetaan metodille parametrina, asetetaan metodin parametrille kopio annetun muuttujan lokerossa olevasta. Käytännössä myös metodin parametrieilla on omat lokerot, joihin arvo kopioidaan kuten asetuslauseessa. Katsotaan seuraavaa metodia <code>lisaaLukuun(int luku, int paljonko)</code>.</p>

<pre class="sh_java">
public int lisaaLukuun(int luku, int paljonko) {
    return luku + paljonko;
}
</pre>

        <p>Metodi <code>lisaaLukuun</code> saa kaksi parametria, kokonaisvalues <code>luku</code> ja <code>paljonko</code>. Metodi palauttaa uuden luvun, joka on annettujen parametrien summa. Tutkitaan vielä metodin kutsumista.</p>

<pre class="sh_java">
int omaLuku = 10;
omaLuku = lisaaLukuun(omaLuku, 15);
// muuttuja omaLuku sisältää nyt arvon 25
</pre>

        <p>Esimerkissä kutsutaan <code>lisaaLukuun</code>-metodia muuttujalla <code>omaLuku</code> ja arvolla <code>15</code>. Metodin muuttujiin <code>luku</code> ja <code>paljonko</code> kopioituvat arvot 10, eli muuttujan <code>omaLuku</code> sisältö, ja 15. Metodi palauttaa muuttujien <code>luku</code> ja <code>paljonko</code> summan, eli <code>10 + 15 = 25</code>.</p>

        <p>Huom! Edellisessä esimerkissä muuttujan <code>omaLuku</code> arvo muuttuu ainoastaan koska metodin <code>lisaaLukuun</code> palauttama arvo asetetaan siihen sijoituslausekkeella (<code>omaLuku = lisaaLukuun(omaLuku, 15);</code>). Jos metodin <code>lisaaLukuun</code> kutsu olisi seuraavanlainen, ei muuttujan <code>omaLuku</code> arvo muutu.</p>

<pre class="sh_java">
int omaLuku = 10;
lisaaLukuun(omaLuku, 15);
// muuttuja omaLuku sisältää vieläkin arvon 10
</pre>

<h4>Minimi- ja maksimiarvot</h4>

        <p>Eri tietotyypeillä on omat minimi- ja maksimiarvonsa, eli arvot joita pienempiä tai suurempia ne eivät voi olla. Tämä johtuu Javan (ja useimpien ohjelmointikielten) sisäisestä tiedon esitysmuodosta, jossa tietotyyppien koot on ennalta määrätty.</p>

        <p>Alla muutama Javan alkeistyyppi ja niiden minimi- ja maksimiarvot</p>

        <p>
          <table cellspacing="5" >
            <tr><th>Muuttujatyyppi</th><th>Selitys</th><th>Minimiarvo</th><th>Maksimiarvo</th></tr>
            <tr><td>int</td><td>Kokonaisluku</td><td>-2 147 483 648 (<code>Integer.MIN_VALUE</code>)</td><td>2 147 483 647 (<code>Integer.MAX_VALUE</code>)</td></tr>
            <tr><td>long</td><td>Iso kokonaisluku</td><td>-9 223 372 036 854 775 808 (<code>Long.MIN_VALUE</code>)</td><td>9 223 372 036 854 775 807 (<code>Long.MAX_VALUE</code>)</td></tr>
            <tr><td>boolean</td><td>Totuusarvo</td><td colspan=2><code>true</code> tai <code>false</code></td></tr>
            <tr><td>double</td><td>Liukuluku</td><td><code>Double.MIN_VALUE</code></td><td><code>Double.MAX_VALUE</code></td></tr>
          </table>
        </p>

        <p><strong>Pyöristysvirheet</strong></p>

        <p>Liukulukuja käyttäessä kannattaa muistaa että liukuluvun arvo on aina <em>arvio</em> oikeasta arvosta. Koska liukuluvun, kuten kaikkien muidenkin alkeistyyppien sisältämä tietomäärä on rajoitettu, voidaan huomata yllättäviäkin pyöristysvirheitä. Esimerkiksi seuraava tilanne.</p>

<pre class="sh_java">
double eka = 0.39;
double toka = 0.35;
System.out.println(eka - toka);
</pre>

        <p>Esimerkki tulostaa arvon <code>0.040000000000000036</code>. Ohjelmointikielet tarjoavat usein työkalut liukulukujen tarkempaa käsittelyä varten. Esimerkiksi Javassa on luokka <em>BigDecimal</em>, johon voi asettaa äärettömän pitkiä liukulukuja.</p>

        <p>Liukulukuja vertaillessa pyöristysvirheisiin varaudutaan usein vertaamalla arvojen etäisyyttä toisistaan. Esimerkiksi edellisen esimerkin muuttujia käytettäessä vertailu <code>eka - toka == 0.04</code> ei tuota toivottua tulosta pyöristysvirheen takia.</p>

<pre class="sh_java">
double eka = 0.39;
double toka = 0.35;

if((eka - toka) == 0.04) {
    System.out.println("Vertailu onnistui!");
} else {
    System.out.println("Vertailu epäonnistui!");
}
</pre>

<pre>
Vertailu epäonnistui!
</pre>

        <p>Arvon etäisyyttä jostain luvusta voi tarkastella esimerkiksi seuraavasti. Apufunktio <code>Math.abs</code> palauttaa sille annetun luvun itseisarvon.</p>

<pre class="sh_java">
double eka = 0.39;
double toka = 0.35;

double etaisyys = 0.04 - (eka - toka);

if(Math.abs(etaisyys) &lt; 0.0001) {
    System.out.println("Vertailu onnistui!");
} else {
    System.out.println("Vertailu epäonnistui!");
}
</pre>

<h3>Viitetyyppi</h3>

        <p>Viitetyyppiset muuttujat tallentavat niihin liittyvän tiedon viitteen taakse eli "langan päähän". Viitetyyppisten muuttujien lokerossa on viite tiedon sisältävään paikkaan. Toisin kuin alkeistyyppisillä muuttujilla, viitetyyppisillä muuttujilla ei ole rajoitettua arvoaluetta, koska niiden oikea arvo tai <em>tieto</em> on viitteen takana. Oleellinen ero alkeistyyppisiin muuttujiin on se, että usea viitetyyppinen muuttuja voi viitata samaan olioon.</p>

<!--
        <p>Viitetyyppisistä muuttujista puhutaan olioina, joita luodaan <code>new</code>-kutsulla. Muuttujan arvo asetetaan vieläkin sijoitusoperaattorilla <code>=</code>, mutta komento <code>new</code> luo olion ja palauttaa viitteen olioon. Viite asetetaan muuttujaan liittyvään lokeroon eli sen arvoksi.</p> 
-->

<p>Tutkitaan kahden viitetyyppisen muuttujan luontia. Esimerkeissä käytetään seuraavaa luokkaa <em>Laskuri</em>:</p>

<pre class="sh_java">
public class Laskuri {
    private int arvo;

    public Laskuri(int alkuarvo) {  // Konstruktori
        this.arvo = alkuarvo;
    }

    public void kasvataArvoa() {
        this.arvo = this.arvo + 1;
    }

    public int annaArvo() {
        return arvo;
   }
}
</pre>

        <p>Pääohjelma:</p>

<pre class="sh_java">
Laskuri bonusLaskuri = new Laskuri(5);
Laskuri axeLaskuri = new Laskuri(6);
</pre>

        <p>Esimerkissä luodaan ensin viitetyyppinen muuttuja <code>bonusLaskuri</code>. Komentoa <code>new</code> kutsuessa varataan tila muuttujan tietoa varten, suoritetaan <code>new</code>-kutsua seuraavan konstruktorin koodi, ja palautetaan viite juuri luotuun olioon. . Palautettu viite asetetaan sijoitusoperaattorilla <code>=</code> muuttujaan <code>bonusLaskuri</code>. Sama tapahtuu muuttujalle nimeltä <code>axeLaskuri</code>. Kuvana viitetyyppi kannattaa ajatella siten, että muuttuja sisältää "langan" tai "nuolen", jonka päässä on olio itse. Muuttuja ei siis sisällä oliota, vaan viitteen olioon liittyviin tietoihin.</p>

        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit.png" /></p>

        <p>Tutkitaan seuraavaksi viitetyyppisen muuttujan kopioitumista.</p>

<pre class="sh_java">
Laskuri bonusLaskuri = new Laskuri(5);
Laskuri axeLaskuri = new Laskuri(6);

bonusLaskuri = axeLaskuri; // muuttujaan bonusLaskuri kopioidaan muuttujan axeLaskuri sisältämä viite,
                           // eli viite Laskuri-tyyppiseen olioon joka on saanut konstruktorissaan arvon 6
</pre>

        <p>Viitetyyppistä muuttujaa kopioitaessa (yllä <code>bonusLaskuri = axeLaskuri;</code>) muuttujan viite kopioituu. Yllä muuttujan <code>bonusLaskuri</code> lokeroon kopioituu muuttujan <code>axeLaskuri</code> lokerossa oleva viite. Nyt kummatkin oliot viittaavat samaan paikkaan!</p>

        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-3.png" /></p>

        <p>Jatketaan yllä olevaa esimerkkiä ja asetetaan muuttujaan <code>axeLaskuri</code> uusi viite, joka osoittaa kutsulla <code>new Laskuri(10)</code> luotuun olioon.</p>

<pre class="sh_java">
Laskuri bonusLaskuri = new Laskuri(5);
Laskuri axeLaskuri = new Laskuri(6);

bonusLaskuri = axeLaskuri; // muuttujaan bonusLaskuri kopioidaan muuttujan axeLaskuri sisältämä viite,
                           // eli viite Laskuri-tyyppiseen olioon joka on saanut konstruktorissaan arvon 6

axeLaskuri = new Laskuri(10); // muuttujaan axeLaskuri asetetaan uusi viite, joka osoittaa
                              // new Laskuri(10) - kutsulla luotuun Laskuri-olioon

// muuttuja bonusLaskuri sisältää vieläkin viitteen Laskuri-olioon, joka sai konstruktorissaan arvon 6
</pre>

        <p>Esimerkissä tehdään käytännössä samat operaatiot kuin alkeistyyppi-kappaleessa olevassa asetusesimerkissä. Äskeisessä esimerkissä kopioimme viitetyyppisten muuttujien viitteitä, kun taas alkeistyyppisiin muuttujiin liittyvässä esimerkissä kopioimme alkeistyyppien arvoja. Kummassakin tapausessa siis lokeron sisältö kopioidaan, alkeistyyppisten muuttujien lokero sisältää arvon, viitetyyppisten muuttujien lokero sisältää viitteen.</p>

        <p>Edellisen esimerkin lopussa kukaan ei viittaa Laskuriolioon, joka sai arvokseen 5 sen konstruktorissa. Javassa oleva roskienkeruumekanismi käy ajallaan poistamassa tällaiset turhat oliot. Lopputilanne kuvana:</p>


        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-2.png" /></p>

        <p>Tarkastellaan vielä kolmatta esimerkkiä, joka näyttää viite- ja alkeistyyppisten muuttujien oleellisen eron.</p>

<pre class="sh_java">
Laskuri bonusLaskuri = new Laskuri(5);
Laskuri axeLaskuri = new Laskuri(6);

bonusLaskuri = axeLaskuri; // muuttujaan bonusLaskuri kopioidaan muuttujan axeLaskuri sisältämä viite,
                           // eli viite Laskuri-tyyppiseen olioon joka on saanut konstruktorissaan arvon 6

axeLaskuri.kasvataArvoa(); // kasvatetaan axeLaskuri-viitteen takana olevan olion arvoa yhdellä

System.out.println(bonusLaskuri.annaArvo());
System.out.println(axeLaskuri.annaArvo());
</pre>

<pre>
7
7
</pre>

        <p>Koska asetuksen <code>bonusLaskuri = axeLaskuri;</code> jälkeen <code>bonusLaskuri</code>-muuttuja viittaa samaan olioon kuin <code>axeLaskuri</code>-muuttuja, on kummankin laskurin arvo 7 vaikka kasvatuksia on tehty vain yksi. Tämä johtuu siitä että kummatkin laskurit viittaavat samaan olioon.</p>

        <p>Kuvana tilanne on ehkä selkeämpi. Kutsu <code>axeLaskuri.kasvataArvoa()</code> kasvattaa muuttujan <code>axeLaskuri</code> viittaaman olion sisältämää muuttujan <code>arvo</code> arvoa yhdellä. Koska muuttuja <code>bonusLaskuri</code> viittaa samaan olioon, palauttaa kutsu <code>bonusLaskuri.annaArvo()</code> saman muuttujan arvon, jota aiempi kutsu <code>axeLaskuri.kasvataArvoa()</code> kasvatti.</p>

        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-4.png" /></p>

        <p> Seuraavassa esimerkissä on kolme viitetyyppistä muuttujaa, jotka kaikki osoittavat samaan <code>Laskuri</code>-olioon.</p>

<pre class="sh_java">
Laskuri bonus = new Laskuri(5);
Laskuri ihq = bonus;
Laskuri lennon = bonus;
</pre>

        <p>Esimerkissä luodaan vain yksi <code>Laskuri</code>-olio, mutta kaikki kolme <code>Laskuri</code>-tyyppistä muuttujaa osoittavat lopussa siihen. Tällöin kaikki metodikutsut viitteille <code>bonus</code>, <code>ihq</code> ja <code>lennon</code> muokkaavat samaa oliota. Vielä kerran: viitetyyppisiä muuttujia kopioitaessa viitteet kopioituvat. Kuvana:</p>


        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-5.png" /></p>

        <p>Katsotaan kopioitumista vielä esimerkillä.</p>

<pre class="sh_java">
Laskuri bonus = new Laskuri(5);
Laskuri ihq = bonus;
Laskuri lennon = bonus;

lennon = new Laskuri(3);
</pre>

        <p>Kun muuttujan <code>lennon</code> sisältö, eli viite muuttuu, se ei vaikuta muuttujien <code>bonus</code> tai <code>ihq</code> sisältämiin viitteisiin. Muuttujan arvoa asetettaessa muutetaan aina vain muuttujan oman lokeron sisältöä. Kuvana:</p>

        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-6.png" /></p>

        <h4>Viitetyyppinen muuttuja metodin parametrina</h4>

        <p>Kun viitetyyppinen muuttuja annetaan parametrina metodille, luodaan metodin parametrille kopio annetusta muuttujan viitteestä. Parametrilla on siis oma lokero, johon viite kopioidaan. Alkeistyyppisistä muuttujista poiketen kopioimme viitteen, emmekä arvoa, eli voimme muokata viitteen takana olevaa oliota myös metodin sisällä. Oletetaan että metodimme on alla esitelty <code>public void lisaaLaskuriin(Laskuri laskuri, int paljonko)</code>.</p>

<pre class="sh_java">
public void lisaaLaskuriin(Laskuri laskuri, int paljonko) {
    for (int i = 0; i &lt; paljonko; i++) {
        laskuri.kasvataArvoa();
    }
}
</pre>

        <p>Metodille <code>lisaaLaskuriin</code> annetaan kaksi parametria, viitetyyppinen muuttuja ja alkeistyyppinen muuttuja. Kumpaankin muuttujaan liittyvän lokeron sisältö kopioidaan metodin parametrien omiin lokeroihin. Viitetyyppiselle parametrille <code>laskuri</code> kopioituu viite ja alkeistyyppiselle parametrille <code>paljonko</code> kopioituu arvo. Metodi kutsuu <code>Laskuri</code>-tyyppisen parametrin metodia <code>kasvataArvoa()</code> <code>paljonko</code>-muuttujan sisältämän arvon määrän. Tutkitaan vielä metodin kutsumista.</p>

<pre class="sh_java">
int kertoja = 10;

Laskuri bonus = new Laskuri(10);
lisaaLaskuriin(bonus, kertoja);
// muuttujan bonus sisäinen arvo on nyt 20
</pre>

        <p>Esimerkissä kutsutaan <code>lisaaLaskuriin()</code>-metodia muuttujilla <code>bonus</code> ja <code>kertoja</code>. Metodin parametriin <code>laskuri</code> ja <code>paljonko</code> kopioituvat siis viitetyyppisen muuttujan <code>bonus</code> viite, ja alkeistyyppisen muuttujan <code>kertoja</code>arvo <code>10</code>. Metodi suorittaa metodissa olevalle muuttujalle <code>laskuri</code> <code>paljonko</code> muuttujan määrittelemän määrän <code>kasvataArvoa()</code>-metodikutsuja. Tämä kuvana:</p>


        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-7.png" /></p>

        <p><em>Metodissa on siis pääohjelmasta täysin erilliset muuttujat!</em></p>

        <p>Viitetyyppisestä muuttujasta kopioituu metodin sisäiseen muuttujaan viite, eli metodin sisäinen muuttuja viittaa vieläkin samaan olioon. Alkeistyyppisestä muuttujasta kopioituu arvo, eli metodin sisäisellä muuttujalla on täysin oma arvonsa.</p>

        <p>Metodi näkee saman laskurin johon muuttuja <code>bonus</code> viittaa, eli metodin tekemä muutos vaikuttaa suoraan olioon. Alkeistyyppien suhteen tilanne on toinen, eli metodille tulee ainoastaan kopio muuttujan <code>kertoja</code> arvosta. Metodista käsin ei siis voi muuttaa alkeistyyppisten muuttujien arvoja.</p>

        <h4>Viitetyyppinen muuttuja metodin paluuarvona</h4>

        <p>Kun metodi palauttaa viitetyyppisen muuttujan, palauttaa se viitteen muualla sijaitsevaan olioon. Metodin palauttaman viitetyyppisen muuttujan voi asettaa muuttujalle samalla tavalla kuin normaalikin asetus tapahtuu, eli yhtäsuuruusmerkin avulla. Katsotaan metodia <code>public Laskuri luoLaskuri(int alkuarvo)</code>, joka luo uuden viitetyyppisen muuttujan.</p>

<pre class="sh_java">
public Laskuri luoLaskuri(int alkuarvo) {
    return new Laskuri(alkuarvo);
}
</pre>

    <p>Metodi luoLaskuri palauttaa metodissa luotuun olioon viittaavan viitteen <code>uusiLaskuri</code>. Uusi olio luodaan aina metodia kutsuttaessa, seuraavassa esimerkissä luomme kaksi erillistä <code>Laskuri</code>-tyyppistä oliota.</p>

<pre class="sh_java">
Laskuri bonus  = luoLaskuri(10);
Laskuri lennon = luoLaskuri(10);
</pre>

        <p>Metodi <code>luoLaskuri</code> luo aina uuden <code>Laskuri</code>-tyyppisen olion. Ensimmäisessä kutsussa, eli kutsussa <code>Laskuri bonus = luoLaskuri(10);</code> asetetaan metodin palauttama viite viitetyyppiseen muuttujaan <code>bonus</code>. Toisessa metodikutsussa luodaan uusi viite, joka asetetaan muuttujaan <code>lennon</code>. Muuttujat <code>bonus</code> ja <code>lennon</code> eivät sisällä samaa viitettä, sillä metodi luo aina uuden olion ja palauttaa viitteen luotuun olioon.</p>


        <h2 id="stat_ja_ei">Static ja ei-static</h2>


        <p>Kerrataan ja täsmennetään Ohjelmoinnin perusteiden luvussa 30 käsiteltyä asiaa. Staattisuudella ja ei-staattisisuudella erotetaan se, mihin muuttuja tai metodi liittyy. Staattiset metodit liittyvät aina luokkaan, kun taas ei-staattiset metodit voivat muokata olion omia muuttujia.</p>

        <h3>Static, luokkakirjastot ja final</h3>

        <p>Static-määreen saavat metodit eivät liity olioihin vaan luokkiin. On mahdollista määritellä myös luokkakohtaisia muuttujia lisäämällä muuttujan eteen määre <code>static</code>. Esimerkiksi <code>Integer.MAX_VALUE</code>, <code>Long.MIN_VALUE</code> ja <code>Double.MAX_VALUE</code> ovat kaikki staattisia muuttujia. Staattisia muuttujia ja metodeja käytetään luokan nimen kautta, esimerkiksi <code>LuokanNimi.muuttuja</code> tai <code>LuokanNimi.metodi()</code>.</p>

        <p>Luokkakirjastoksi kutsutaan luokkaa, jossa on yleiskäyttöisiä metodeja ja muuttujia. Esimerkiksi Javan <code>Math</code>-luokka on luokkakirjasto. Se tarjoaa muun muassa <code>Math.PI</code>-muuttujan. Omien luokkakirjastojen toteuttaminen on usein hyödyllistä. Esimerkiksi Helsingin Seudun Liikenne (HSL) voisi pitää lippujensa hintoja luokkakirjastossa, josta ne löytyisi tarvittaessa.</p>

<pre class="sh_java">
public class HslHinnasto {
    public static final double KERTALIPPU_AIKUINEN = 2.50;
    public static final double RAITIOVAUNULIPPU_AIKUINEN = 2.50;
}
</pre>

        <p>Avainsana <code>final</code> muuttujan määrittelyssä kertoo ettei muuttujaan voi asettaa uutta arvoa kun se on kerran asetettu. Final-tyyppiset muuttujat ovat vakioita, ja niiden tulee sisältää aina arvo. Esimerkiksi suurimman kokonaisluvun kertova luokkamuuttuja <code>Integer.MAX_VALUE</code> on vakiotyyppinen luokkamuuttuja.</p>

        <p>Jos käytössämme on yllä esitelty luokka <code>HslHinnasto</code>, voivat kaikki ohjelmat, jotka tarvitsevat kerta- tai raitiovaunulipun hintaa, päästä niihin käsiksi <code>HslHinnasto</code>-luokan kautta. Seuraavassa esimerkissä esitellään luokka <code>Ihminen</code>, jolla on metodi <code>onkoRahaaKertalippuun()</code>, joka käyttää <code>HslHinnasto</code>-luokasta löytyvää lipun hintaa.</p>

<pre class="sh_java">
public class Ihminen {
    private String name;
    private double rahat;
    // muut oliomuuttujat

    // konstruktori

    public boolean onkoRahaaKertalippuun() {
        if(this.rahat >= HslHinnasto.KERTALIPPU_AIKUINEN) {
            return true;
        }

        return false;
    }

    // muut luokkaan Ihminen liittyvät metodit
}
</pre>

<p>Metodi <code>public boolean onkoRahaaKertalippuun()</code> vertaa luokan <code>Ihminen</code> oliomuuttujaa <code>rahat</code> <code>HslHinnasto</code>-luokan staattiseen muuttujaan <code>KERTALIPPU_AIKUINEN</code>. Metodia <code>onkoRahaaKertalippuun()</code> voi kutsua vain olioviitteen kautta. Esimerkiksi:</p>

<pre class="sh_java">
Ihminen matti = new Ihminen();

if (matti.onkoRahaaKertalippuun()) {
    System.out.println("Ostetaan kertalippu.");
} else {
    System.out.println("Mennään pummilla.");
}
</pre>

<p>Huomaa nimeämiskäytäntö! Kaikki <em>vakiot</em> eli final-määreellä varustetut muuttujat kirjoitetaan ISOLLA_JA_ALAVIIVOILLA.</p> 

<p>Staattiset metodit toimivat vastaavasti. Esimerkiksi Luokka <code>HslHinnasto</code> saattaisi <em>kapseloida</em> muuttujat ja antaa vain <em>aksessorit</em> niihin. Aksessoriksi kutsutaan metodia, jolla voi joko lukea muuttujan arvon tai sijoittaa muuttujalle uuden arvon.</p>

<pre class="sh_java">
public class HslHinnasto {
  private static final double KERTALIPPU_AIKUINEN = 2.50;
  private static final double RAITIOVAUNULIPPU_AIKUINEN = 2.50;

  public static double annaKertalipunHinta() {   // Aksessori
    return KERTALIPPU_AIKUINEN;
  }

  public static double annaRaitiovaunulipunHinta() {   // Aksessori
    return RAITIOVAUNULIPPU_AIKUINEN;
  }
}
</pre>

<p>Tällöin <code>Ihminen</code>-luokan toteutuksessa tulee kutsua metodia<code>annaKertalipunHinta()</code> sen sijaan että kutsuttaisiin muuttujaa suoraan.</p>

<pre class="sh_java">
public class Ihminen {
    private String name;
    private double rahat;
    // muut oliomuuttujat

    // konstruktori

    public boolean onkoRahaaKertalippuun() {
        if(this.rahat >= HslHinnasto.annaKertalipunHinta()) {
            return true;
        }

        return false;
    }

    // muut luokkaan Ihminen liittyvät metodit
}
</pre>


<p>Vaikka Java periaatteessa mahdollistaa staattisten muuttujien käytön, ei niille useinkaan ole tarvetta. Usein staattisten muuttujien käyttö aiheuttaa ongelmia ohjelman rakenteelle, sillä staattiset muuttujat toimivat pahamaineisten <a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad">globaalien muuttujien</a> tapaan. <b>Tällä kurssilla käytämme ainoastaan vakioarvoisia eli final määreen omaavia staattisia muuttujia!</b></p>

    <h3>Ei-static</h3>

    <p>Ei-staattiset metodit ja muuttujat liittyvät olioihin. Oliomuuttujat, eli attribuutit määritellään luokan alussa. Kun olio luodaan <code>new</code>-kutsulla, kaikille oliomuuttujille varataan tila olioon liittyvän viitteen päähän. Muuttujien arvot ovat oliokohtaisia, eli jokaisella oliolla on omat muuttujien arvot. Tutkitaan taas luokkaa <code>Ihminen</code>, jolla on oliomuuttujat <code>nimi</code> ja <code>rahat</code>.</p>

<pre class="sh_java">
public class Ihminen {
  private String name;
  private double rahat;

  // muut tiedot
}
</pre>

    <p>Kun luokasta <em>Ihminen</em> luodaan uusi ilmentymä, alustetaan myös siihen liittyvät muuttujat. Jos viitetyyppistä muuttujaa <code>nimi</code> ei alusteta, saa se arvokseen <em>null</em>-viitteen. Lisätään luokan <em>Ihminen</em> toteutukseen vielä <em>konstruktori</em> ja muutama metodi.</p>

<pre class="sh_java">
public class Ihminen {
    private String name;
    private double rahat;

    // konstruktori
    public Ihminen(String name, double rahat) {
        this.name = nimi;
        this.rahat = rahat;
    }

    public String getName() {
        return this.name;
    }

    public double getRahat() {
        return this.rahat;
    }

    public void lisaaRahaa(double summa) {
        if(summa &gt; 0) {
          this.rahat += summa;
        }
    }

    public boolean onkoRahaaKertalippuun() {
        if(this.rahat >= HslHinnasto.annaKertalipunHinta()) {
            return true;
        }

        return false;
    }
}
</pre>

    <p>Konstruktori <code>Ihminen(String name, double rahat)</code> luo uuden ihmisolion ja palauttaa viitteen siihen. Metodi <code>getName()</code> palauttaa viitteen <code>nimi</code>-olioon, ja <code>getRahat()</code>-metodi palauttaa alkeistyyppisen muuttujan <code>rahat</code>. Metodi <code>lisaaRahaa(double summa)</code> lisaa oliomuuttujaan <code>rahat</code> parametrina annetun summan jos parametrin arvo on suurempi kuin 0.</p>

    <p>Oliometodeja kutsutaan olion viitteen kautta. Seuraava koodiesimerkki luo uuden Ihmis-olion, lisää sille rahaa, ja lopuksi tulostaa sen nimen. Huomaa että metodikutsut ovat muotoa <code>olionNimi.metodinNimi()</code></p>

<pre class="sh_java">
Ihminen matti = new Ihminen("Matti", 5.0);
matti.lisaaRahaa(5); 

if (matti.onkoRahaaKertalippuun()) {
    System.out.println("Ostetaan kertalippu.");
} else {
    System.out.println("Mennään pummilla.");
}
</pre>

    <p>Esimerkki tulostaa "<code>Ostetaan kertalippu</code>".</p>

    <h4>Metodit luokan sisällä</h4>

    <p>Luokan sisäisiä ei-staattisia metodeja voi kutsua myös ilman olio-etuliitettä metodiin liittyvissä luokissa. Esimerkiksi seuraava <code>toString()</code>-metodi <code>Ihminen</code> luokalle, joka kutsuu olioon liittyvää metodia <code>getName()</code>.</p>

<pre class="sh_java">
public class Ihminen {
    // aiemmin toteutetun luokan sisältö

    public String toString() {
        return this.getName();
    }
}
</pre>

    <p>Metodi <code>toString()</code> kutsuu siis luokan sisäistä juuri käsiteltävään olioon liittyvää <code>getName()</code>-metodia. Etuliite <code>this</code> korostaa kutsun liittyvän juuri tähän olioon.</p>

    <p>Ei-staattiset metodit voivat kutsua myös staattisia, eli luokkakohtaisia metodeja. Toisaalta, luokkakohtaiset metodit eivät voi kutsua oliokohtaisia metodeja ilman viitettä itse olioon, sillä ilman viitettä ei päästä käsiksi olioon liittyviin tietoihin.</p>


    <h4>Muuttujat metodien sisällä</h4>

    <p>Metodien sisällä määriteltävät muuttujat ovat metodien suorituksessa käytettäviä apumuuttujia, eikä niitä tule sekoittaa oliomuuttujiin. Alla esimerkki metodista, jossa luodaan metodiin paikallinen muuttuja. Muuttuja <code>indeksi</code> on olemassa ja käytössä vain metodin suorituksen ajan.</p>

<pre class="sh_java">
public class ... {
    ...

    public static void tulostaTaulukko(String[] taulukko) {
        int indeksi = 0;

        while(indeksi &lt; taulukko.length) {
            System.out.println(taulukko[indeksi]);
            indeksi++;
        }
    }
}
</pre>

    <p>Metodissa <code>tulostaTaulukko()</code> luodaan apumuuttuja <code>indeksi</code> jota käytetään taulukon läpikäynnissä. Muuttuja <code>indeksi</code> on olemassa vain metodin suorituksen ajan.</p>


<div class="tehtavat">
  <h3>Tavara, Matkalaukku ja Lastiruuma</h3>

  <p>Tässä tehtäväsarjassa tehdään luokat <code>Tavara</code>, <code>Matkalaukku</code> ja <code>Lastiruuma</code>, joiden avulla harjoitellaan olioita, jotka sisältävät toisia olioita.</p>

  <h4 class="req">Tavara-luokka</h4>

  <p>Tee luokka <code>Tavara</code>, josta muodostetut oliot vastaavat erilaisia tavaroita. Tallennettavat tiedot ovat tavaran nimi ja paino (kg).</p>

  <p>Lisää luokkaan seuraavat metodit:</p>

  <ul>
    <li>Konstruktori, jolle annetaan parametrina tavaran nimi ja paino</li>
    <li>Metodi <code>public String getName()</code>, joka palauttaa tavaran nimen</li>
    <li>Metodi <code>public int getPaino()</code>, joka palauttaa tavaran painon</li>
    <li>Metodi <code>public String toString()</code>, joka palauttaa characterStringn muotoa "nimi (paino kg)"</li>
  </ul>

  <p>Seuraavassa on luokan käyttöesimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);

        System.out.println("Bookn nimi: " + kirja.getName());
        System.out.println("Bookn paino: " + kirja.getPaino());

        System.out.println("Book: " + kirja);
        System.out.println("Puhelin: " + puhelin);
    }
}
</pre>

<p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
Bookn nimi: Aapiskukko
Bookn paino: 2
Book: Aapiskukko (2 kg)
Puhelin: Nokia 3210 (1 kg)
</pre>

<h4 class="req">Matkalaukku-luokka</h4>

  <p>Tee luokka <code>Matkalaukku</code>. Matkalaukkuun liittyy tavaroita ja maksimipaino, joka määrittelee tavaroiden suurimman mahdollisen yhteispainon.</p>

  <p>Lisää luokkaan seuraavat metodit:</p>

  <ul>
    <li> Konstruktori, jolle annetaan maksimipaino</li>
    <li> Metodi <code>public void lisaaTavara(Tavara tavara)</code>, joka lisää parametrina annettavan tavaran matkalaukkuun. Metodi ei palauta mitään arvoa.</li>
    <li> Metodi <code>public String toString()</code>, joka palauttaa characterStringn muotoa "x tavaraa (y kg)"</li>
  </ul>

  <p>Tavarat kannattaa tallentaa <code>ArrayList</code>-olioon:</p>

<pre class="sh_java">
ArrayList&lt;Tavara&gt; tavarat = new ArrayList&lt;Tavara&gt;();
</pre>

  <p>Luokan <code>Matkalaukku</code> tulee valvoa, että sen sisältämien tavaroiden yhteispaino ei ylitä maksimipainoa. Jos maksimipaino ylittyisi lisättävän tavaran vuoksi, metodi <code>lisaaTavara</code> ei saa lisätä uutta tavaraa laukkuun.</p>

  <p>Seuraavassa on luokan käyttöesimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

        Matkalaukku matkalaukku = new Matkalaukku(5);
        System.out.println(matkalaukku);

        matkalaukku.lisaaTavara(kirja);
        System.out.println(matkalaukku);

        matkalaukku.lisaaTavara(puhelin);
        System.out.println(matkalaukku);

        matkalaukku.lisaaTavara(tiiliskivi);
        System.out.println(matkalaukku);
    }
}
</pre>

  <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
0 tavaraa (0 kg)
1 tavaraa (2 kg)
2 tavaraa (3 kg)
2 tavaraa (3 kg)
</pre>

  <h4>Kielenhuoltoa</h4>

  <p>Ilmoitukset "0 tavaraa" ja "1 tavaraa" eivät ole kovin hyvää suomea &ndash; paremmat muodot olisivat "ei tavaroita" ja "1 tavara". Tee tämä muutos luokkaan <code>Matkalaukku</code>.</p>

  <p>Nyt edellisen ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
ei tavaroita (0 kg)
1 tavara (2 kg)
2 tavaraa (3 kg)
2 tavaraa (3 kg)
</pre>

<h4 class="req">Kaikki tavarat</h4>

<p>Lisää luokkaan <code>Matkalaukku</code> seuraavat metodit:</p>

<ul>
  <li> metodi <code>tulostaTavarat</code>, joka tulostaa kaikki matkalaukussa olevat tavarat</li>
  <li> metodi <code>yhteispaino</code>, joka palauttaa tavaroiden yhteispainon</li>
</ul>

<p>Seuraavassa on luokan käyttöesimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

        Matkalaukku matkalaukku = new Matkalaukku(10);
        matkalaukku.lisaaTavara(kirja);
        matkalaukku.lisaaTavara(puhelin);
        matkalaukku.lisaaTavara(tiiliskivi);

        System.out.println("Matkalaukussa on seuraavat tavarat:");
        matkalaukku.tulostaTavarat();
        System.out.println("Yhteispaino: " + matkalaukku.yhteispaino() + " kg");
    }
}
</pre>

  <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
Matkalaukussa on seuraavat tavarat:
Aapiskukko (2 kg)
Nokia 3210 (1 kg)
Tiiliskivi (4 kg)
Yhteispaino: 7 kg
</pre>


  <p>Muokkaa myös luokkaasi siten, että käytät vain kahta oliomuuttujaa. Toinen sisältää maksimipainon, toinen on lista laukussa olevista tavaroista.</p>

<h4 class="req">Raskain tavara</h4>

  <p>Lisää vielä luokkaan <code>Matkalaukku</code> metodi <code>raskainTavara</code>, joka palauttaa painoltaan suurimman tavaran. Jos yhtä raskaita tavaroita on useita, metodi voi palauttaa minkä tahansa niistä. Metodin tulee palauttaa olioviite. Jos laukku on tyhjä, palauta arvo <em>null</em>.</p>

  <p>Seuraavassa on luokan käyttöesimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("Tiiliskivi", 4);

        Matkalaukku matkalaukku = new Matkalaukku(10);
        matkalaukku.lisaaTavara(kirja);
        matkalaukku.lisaaTavara(puhelin);
        matkalaukku.lisaaTavara(tiiliskivi);

        Tavara raskain = matkalaukku.raskainTavara();
        System.out.println("Raskain tavara: " + raskain);
    }
}
</pre>

  <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
Raskain tavara: Tiiliskivi (4 kg)
</pre>

<h4 class="req">Lastiruuma-luokka</h4>

  <p>Tee luokka <code>Lastiruuma</code>, johon liittyvät seuraavat metodit:</p>

  <ul>
    <li> konstruktori, jolle annetaan maksimipaino</li>
    <li> metodi <code>public void lisaaMatkalaukku(Matkalaukku laukku)</code>, joka lisää parametrina annetun matkalaukun lastiruumaan</li>
    <li> metodi <code>public String toString()</code>, joka palauttaa characterStringn muotoa "x matkalaukkua (y kg)"</li>
  </ul>

  <p>Tallenna matkalaukut sopivaan <code>ArrayList</code>-rakenteeseen.</p>

  <p>Luokan <code>Lastiruuma</code> tulee valvoa, että sen sisältämien matkalaukkujen yhteispaino ei ylitä maksimipainoa. Jos maksimipaino ylittyisi uuden matkalaukun vuoksi, metodi <code>lisaaMatkalaukku</code> ei saa lisätä uutta matkalaukkua.</p>

<p>Seuraavassa on luokan käyttöesimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

        Matkalaukku matinLaukku = new Matkalaukku(10);
        matinLaukku.lisaaTavara(kirja);
        matinLaukku.lisaaTavara(puhelin);

        Matkalaukku pekanLaukku = new Matkalaukku(10);
        pekanLaukku.lisaaTavara(tiiliskivi);

        Lastiruuma lastiruuma = new Lastiruuma(1000);
        lastiruuma.lisaaMatkalaukku(matinLaukku);
        lastiruuma.lisaaMatkalaukku(pekanLaukku);

        System.out.println(lastiruuma);
    }
}
</pre>

  <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
2 matkalaukkua (7 kg)
</pre>

<h4 class="req">Lastiruuman sisältö</h4>

  <p>Lisää luokkaan <code>Lastiruuma</code> metodi <code>public void tulostaTavarat()</code>, joka tulostaa kaikki lastiruuman matkalaukuissa olevat tavarat.</p>

<p>Seuraavassa on luokan käyttöesimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

        Matkalaukku matinLaukku = new Matkalaukku(10);
        matinLaukku.lisaaTavara(kirja);
        matinLaukku.lisaaTavara(puhelin);

        Matkalaukku pekanLaukku = new Matkalaukku(10);
        pekanLaukku.lisaaTavara(tiiliskivi);

        Lastiruuma lastiruuma = new Lastiruuma(1000);
        lastiruuma.lisaaMatkalaukku(matinLaukku);
        lastiruuma.lisaaMatkalaukku(pekanLaukku);

        System.out.println("Ruuman matkalaukuissa on seuraavat tavarat:");
        lastiruuma.tulostaTavarat();
    }
}
</pre>

<p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
Ruuman matkalaukuissa on seuraavat tavarat:
Aapiskukko (2 kg)
Nokia 3210 (1 kg)
tiiliskivi (4 kg)
</pre>

<h4>Paljon tiiliskiviä</h4>

  <p>Testataan vielä, että lastiruuman toiminta on oikea eikä maksimipaino pääse ylittymään. Tee Main-luokkaan metodi <code>public static void lisaaMatkalaukutTiiliskivilla(Lastiruuma lastiruuma)</code>, joka lisää parametrina annettuun lastiruumaan 100 matkalaukkua, joissa jokaisessa on yksi tiiliskivi. Tiiliskivien painot ovat 1, 2, 3, ..., 100 kg.</p>

  <p>Ohjelman runko on seuraava:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Lastiruuma lastiruuma = new Lastiruuma(1000);
        lisaaMatkalaukutTiiliskivilla(lastiruuma);
        System.out.println(lastiruuma);
    }

    public static void lisaaMatkalaukutTiiliskivilla(Lastiruuma lastiruuma) {
        // 100 matkalaukun lisääminen, jokaiseen tulee tiiliskivi
    }
}
</pre>

  <p>Ohjelman tulostus on seuraava:</p>

<pre>
44 matkalaukkua (990 kg)
</pre>

</div>

    <h2 id="hashmap">Hajautustaulu (HashMap)</h2>

    <p><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html">Hajautustaulu</a> on yksi Javan yleishyödyllisistä tietorakenteista. Hajautustaulun ideana on laskea olioon liittyvälle <em>avaimelle</em>, eli yksilöivälle arvolle (esimerkiksi henkilötunnus, opiskelijanumero, puhelinnumero), indeksi hajautustaulun sisältämästä taulukosta. Indeksin avulla Avaimen muuttamista indeksiksi kutsutaan <em>hajautukseksi</em>, joka tarkoittaa indeksin laskemista. Hajautus tapahtuu aina tietyn hajautusfunktion avulla, joka takaa että tietyllä avaimella saadaan aina sama indeksi.</p>

    <p>Avaimen perusteella lisääminen ja hakeminen mahdollistaa erittäin nopean hakemisen. Sen sijaan että tutkisimme taulukon alkiot järjestyksessä (pahimmassa tapauksessa joudumme käymään kaikki alkiot läpi), tai etsisimme arvoa binäärihaulla (pahimmassa tapauksessa käymme taulukon kokoon liittyvän logaritmisen määrän alkoita läpi), voimme periaatteessa katsoa tasan yhtä taulukon indeksiä ja tarkistaa onko indeksiin tallennettu arvoa vai ei.</p>

    <p>Hajautustaulu käyttää avaimen arvon laskemiseen <code>Object</code>-luokassa määriteltyä <code>hashCode()</code>-metodia, jonka jokainen toteutettu luokka <em>perii</em>. Emme kuitenkaan tutustu hajautustaulun toteutukseen tarkemmin tällä kurssilla. Perintään palaamme noin viikolla 4.</p>


    <p>Javan luokka <code>HashMap</code> kapseloi eli piilottaa hajautustaulun toteutuksen, ja tarjoaa valmiit metodit sen käyttöön.</p>

    <p>Hajautustaulua luodessa tarvitaan kaksi <em>tyyppiparametria</em>, avainmuuttujan tyyppi ja tallennettavan olion tyyppi. Seuraava esimerkki käyttää avaimena <code>String</code>-tyyppistä oliota, ja tallennettavana oliona <code>String</code>-tyyppistä oliota. </p>


<pre class="sh_java">
HashMap&lt;String, String&gt; numerot = new HashMap&lt;String, String&gt;();
numerot.put("Yksi", "Uno");
numerot.put("Kaksi", "Dos");

String kaannos = numerot.get("Yksi");
System.out.println(kaannos);

System.out.println(numerot.get("Kaksi"));
System.out.println(numerot.get("Kolme"));
System.out.println(numerot.get("Uno"));
</pre>

<pre>
Uno
Dos
null
null
</pre>


    <p>Esimerkissä luodaan hajatustaulu, jonka avaimena ja tallennettavana oliona characterString. Hajautustauluun lisätään tietoa <code>put()</code>-metodilla, joka saa parametreikseen viitteet avaimeen ja tallennettavaan olioon. Metodi <code>get()</code>-palauttaa parametrina annettuun avaimeen liittyvän viitteen tai arvon <code>null</code> jos avaimella ei löydy viitettä.</p>

    <p>Hajautustaulussa tiettyä avainta vastaa aina yksi arvo. Jos jo olemassaolevalla avaimella tallennetaan uusi arvo, katoaa vanha arvo hajautustaulusta.</p>

<pre class="sh_java">
HashMap&lt;String, String&gt; numerot = new HashMap&lt;String, String&gt;();
numerot.put("Yksi", "Uno");
numerot.put("Kaksi", "Dos");
numerot.put("Yksi", "Ein");

String kaannos = numerot.get("Yksi");
System.out.println(kaannos);

System.out.println(numerot.get("Kaksi"));
System.out.println(numerot.get("Kolme"));
System.out.println(numerot.get("Uno"));
</pre>

    <p>Koska avain "<code>Yksi</code>" asetetaan uudestaan, on esimerkin tulostus nyt seuraavanlainen.</p>

<pre>
Ein
Dos
null
null
</pre>

<div class="tehtavat">

  <h3>Lempinimet</h3>

  <p>Luo <code>main</code>-metodissa
  uusi <code>HashMap&lt;String,String&gt;</code>-olio. Tallenna tähän
  HashMappiin seuraavien henkilöiden nimet ja lempinimet niin, että
  nimi on avain ja lempinimi on arvo. Käytä pelkkiä pieniä kirjaimia.</p>

  <ul>
    <li>matin lempinimi on mage</li>
    <li>mikaelin lempinimi on mixu</li>
    <li>arton lempinimi on arppa</li>
  </ul>

  <p>Tämän jälkeen hae HashMapistä mikaelin lempinimi ja tulosta se.</p>

<p>Testit edellyttävät että kirjoitat nimet pienellä alkukirjaimella.</p>

</div>

        <h3 id="kirjastotietokanta">Kirjojen haku hajautustaulun avulla</h3>

        <p>Tutkitaan hajautustaulun toimintaa seuraavaksi kirjastoesimerkin avulla. Bookstosta voi hakea kirjoja kirjan nimen perusteella, nimi toimii siis kirjan avaimena. Jos annetulle nimelle löytyy kirja, saadaan siihen liittyvä viite ja samalla kirjan tiedot. Luodaan ensin esimerkkiluokka <code>Book</code>, jolla on oliomuuttujina nimi ja kirjaan liittyvä sisältö.</p>

<pre class="sh_java">
public class Book {
    private String name;
    private String sisalto;
    private int publishingYear;

    public Book(String name, int publishingYear, String sisalto) {
        this.name = nimi;
        this.publishingYear = julkaisuvuosi;
        this.sisalto = sisalto;
    }

    public String getName() {
        return this.name;
    }

    public void setNimi(String name) {
        this.name = nimi;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    public void setJulkaisuvuosi(int publishingYear) {
        this.publishingYear = julkaisuvuosi;
    }

    public String getSisalto() {
        return this.sisalto;
    }

    public void setSisalto(String sisalto) {
        this.sisalto = sisalto;
    }

    public String toString() {
        return "Nimi: " + this.name + " (" + this.publishingYear + ")\n"
                + "Sisältö: " + this.sisalto;
    }
}
</pre>

        <p>Luodaan seuraavaksi hajautustaulu, joka käyttää avaimena kirjan nimeä eli String-tyyppistä oliota, ja tallentaa viitteitä <code>Book</code>-olioihin.</p>

<pre class="sh_java">
HashMap&lt;String, Book&gt; kirjahakemisto = new HashMap&lt;String, Book&gt;();
</pre>

    <p>Yllä oleva hajautustaulu käyttää avaimena <code>String</code>-oliota. Laajennetaan esimerkkiä siten, että kirjahakemistoon lisätään kaksi kirjaa, <code>"Järki ja tunteet"</code> ja <code>"Ylpeys ja ennakkoluulo"</code>.</p>

<pre class="sh_java">
Book senseAndSensibility = new Book("Järki ja tunteet", 1811, "...");
Book prideAndPrejudice = new Book("Ylpeys ja ennakkoluulo", 1813, "....");

HashMap&lt;String, Book&gt; kirjahakemisto = new HashMap&lt;String, Book&gt;();
kirjahakemisto.put(senseAndSensibility.getName(), senseAndSensibility);
kirjahakemisto.put(prideAndPrejudice.getName(), prideAndPrejudice);
</pre>

        <p>Bookhakemistosta voi hakea kirjoja kirjan nimellä. Haku kirjalla <code>"Viisasteleva sydän"</code> ei tuota osumaa, jolloin hajautustaulu palauttaa <code>null</code>-viitteen. Book "Ylpeys ja ennakkoluulo" kuitenkin löytyy.</p>

<pre class="sh_java">
Book kirja = kirjahakemisto.get("Viisasteleva sydän");
System.out.println(kirja);
System.out.println();
kirja = kirjahakemisto.get("Ylpeys ja ennakkoluulo");
System.out.println(kirja);
</pre>

<pre>
null

Nimi: Ylpeys ja ennakkoluulo (1813)
Sisältö: ...
</pre>

    <p>Hajautustaulu on hyödyllinen silloin kun tiedetään avain minkä perusteella halutaan hakea. Avaimet ovat aina yksilöllisiä, joten saman avaimen taakse ei voi tallettaa montaa eri oliota. Tallennettava olio voi toki olla lista tai toinen hajautustaulukko!</p>

    <h3 id="kapseloitu_kirjasto">Booksto</h3>

    <p>Yllä olevan kirjahakemiston ongelmana on se, että kirjoja haettaessa täytyy muistaa kirjan nimi merkki merkiltä oikein. Javan valmis <code>String</code>-luokka tarjoaa meille välineet tähänkin. Metodi <code>toLowerCase()</code> muuttaa characterStringn kirjaimet pieniksi, ja metodi <code>trim()</code> poistaa characterStringn alusta ja lopusta tyhjät merkit (esimerkiksi välilyönnit). Tietokoneen käyttäjät usein kirjoittavat tekstin alkuun tai loppuun vahingossa välilyöntejä.</p>

<pre class="sh_java">
String teksti = "Ylpeys ja ennakkoluulo ";
teksti = teksti.toLowerCase(); // teksti nyt "ylpeys ja ennakkoluulo "
teksti = teksti.trim() // teksti nyt "ylpeys ja ennakkoluulo"
</pre>

    <p>Luodaan luokka <code>Booksto</code>, joka kapseloi kirjat sisältävän hajautustaulun ja mahdollistaa kirjoitusasusta riippumattoman kirjojen haun. Lisätään <code>Booksto</code>-luokalle metodit <code>lisaaBook(Book kirja)</code> ja <code>poistaBook(String kirjanNimi)</code>. Huomaamme jo nyt että characterStringn siistimistä tarvitsisi useammassa metodissa, joten tehdään siitä erillinen metodi <code>private String siisticharacterString(String characterString)</code>.</p>

<pre class="sh_java">
public class Booksto {
    private HashMap&lt;String, Book&gt; hakemisto;

    public Booksto() {
        this.hakemisto = new HashMap&lt;String, Book&gt;();
    }

    public void lisaaBook(Book kirja) {
        String name = siisticharacterString(kirja.getName());

        if(this.hakemisto.containsKey(nimi)) {
            System.out.println("Book on jo kirjastossa!");
        } else {
            hakemisto.put(nimi, kirja);
        }
    }

    public void poistaBook(String kirjanNimi) {
        kirjanNimi = siisticharacterString(kirjanNimi);

        if(this.hakemisto.containsKey(kirjanNimi)) {
            this.hakemisto.remove(kirjanNimi);
        } else {
            System.out.println("Booka ei löydy, ei voida poistaa!");
        }
    }

    private String siisticharacterString(String characterString) {
        if (characterString == null) {
            return "";
        }

        characterString = characterString.toLowerCase();
        return characterString.trim();
    }
}
</pre>
        <p>Toteutetaan kirjan hakutoiminnallisuus siten, että kirjaa haetaan hajautusrakenteesta sen nimellä.</p>

<pre class="sh_java">
    public Book haeBook(String kirjanNimi) {
        kirjanNimi = siisticharacterString(kirjanNimi);
        return this.hakemisto.get(kirjanNimi);
    }
</pre>

    <p>Yllä oleva metodi palauttaa haetun kirjan jos sellainen löytyy, muulloin <code>null</code>-arvon. Voimme myös käydä kaikki hakemiston avaimet läpi  yksitellen, etsien esimerkiksi alkuosaa kirjan nimestä. Tällä tavalla etsiessä menetämme kuitenkin hajautustaulun nopeusedun, sillä huonoimmassa tapauksessa joudumme käymään kaikkien kirjojen nimet läpi. Hakeminen alkuosan perusteella onnistuisi hajautustaulun <code>keySet()</code>-metodin avulla. Metodi <code>keySet()</code> palauttaa avaimet joukossa, jonka voi käydä läpi <code>for-each</code> -toistolauseella.</p>

<pre class="sh_java">
    public Book haeBookNimenAlkuosalla(String kirjanAlkuosa) {
        kirjanAlkuosa = siisticharacterString(kirjanAlkuosa);

        for (String avain: this.hakemisto.keySet()) {
            if (avain.startsWith(kirjanAlkuosa)) {
                return this.hakemisto.get(avain);
            }
        }

        return null;
    }
</pre>

    <p>Jätämme yllä olevan metodin kuitenkin pois kirjastostamme. Bookstosta puuttuu oleellisista toiminnoista vielä kirjojen listaaminen. Luodaan metodi <code>public ArrayList&lt;Book&gt; kirjalista()</code>, joka palauttaa listan kirjaston kirjoista. Metodi <code>kirjalista</code> hyödyntää hajautustaulun tarjoamaa <code>values()</code>-metodia. Metodi <code>values()</code> palauttaa kokoelman kirjaston kirjoista, jonka voi antaa parametrina <code>ArrayList</code>-luokan konstruktorille.</p>

<pre class="sh_java">
public class Booksto {
    private HashMap&lt;String, Book&gt; hakemisto;

    public Booksto() {
        this.hakemisto = new HashMap&lt;String, Book&gt;();
    }

    public Book haeBook(String kirjanNimi) {
        kirjanNimi = siisticharacterString(kirjanNimi);
        return this.hakemisto.get(kirjanNimi);
    }

    public void lisaaBook(Book kirja) {
        String name = siisticharacterString(kirja.getName());

        if(this.hakemisto.containsKey(nimi)) {
            System.out.println("Book on jo kirjastossa!");
        } else {
            this.hakemisto.put(nimi, kirja);
        }
    }

    public void poistaBook(String kirjanNimi) {
        kirjanNimi = siisticharacterString(kirjanNimi);

        if(this.hakemisto.containsKey(kirjanNimi)) {
            this.hakemisto.remove(kirjanNimi);
        } else {
            System.out.println("Booka ei löydy, ei voida poistaa!");
        }
    }

    public ArrayList&lt;Book&gt; kirjalista() {
        return new ArrayList&lt;Book&gt;(this.hakemisto.values());
    }

    private String siisticharacterString(String characterString) {
        if (characterString == null) {
            return "";
        }

        characterString = characterString.toLowerCase();
        return characterString.trim();
    }
}
</pre>

    <p>Yksi ohjelmoinnin periaatteista on ns. <em>DRY</em>-periaate (Don't Repeat Yourself), jolla pyritään välttämään saman koodin olemista useassa paikassa. characterStringn pieneksi muuttaminen ja <em>trimmaus</em>, eli tyhjien merkkien poisto alusta ja lopusta, olisi toistunut useasti kirjastoluokassamme ilman metodia <code>siisticharacterString</code>. Toistuvaa koodia ei usein huomaa ennen kuin sitä on jo kirjoittanut, jolloin sitä päätyy koodiin lähes pakosti. Tässä ei kuitenkaan ole mitään pahaa. Tärkeintä on että siistit koodiasi sitä mukaa kun huomaat siistimistä vaativia tilanteita.</p>


    <h3>Alkeistyyppiset muuttujat hajautustaulussa</h3>

    <p>Huomaa että hajautustaulun avain ja tallennettava olio ovat aina viitetyyppisiä. Jos haluat käyttää alkeistyyppisiä muuttujia avaimena tai tallennettavana arvona, on niille olemassa myös viitetyyppiset vastineet. Alla on esitelty muutama.</p>

    <p>
      <table>
        <tr><th>Alkeistyyppi</th><th>Viitetyyppinen vastine</th><tr>
        <tr><td>int</td><td><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Integer.html" target="_blank">Integer</a></td></tr>
        <tr><td>double</td><td><a href="docs.oracle.com/javase/6/docs/api/java/lang/Double.html" target="_blank">Double</a></td></tr>
        <tr><td>char</td><td><a href="docs.oracle.com/javase/6/docs/api/java/lang/Character.html" target="_blank">Character</a></td></tr>
      </table>
    </p>

        <p>Java oikeastaan kapseloi alkeistyyppiset muuttujat automaattisesti viitetyyppisiksi muuttujiksi tarvittaessa. Vaikka numero <code>1</code> on alkeistyyppinen muuttuja, voit käyttää sitä suoraan <code>Integer</code>-tyyppisenä avaimena seuraavasti.</p>

<pre class="sh_java">
HashMap&lt;Integer, String&gt; taulu = new HashMap&lt;Integer, String&gt;();
taulu.put(1, "Ole!");
</pre>

        <p>Alkeistyyppisten muuttujien automaattista muunnosta viitetyyppisiksi kutsutaan Javassa <em>auto-boxingiksi</em>, eli automaattiseksi "laatikkoon" asettamiseksi. Vastaava onnistuu myös toisinpäin. Voimme luoda metodin, joka palauttaa hajautustaulun sisältämän kokonaisluvun. Seuraavassa esimerkissä olevassa metodissa <code>lisaaBongaus</code> tapahtuu automaattinen tyyppimuunnos.</p>


<pre class="sh_java">
public class Rekisteribongaus {
    private HashMap&lt;String, Integer&gt; bongatut;

    public Numerokirjanpito() {
        this.bongatut = new HashMap&lt;String, Integer&gt;();
    }

    public void lisaaBongaus(String name, int numero) {
        this.bongatut.put(nimi, numero);
    }

    public int viimeisinBongaus(String name) {
        this.bongatut.get(nimi);
    }
}
</pre>

        <p>Vaikka hajautustaulu sisältää Integer-tyyppisiä olioita, osaa Java myös muuntaa tietyt viitetyyppiset muuttujat myös niiden alkeistyyppisiksi vastineiksi. Esimerkiksi <code>Integer</code>-oliot muuttuvat tarpeen vaatiessa <code>int</code>-tyyppisiksi muuttujiksi. Tässä piilee kuitenkin vaara!  Jos yritämme muuttaa null-viitettä numeroksi, näemme virheen <em>java.lang.reflect.InvocationTargetException</em>. Kun teemme automaattista muunnosta, tulee varmistaa että muunnettava arvo ei ole null. Yllä olevassa ohjelmassa oleva <code>viimeisinBongaus</code>-metodi tulee korjata esimerkiksi seuraavasti.</p>

<pre class="sh_java">
    public int viimeisinBongaus(String name) {
        if(this.bongatut.containsKey(nimi) {
            return this.bongatut.get(nimi);
        }

        return 0;
    }
</pre>



<div class="tehtavat">
  <h3>Velkakirja</h3>

  <p>Luo luokka <code>Velkakirja</code>, jolla on seuraavat toiminnot:</p>

  <ul>
    <li> konstruktori <code>public Velkakirja()</code> luo uuden velkakirjan</li>
    <li> metodi <code>public void asetaLaina(String kenelle, double maara)</code> tallettaa velkakirjaan merkinnän lainasta tietylle henkilölle.</li>
    <li> metodi <code>public double paljonkoVelkaa(String kuka)</code> palauttaa velan määrän annetun henkilön nimen perusteella</li>
  </ul>

<p>Luokkaa käytetään seuraavalla tavalla:</p>

<pre class="sh_java">
  Velkakirja matinVelkakirja = new Velkakirja();
  matinVelkakirja.asetaLaina("Arto", 51.5);
  matinVelkakirja.asetaLaina("Mikael", 30);

  System.out.println(matinVelkakirja.paljonkoVelkaa("Arto"));
  System.out.println(matinVelkakirja.paljonkoVelkaa("Joel"));
</pre>

<p>Yllä oleva esimerkki tulostaisi:</p>

<pre>
51.5
0
</pre>

<p>Ole tarkkana tilanteessa, jossa kysytään velattoman ihmisen velkaa. Kertaa luvun 4.3 lopun esimerkki!</p>

  <p>Huom! Velkakirjan ei tarvitse huomioida vanhoja lainoja. Kun asetat uuden velan henkilölle jolla on vanha velka, vanha velka unohtuu.</p>  

<pre class="sh_java">
  Velkakirja matinVelkakirja = new Velkakirja();
  matinVelkakirja.asetaLaina("Arto", 51.5);
  matinVelkakirja.asetaLaina("Arto", 10.5);

  System.out.println(matinVelkakirja.paljonkoVelkaa("Arto"));
</pre>

<pre>
10.5
</pre>

  <h3>Sanakirja</h3>

  <p>Tässä tehtäväsarjassa toteutetaan sanakirja, josta voi hakea suomen kielen sanoille englanninkielisiä käännöksiä. Sanakirjan tekemisessä käytetään <code>HashMap</code>-tietorakennetta.</p>

  <h4 class="req">Luokka Sanakirja</h4>

  <p>Toteuta luokka nimeltä <code>Sanakirja</code>. Luokalla on aluksi seuraavat metodit:</p>

  <ul>
    <li> <code>public String kaanna(String sana)</code> metodi palauttaa parametrinsa käännöksen. Jos sanaa ei tunneta, palautetaan <em>null</em>.</li>
    <li> <code>public void lisaa(String sana, String kaannos)</code> metodi lisää sanakirjaan uuden käännöksen</li>
  </ul>

  <p>Toteuta luokka Sanakirja siten, että sen ainoa oliomuuttuja on <code>HashMap</code>-tietorakenne.</p>

  <p>Testaa sanakirjasi toimintaa:</p>

<pre class="sh_java">
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    sanakirja.lisaa("cembalo", "harpsichord");

    System.out.println(sanakirja.kaanna("apina"));
    System.out.println(sanakirja.kaanna("porkkana"));
</pre>

<pre>
monkey
null
</pre>

<h4>Sanojen lukumäärä</h4>

  <p>Lisää sanakirjaan metodi <code>public int sanojenLukumaara()</code>, joka palauttaa sanakirjassa olevien sanojen lukumäärän.</p>

<pre class="sh_java">
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    System.out.println(sanakirja.sanojenLukumaara());

    sanakirja.lisaa("cembalo", "harpsichord");
    System.out.println(sanakirja.sanojenLukumaara());
</pre>


<pre>
2
3
</pre>

<h4>Kaikkien sanojen listaaminen</h4>

  <p>Lisää sanakirjaan metodi <code>public ArrayList&lt;String&gt; kaannoksetListana()</code> joka palauttaa sanakirjan sisällön listana <i>avain = arvo</i> muotoisia characterStringja.</p>

<pre class="sh_java">
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    sanakirja.lisaa("cembalo", "harpsichord");

    ArrayList&lt;String&gt; kaannokset = sanakirja.kaannoksetListana();
    for(String kaannos: kaannokset) {
        System.out.println(kaannos);
    }
</pre>

<pre>
banaani = banana
apina = monkey
cembalo = harpsichord
</pre>

<p><strong>Vihje:</strong> saat käytyä kaikki HashMapissa olevat avaimet läpi metodin <code>keySet</code> avulla seuraavasti:</p>

<pre class="sh_java">
    HashMap&lt;String, String&gt; sanaparit = new HashMap&lt;String, String&gt;();

    sanaparit.put("apina", "eläin");
    sanaparit.put("etelä", "ilmansuunta");
    sanaparit.put("sauerkraut", "ruoka");

    for ( String avain : sanaparit.keySet() ) {
        System.out.print( avain + " " );
    }
 
    // tulostuu apina etelä sauerkraut
</pre>



  <h4 class="req">Tekstikäyttöliittymän alku</h4>

  <p>Harjoitellaan tässäkin tehtävässä erillisen tekstikäyttöliittymän tekemistä. Luo luokka <code>Tekstikayttoliittyma</code>, jolla on seuraavat metodit
    <ul>
      <li> konstruktori <code>public Tekstikayttoliittyma(Scanner lukija, Sanakirja sanakirja)</code></li>
      <li> metodi <code>public void kaynnista()</code>, joka käynnistää tekstikäyttöliittymän.</li>
    </ul>
  </p>

<p>Tekstikäyttöliittymä tallettaa konstruktorin parametrina saamansa lukijan ja sanakirjan oliomuuttujiin. Muita oliomuuttujia ei tarvita.
<strong>
Käyttäjän syötteen lukeminen tulee hoitaa konstruktorin parametrina saatua lukija-olioa käyttäen! Myös kaikki käännökset on talletettava  konstruktorin parametrina saatuun sanakirja-olioon. Tekstikäyttöliittymä ei saa luoda olioita itse! 
</strong>
</p>

<p><strong>HUOM:</strong> vielä uudelleen edellinen, eli <strong>Tekstikäyttöliittymä ei saa luoda itse skanneria</strong> vaan sen on käytettävä parametrina saamaansa skanneria syötteiden lukemiseen!</p>

  <p>Tekstikäyttöliittymässä tulee aluksi olla vain komento <code>lopeta</code>, joka poistuu tekstikäyttöliittymästä. Jos käyttäjä syöttää jotain muuta, käyttäjälle sanotaan "Tuntematon komento".</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.kaynnista();
</pre>

<pre>
Komennot:
  lopeta - poistuu käyttöliittymästä

Komento: <font color="red">apua</font>
Tuntematon komento.

Komento: <font color="red">lopeta</font>
Hei hei!
</pre>

  <h4 class="req">Sanojen lisääminen ja kääntäminen</h4>

  <p>Lisää tekstikäyttöliittymälle komennot <code>lisaa</code> ja <code>kaanna</code>. Komento <code>lisaa</code> lisää kysyy käyttäjältä sanaparin ja lisää sen sanakirjaan. Komento <code>kaanna</code> kysyy käyttäjältä sanaa ja tulostaa sen käännöksen.</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.kaynnista();
</pre>

<pre>
Komennot:
  lisaa - lisää sanaparin sanakirjaan
  kaanna - kysyy sanan ja tulostaa sen käännöksen
  lopeta - poistuu käyttöliittymästä

Komento: <font color="red">lisaa</font>
Suomeksi: <font color="red">porkkana</font>
Käännös: <font color="red">carrot</font>

Komento: <font color="red">kaanna</font>
Anna sana: <font color="red">porkkana</font>
Käännös: carrot

Komento: <font color="red">lopeta</font>
Hei hei!
</pre>

</div>


<h2>Kohti testauksen automatisointia</h2>

<p>Ohjelman testaaminen käsin on toivottoman työlästä. Syötteen antaminen on kuitenkin mahdollista automatisoida esimerkiksi syöttämällä Scanner-oliolle luettava characterString. Alla on annettu esimerkki siitä, miten yllä olevassa tehtävässä luotua ohjelmaa voi testata automaattisesti.</p>

<pre class="sh_java">
    String syote = "kaanna\n" + "apina\n"  +
                   "kaanna\n" + "juusto\n" +
                   "lisaa\n"  + "juusto\n" + "cheese\n" +
                   "kaanna\n" + "juusto\n" +
                   "lopeta\n";

    Scanner lukija = new Scanner(syote);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.kaynnista();
</pre>

  <p>Ohjelma tulostus näyttää vain ohjelman antaman tulostuksen, ei käyttäjän tekemiä komentoja.</p>

<pre>
Komennot:
  lisaa - lisää sanaparin sanakirjaan
  kaanna - kysyy sanan ja tulostaa sen käännöksen
  lopeta - poistuu käyttöliittymästä

Komento: Anna sana: Tuntematon sana!

Komento: Anna sana: Tuntematon sana!

Komento: Suomeksi: Käännös:
Komento: Anna sana: Käännös: cheese

Komento: Hei hei!
</pre>

<p>characterStringn antaminen Scanner-luokalle korvaa näppäimistöltä luettavan syötteen characterStringlla. characterStringmuuttujan <code>syote</code> sisältö siis "simuloi" käyttäjän antamaa syötettä. Rivinvaihto syötteeseen merkitään <code>\n</code>:llä. Jokainen yksittäinen rivinvaihtomerkkiin loppuva osa <code>syote</code>-characterStringssa siis vastaa käyttäjän yhteen nextLine()-komentoon antamaa syötettä.</p>

<p>Testityötettä on helppo muuttaa, esim. seuraavassa syötetään lisää uusia sanoja sanakirjaan:</p>

<pre class="sh_java">
    String syote = "lisaa\n"  + "juusto\n" +     "cheese\n" +
                   "lisaa\n"  + "olut\n"   +     "beer\n" +
                   "lisaa\n"  + "kirja\n"  +     "book\n" +
                   "lisaa\n"  + "tietokone\n" +  "computer\n" +
                   "lisaa\n"  + "auto\n"   +     "car\n" +
                   "lopeta\n";
</pre>

<p>Kun haluat testata ohjelmasi toimintaa jälleen käsin, vaihda Scanner-olion konstruktorin parametriksi <code>System.in</code>, eli järjestelmän syötevirta.</p>

<p>Ohjelman toiminnan oikeellisuus pitää edelleen tarkastaa itse ruudulta. Tulostus voi olla aluksi hieman hämmentävää, sillä automatisoitu syöte ei näy ruudulla ollenkaan.</p>

<p>Lopullinen tavoite on automatisoida myös ohjelman tulostuksen oikeellisuden tarkastaminen niin hyvin, että ohjelman testaus ja testituloksen analysointi onnistuu "nappia painamalla". Palaamme aiheeseen myöhemmin kurssin aikana.</p>




<h2>Java API</h2>

        <p>Kurssilla käyttämämme Java-ohjelmointikieli koostuu kolmesta osasta. Ensimmäinen osa on ohjelmointikielen  syntaksi ja semantiikka: muuttujien määrittelytapa, kontrollirakenteiden muoto, ja muuttujien ja luokkien rakenne ja niiden toimintatapa. Toinen osa on JVM, eli <em>Java Virtual Machine</em>, jota käytetään ohjelmien suorittamiseen. Java-ohjelmat käännetään <em>tavukoodiksi</em>, jota voidaan suorittaa missä tahansa koneessa olevan JVM:n avulla. Emme oikeastaan ole törmänneet ohjelmien kääntämiseen, sillä ohjelmointiympäristöt tekevät sen ohjelmoijien puolesta. Silloin tällöin ohjelmointiympäristö ei toimi odotetulla tavalla, ja saatamme joutua valitsemaan <em>clean & build</em>, joka poistaa vanhat lähdekoodit ja kääntää ohjelman uudestaan. Kolmantena osana on API (<em>Application Programming Interface</em>), eli ohjelmointirajapinta tai standardikirjasto.</p>

        <p>API on ohjelmointikielen tarjoama joukko valmiita luokkia, joita ohjelmoija voi käyttää omissa projekteissaan. Esimerkiksi luokat <code>ArrayList</code>, <code>Arrays</code>, <code>Collections</code>, ja <code>String</code> ovat kaikki osa Javan valmista APIa. Javan version 7 API-kuvaus löytyy osoitteesta <a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank">http://docs.oracle.com/javase/7/docs/api/</a>. Osoitteessa olevan sivuston vasemmassa laidassa on Javan valmiille luokille luokkakuvaus. Etsiessäsi sivulta luokkaa <code>ArrayList</code>, löydät sivun <a href="http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html" target="_blank">http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html</a>, joka kuvaa <code>ArrayList</code>-luokan rakenteen, konstruktorit, ja metodit.</p>

        <p>NetBeans osaa näyttää luokkaan liittyvän APIn tarvittaessa. Kun kirjoitat luokan nimen ja lisäät siihen liittyvän import-lauseen, voit klikata luokan nimeä oikealla hiirennapilla ja valita <em>Show Javadoc</em>. Tämä avaa luokkaan liittyvän API-kuvauksen selaimessa.</p>

<div class="tehtavat">
  <h3>Lentokenttä</h3>

  <p>Jokaisella viikolla on yksi laajempi tehtävä, jossa pääset vapaasti suunnittelemaan ohjelman rakenteen, käyttöliittymän ulkomuoto ja vaaditut komennot on määritelty ennalta. Ohjelmoinnin jatkokurssin ensimmäinen vapaasti suunniteltava tehtävä on <em>Lentokenttä</em>.</p>

<p><b>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. Älä myöskään käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</b></p>

  <p>Lentokenttä-tehtävässä toteutetaan lentokentän hallintasovellus. Lentokentän hallintasovelluksessa hallinnoidaan lentokoneita ja lentoja. Lentokoneista tiedetään aina tunnus ja kapasiteetti. Lennoista tiedetään lennon lentokone, lähtöpaikan tunnus (esim. <a href="http://en.wikipedia.org/wiki/Helsinki_Airport" target="_blank">HEL</a>) ja kohdepaikan tunnus (esim. <a href="http://en.wikipedia.org/wiki/Batman_Airport" target="_blank">BAL</a>).</p>

  <p>Sekä lentokoneita että lentoja voi olla useita. Sama lentokone voi myös lentää useaa eri lentoa (useaa eri reittiä). Sovelluksen tulee toimia kahdessa vaiheessa. Ensin lentokentän työntekijä syöttää lentokoneiden ja lentojen tietoja hallintakäyttöliittymässä.</p>

  <p>Kun käyttäjä poistuu hallintakäyttöliittymässä, avautuu käyttäjälle mahdollisuus lentopalvelun käyttöön. Lentopalvelussa on kolme toimintoa; lentokoneiden tulostaminen, lentojen tulostaminen, ja lentokoneen tietojen tulostaminen. Tämän lisäksi käyttäjä voi poistua ohjelmasta valitsemalla vaihtoehdon <code>x</code>. Jos käyttäjä syöttää epäkelvon komennon, kysytään komentoa uudestaan.</p>


<pre>
Lentokentän hallinta
--------------------

Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">1</font>
Anna lentokoneen tunnus: <font color="red">HA-LOL</font>
Anna lentokoneen kapasiteetti: <font color="red">42</font>
Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">1</font>
Anna lentokoneen tunnus: <font color="red">G-OWAC</font>
Anna lentokoneen kapasiteetti: <font color="red">101</font>
Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">2</font>
Anna lentokoneen tunnus: <font color="red">HA-LOL</font>
Anna lähtöpaikan tunnus: <font color="red">HEL</font>
Anna kohdepaikan tunnus: <font color="red">BAL</font>
Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">2</font>
Anna lentokoneen tunnus: <font color="red">G-OWAC</font>
Anna lähtöpaikan tunnus: <font color="red">JFK</font>
Anna kohdepaikan tunnus: <font color="red">BAL</font>
Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">2</font>
Anna lentokoneen tunnus: <font color="red">HA-LOL</font>
Anna lähtöpaikan tunnus: <font color="red">BAL</font>
Anna kohdepaikan tunnus: <font color="red">HEL</font>
Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">x</font>

Lentopalvelu
------------

Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
> <font color="red">1</font>
G-OWAC (101 henkilöä)
HA-LOL (42 henkilöä)
Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
> <font color="red">2</font>
HA-LOL (42 henkilöä) (HEL-BAL)
HA-LOL (42 henkilöä) (BAL-HEL)
G-OWAC (101 henkilöä) (JFK-BAL)

Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
> <font color="red">3</font>
Mikä kone: <font color="red">G-OWAC</font>
G-OWAC (101 henkilöä)

Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
> <font color="red">x</font>
</pre>

<p><strong>Huom1:</strong> Testien kannalta on oleellista että <em>käyttöliittymä</em> toimii <b>täsmälleen</b> kuten yllä kuvattu. Ohjelman tulostamat menut kannattaneekin copypasteta tästä ohjelmakoodiin. Testit eivät oleta, että ohjelmasi on varautunut epäkelpoihin syötteisiin. Tämä tehtävä on kolmen yksittäisen tehtäväpisteen arvoinen.</p>

<p><strong>Huom2:</strong> älä käytä luokkein nimissä skandeja, ne saattavat aiheuttaa ongelmia testeihin!</p>

<p><em><strong>Ohjelman tulee käynnistyä kun tehtäväpohjassa oleva main-metodi suoritetaan.</strong></em></p>

<p><b>Vielä uudelleen varoitus:</b> jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. Älä myöskään käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</p>
</div>



<div class="tyhja"></div>

<div class="viikkoraja">Viikko 2</div>

<h2 id="object">Object</h2>

        <p>Kurssilla on jo useampaan otteeseen käytetty metodia <code>public String toString()</code> olion characterStringesityksen muodostanuseen esim. tulostuskomennon yhteydessä. Emme ole saaneet selvyyttä <em>miksi</em> Java osaa käyttää kyseistä metodia. Olemattoman metodin kutsuminenhan tuottaa normaalisti virheen. Tutkitaan seuraavaa luokkaa <code>Book</code>, jolla ei ole metodia <code>public String toString()</code>, ja ohjelmaa joka yrittää tulostaa <code>Book</code>-luokasta luodun olion <code>System.out.println()</code>-komennolla.</p>

<pre class="sh_java">
public class Book {
    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = nimi;
        this.publishingYear = julkaisuvuosi;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }
}
</pre>

<pre class="sh_java">
Book olioBook = new Book("Oliokirja", 2000);
System.out.println(olioBook);
</pre>

        <p>Ohjelmamme ei tulosta virheilmoitusta tai kaadu kun annamme <code>Book</code>-luokasta tehdyn olion parametrina <code>System.out.println</code>-komennolle. Näemme virheilmoituksen tai kaatumisen sijaan mielenkiintoisen tulosteen. Tuloste sisältää luokan <code>Book</code> nimen ja epämääräisen @-merkkiä seuraavan characterStringn. Huomaa että kutsussa <code>System.out.println(olioBook)</code> Java tekee oikeasti kutsun <code>System.out.println(olioBook.toString())</code>, emme kuitenkaan kohtaa virhettä.</p>

        <p>Selitys liittyy Javan luokkien rakenteeseen. Jokainen Javan luokka <em>perii</em> automaattisesti luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html" target="_blank">Object</a></code>, joka sisältää joukon jokaiselle Javan luokalle hyödyllisiä perusmetodeja. Perintä tarkoittaa että oma luokkamme saa käyttöön perittävän luokan määrittelemiä toiminnallisuuksia ja ominaisuuksia. Luokka <code>Object</code> sisältää muun muassa metodin <code>toString</code>, joka periytyy luomiimme luokiin.</p>

        <p>Object-luokassa määritelty <code>toString</code>-metodin tuottama characterString ei yleensä ole toivomamme. Tämän takia meidän tulee <em>korvata</em>, eli syrjäyttää metodi omalla toteutuksellamme. Lisätään luokkaan <code>Book</code> metodi <code>public String toString()</code>, joka korvaa perityssä <code>Object</code> luokassa olevan metodin <code>toString</code>.</p>

<pre class="sh_java">
public class Book {
    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = nimi;
        this.publishingYear = julkaisuvuosi;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    @Override
    public String toString() {
        return this.name + " (" + this.publishingYear + ")";
    }
}
</pre>

        <p>Nyt kun teemme oliosta ilmentymän ja annamme sen tulostusmetodille, näemme luokassa <code>Book</code> olevan <code>toString</code>-metodin tuottaman characterStringn.</p>

<pre class="sh_java">
Book olioBook = new Book("Oliokirja", 2000);
System.out.println(olioBook);
</pre>

<pre>
Oliokirja (2000)
</pre>

        <p>Luokassa <code>Book</code> olevan metodin <code>toString</code> yläpuolella on <em>annotaatio</em> <code>@Override</code>. Annotaatioilla annetaan vinkkejä sekä kääntäjälle että lukijalle siitä, miten metodeihin tulisi suhtautua. Annotaatio <code>@Override</code> antaa vihjeen että annotaatiota seuraava korvaa perityssä luokassa määritellyn metodin. Jos korvattavaan metodiin ei liitetä annotaatiota, 
antaa kääntäjä tilanteesa <em>varoituksen</em>, overriden kirjottamatta jättäminen ei kuitenkaan ole virhe.</p>

        <p>Luokasta <code>Object</code> peritään muitakin hyödyllisiä metodeja. Tutustutaan seuraavaksi metodeihin <code>equals</code> ja <code>hashCode</code>.</p>

        <h3>Metodi equals</h3>

        <p>Metodia <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#equals(java.lang.Object)" target="_blank">equals</a></code> käytetään kahden olion yhtäsuuruusvertailuun. Metodia on jo käytetty muun muassa <code>String</code>-olioiden yhteydessä.</p>

<pre class="sh_java">
Scanner lukija = new Scanner(System.in);

System.out.print("Kirjoita salasana: ");
String salasana = reader.nextLine();

if(salasana.equals("salasana")) {
    System.out.println("Oikein meni!");
} else {
    System.out.println("Pieleen meni!");
}
</pre>

<pre>
Kirjoita salasana: <font color="red">mahtiporkkana</font>
Pieleen meni!
</pre>

        <p>Luokassa <code>Object</code> määritelty <code>equals</code>-metodi tarkistaa onko parametrina annetulla oliolla sama viite kuin oliolla johon verrataan, eli toisinsanoen oletusarvoisesti vertaillaan onko kyse kahdesta <em>samasta</em> oliosta. Jos viite on sama, palauttaa metodi arvon <code>true</code>, muuten <code>false</code>. Tämä selvenee seuraavalla esimerkillä. Luokassa <code>Book</code> ei ole omaa <code>equals</code>-metodin toteutusta, joten se käyttää <code>Object</code>-luokassa olevaa toteutusta.</p>

<pre class="sh_java">
Book olioBook = new Book("Oliokirja", 2000);
Book toinenOlioBook = olioBook;

if (olioBook.equals(toinenOlioBook)) {
    System.out.println("Bookt olivat samat");
} else {
    System.out.println("Bookt eivät olleet samat");
}

// nyt luodaan saman sisältöinen olio joka kuitenkin on oma erillinen olionsa
toinenOlioBook = new Book("Oliokirja", 2000);

if (olioBook.equals(toinenOlioBook)) {
    System.out.println("Bookt olivat samat");
} else {
    System.out.println("Bookt eivät olleet samat");
}
</pre>

<p>Tulostuu:</p>

<pre>
Bookt olivat samat
Bookt eivät olleet samat
</pre>

        <p>Vaikka <code>Book</code>-olioiden sisäinen rakenne (eli oliomuuttujien arvot) ovat molemmissa tapauksissa täsmälleen samat, vain ensimmäinen vertailu tulostaa characterStringn "<code>Bookt olivat samat</code>". Tämä johtuu siitä että vain ensimmäisessä tapauksessa myös viitteet ovat samat eli vertaillaan olioa itseensä. Toisessa vertailussa kyse on kahdesta eri oliosta, vaikka muuttujilla onkin samat arvot.</p>

<p>characterStringjen eli Stringien yhteydessä <code>equals</code> toimii odotetulla tavalla, eli se ilmoittaa kaksi <em>samansisältöistä</em> characterStringa "equalseiksi" vaikka kyseessä olisikin kaksi erillistä olioa. String-luokassa onkin korvattu oletusarvoinen <code>equals</code> omalla toteutuksella.</p>

        <p>Haluamme että kirjojen vertailu onnistuu myös nimen ja vuoden perusteella. Korvataan <code>Object</code>-luokassa oleva metodi <code>equals</code> määrittelemällä sille toteutus luokkaan <code>Book</code>. Metodin <code>equals</code> tehtävänä on selvittää onko olio sama kuin metodin parametrina saatu olio. Metodi saa parametrina <code>Object</code>-tyyppisen viitteen olion. Määritellään ensin metodi, jonka mielestä kaikki oliot ovat samoja.</p>

<pre class="sh_java">
    public boolean equals(Object olio) {
        return true;
    }
</pre>

        <p>Metodimme on varsin optimistinen, joten muutetaan sen toimintaa hieman. Määritellään että oliot eivät ole samoja jos parametrina saatu olio on <em>null</em> tai jos olioiden tyypit eivät ole samat. Olion tyypin saa (<code>Object</code>-luokassa määritellyllä) metodilla <code>getClass()</code>. Muussa tapauksessa oletetaan että oliot ovat samat.</p>

<pre class="sh_java">
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (this.getClass() != olio.getClass()) {
            return false;
        }

        return true;
    }
</pre>

        <p>Metodi <code>equals</code> huomaa eron erityyppisten olioiden välillä, mutta ei vielä osaa erottaa samanlaisia olioita toisistaan. Jotta voisimme verrata nykyistä oliota ja parametrina saatua <code>Object</code>-tyyppisellä parametrilla viitattua olioa, tulee Object-viitteen tyyppiä muuttaa. Viitteen tyyppiä voidaan muuttaa tyyppimuunnoksella jos ja vain jos olion tyyppi on oikeasti sellainen, mihin sitä yritetään muuttaa. Tyyppimuunnos tapahtuu antamalla asetuslauseen oikealla puolella haluttu luokka suluissa, esimerkiksi:</p>

<pre class="sh_java">
    HaluttuTyyppi muuttuja = (HaluttuTyyppi) vanhaMuuttuja;
</pre>

        <p>Voimme tehdä tyyppimuunnoksen koska tiedämme olioiden olevan samantyyppisiä, jos ne ovat erityyppisiä yllä oleva metodi <code>getClass</code> palauttaa arvon false. Muunnetaan metodissa <code>equals</code> saatu <code>Object</code>-tyyppinen parametri <code>Book</code>-tyyppiseksi, ja todetaan kirjojen olevan eri jos niiden julkaisuvuodet ovat eri. Muuten kirjat ovat vielä samat.</em>

<pre class="sh_java">
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (getClass() != olio.getClass()) {
            return false;
        }

        Book verrattava = (Book) olio;

        if(this.publishingYear != verrattava.getPublishingYear()) {
            return false;
        }

        return true;
    }
</pre>

        <p>Nyt vertailumetodimme osaa erottaa  eri vuosina julkaistut kirjat. Lisätään vielä tarkistus, että kirjojemme nimet ovat samat ja että oman kirjamme nimi ei ole <em>null</em>.</p>

<pre class="sh_java">
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (getClass() != olio.getClass()) {
            return false;
        }

        Book verrattava = (Book) olio;

        if (this.publishingYear != verrattava.getPublishingYear()) {
            return false;
        }

        if (this.name == null || !this.name.equals(verrattava.getName())) {
            return false;
        }

        return true;
    }
</pre>

        <p>Mahtavaa, viimeinkin toimiva vertailumetodi! Alla vielä tämänhetkinen <code>Book</code>-luokkamme.</p>

<pre class="sh_java">
public class Book {
    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = nimi;
        this.publishingYear = julkaisuvuosi;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    @Override
    public String toString() {
        return this.name + " (" + this.publishingYear + ")";
    }

    @Override
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (getClass() != olio.getClass()) {
            return false;
        }

        Book verrattava = (Book) olio;

        if (this.publishingYear != verrattava.getPublishingYear()) {
            return false;
        }

        if (this.name == null || !this.name.equals(verrattava.getName())) {
            return false;
        }

        return true;
    }
}
</pre>

        <p>Nyt kirjojen vertailu palauttaa <code>true</code> jos kirjojen sisällöt ovat samat.</p>

<pre class="sh_java">
Book olioBook = new Book("Oliokirja", 2000);
Book toinenOlioBook = new Book("Oliokirja", 2000);

if (olioBook.equals(toinenOlioBook)) {
    System.out.println("Bookt olivat samat");
} else {
    System.out.println("Bookt eivät olleet samat");
}
</pre>

<pre>
Bookt olivat samat
</pre>

        <h4>Equals ja ArrayList</h4>

        <p>Useat Javan valmiit tietorakenteet käyttävät <code>equals</code>-metodia osana sisäistä hakumekanismiaan. Esimerkiksi luokan <code>ArrayList</code> <code>contains</code>-metodi vertailee olioiden yhtäsuuruutta <code>equals</code>-metodin avulla. Jatketaan aiemmin määrittelemämme <code>Book</code>-luokan käyttöä seuraavassa esimerkissä. Jos emme toteuta omissa olioissamme <code>equals</code>-metodia, emme voi käyttää esimerkiksi <code>contains</code>-metodia. Kokeile alla olevaa koodia kahdella erilaisella <code>Book</code>-luokalla. Toisessa on <code>equals</code>-metodi, ja toisessa sitä ei ole.</p>

<pre class="sh_java">
ArrayList&lt;Book&gt; kirjat = new ArrayList&lt;Book&gt;();
Book olioBook = new Book("Oliokirja", 2000);
kirjat.add(olioBook);

if (kirjat.contains(olioBook)) {
    System.out.println("Oliokirja löytyi.");
}

olioBook = new Book("Oliokirja", 2000);

if (!kirjat.contains(olioBook)) {
    System.out.println("Oliokirjaa ei löytynyt.");
}
</pre>

        <h3>Metodi hashCode</h3>

        <p>Metodi <code>hashCode</code> luo oliosta numeerisen arvon eli hajautusarvon. Numeerista arvoa tarvitaan esimerkiksi 
jos olioa käytetään HashMap:in avaimena. 
Olemme tähän mennessä käyttäneet HashMapin avaimina ainoastaan String- ja Integer-tyyppisiä olioita ja niillä on valmiit sopivasti toteutetut  <code>hashCode</code>-metodit. Luodaan esimerkki jossa näin ei ole: jatketaan kirjojen parissa ja ruvetaan pitämään kirjaa lainassa olevista kirjoista. Päätetään ratkaista kirjanpito HashMapin avulla. Avaimena toimii kirja ja kirjaan liitetty arvo on characterString, joka keroo lainaajan nimen:</p>

<pre class="sh_java">
        HashMap&lt;Book, String&gt; lainaajat = new HashMap&lt;Book, String&gt;();
       
        Book oliokirja = new Book("Oliokirja", 2000);
        lainaajat.put( oliokirja, "Pekka" );
        lainaajat.put( new Book("Test Driven Development",1999), "Arto" );
        
        System.out.println( lainaajat.get( oliokirja ) );
        System.out.println( lainaajat.get( new Book("Oliokirja", 2000) );
        System.out.println( lainaajat.get( new Book("Test Driven Development", 1999) );
</pre>

<p>Tulostuu:</p>

<pre>
Pekka
null
null
</pre>

        <p>Löydämme lainaajan hakiessamme samalla oliolla, joka annettiin hajautustaulun <code>put</code>-metodille avaimeksi. Täsmälleen samanlaisella kirjalla mutta eri oliolla haettaessa lainaajaa ei kuitenkaan löydy ja saamme <em>null</em>-viitteen. Syynä on taas <code>Object</code>-luokassa oleva <code>hashCode</code>-metodin oletustoteutus. Oletustoteutus luo indeksin viitteen perusteella eli samansisältöiset mutta eri oliot saavat eri tuloksen hashCode-metodista ja tämän takia olioa ei osata etsiä oikeasta paikasta HashMapia.</p>

        <p>Jotta HashMap toimisi haluamallamme tavalla, eli palauttaisi lainaajan kun avaimeksi annetaan oikean <em>sisältöinen</em> olio (ei välttämässä siis sama olio kuin alkuperäinen avain), on avaimena toimivan luokan ylikirjoitettava metodin <code>equals</code> lisäksi metodi <code>hashCode</code>. Metodi on ylikirjoitettava siten, että se antaa saman numeerisen tuloksen kaikille samansisältöisille olioille. Myös jotkut erisisältöiset oliot saavat saada saman tuloksen hashCode-metodista, on kuitenkin HashMapin tehokkuuden kannalta oleellista, että erisisältöiset oliot saavat mahdollisimman harvoin saman tuloksen.</p> 

<p> Olemme aiemmin käyttäneet <code>String</code>-olioita menestyksekkäästi HashMapin avaimena, joten voimme päätellä että <code>String</code>-luokassa on oma järkevästi toimiva <code>hashCode</code>-toteutus. <em>Delegoidaan</em>, eli siirretään laskemisvastuu <code>String</code>-oliolle.</p>

<pre class="sh_java">
    public int hashCode() {
        return this.name.hashCode();
    }
</pre>

        <p>Yllä oleva ratkaisu on melko hyvä, mutta jos <code>nimi</code> on <em>null</em>, näemme <code>NullPointerException</code>-virheen. Korjataan tämä vielä määrittelemällä ehto: jos <code>nimi</code>-muuttujan arvo on <em>null</em>, palautetaan arvo 7. Arvo 7 on "satunnaisesti"  valittu alkuluku, yhtä hyvin olisi voitu valita esimerkiksi arvo 13.</p>

<pre class="sh_java">
    public int hashCode() {
        if (this.name == null) {
            return 7;
        }

        return this.name.hashCode();
    }
</pre>

<p>Parantelemme vielä <code>hashCode</code>-metodia siten, että koodin laskennassa huomioidaan myös kirjan julkaisuvuosi:</p>

<pre class="sh_java">
    public int hashCode() {
        if (this.name == null) {
            return 7;
        }

        return this.publishingYear + this.name.hashCode();
    }
</pre>


        <p>Sivuhuomautus: HashMapissa avaimina olevien olioiden hashCode-metodin tulos kertoo hajautusrakenteeseen talletettavien arvon paikan eli indeksin hajautustaulussa. Saatat tässä kohtaa miettiä "eikö tämä johda tilanteeseen jossa useampi olio päätyy samaan indeksiin hajautustaulussa?". Vastaus on kyllä ja ei. Vaikka metodi <code>hashCode</code> antaisi kahdelle eri oliolle saman arvon, on hajautustaulut toteutettu sisäisesti siten että useampi olio voi olla samassa indeksissä. Jotta samassa indeksissä olevat oliot voi erottaa toisistaan, tulee hajautustaulun avaimina toimivina olioilla olla metodi <code>equals</code> toteutettuna. Lisätietoa hajautustaulujen toteuttamisen periaatteista tulee kurssilla <em>tietorakenteet ja algoritmit</em>.</p>

        <p>Luokka <code>Book</code> nyt kokonaisuudessaan.</p>

<pre class="sh_java">
public class Book {

    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = nimi;
        this.publishingYear = julkaisuvuosi;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    @Override
    public String toString() {
        return this.name + " (" + this.publishingYear + ")";
    }

    @Override
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (getClass() != olio.getClass()) {
            return false;
        }

        Book verrattava = (Book) olio;

        if (this.publishingYear != verrattava.getPublishingYear()) {
            return false;
        }

        if (this.name == null || !this.name.equals(verrattava.getName())) {
            return false;
        }

        return true;
    }

    public int hashCode() {
        if (this.name == null) {
            return 7;
        }

        return this.publishingYear + this.name.hashCode();
    }
}
</pre>

<p><b>Kerrataan vielä:</b> jotta luokkaa voidaan käyttää HashMap:in avaimena, tulee sille määritellä</p>
<ul>
<li>metodi <code>equals</code> siten, että kaikki samansisältöisenä ajatellut oliot tuottavat vertailussa tuloksen true ja erisisältöiset false</li>
<li>metodi <code>hashCode</code> siten, että kaikki samansisältöisenä ajatelluille olioille metodin kutsu tuottaa saman arvon</li>
</ul>

<p>Luokalle <code>Book</code> määrittelemämme equals ja hashCode selvästi täyttävät nämä ehdot.
Nyt myös aiemmin kohtaamamme ongelma ratkeaa ja kirjojen lainaajat löytyvät:</p>

<pre class="sh_java">
        HashMap&lt;Book, String&gt; lainaajat = new HashMap&lt;Book, String&gt;();
       
        Book oliokirja = new Book("Oliokirja", 2000);
        lainaajat.put( oliokirja, "Pekka" );
        lainaajat.put( new Book("Test Driven Development",1999), "Arto" );
        
        System.out.println( lainaajat.get( oliokirja ) );
        System.out.println( lainaajat.get( new Book("Oliokirja", 2000) );
        System.out.println( lainaajat.get( new Book("Test Driven Development", 1999) );
</pre>

<p>Tulostuu:</p>

<pre>
Pekka
Pekka
Arto
</pre>

        <p><em>NetBeans tarjoaa metodien <code>equals</code> ja <code>hashCode</code> automaattisen luonnin. Voit valita valikosta Source -> Insert Code, ja valita aukeavasta listasta <em>equals() and hashCode()</em>. Tämän jälkeen NetBeans kysyy oliomuuttujat joita metodeissa käytetään.</em></p>

        <div class="tehtavat" id="viikko8">

<NEXTWEEK></NEXTWEEK>

<h3>Autorekisterikeskus</h3>

<h4>Rekisterinumeron equals ja hashCode</h4>

<p>Eurooppalaiset rekisteritunnukset koostuvat kahdesta osasta: yksi tai kaksikirjaimisesta maatunnuksesta ja maakohtaisesti määrittyvästä rekisterinumerosta, joka taas koostuu numeroista ja merkeistä. Rekisterinumeroita esitetään seuraavanlaisen luokan avulla:</p>

<pre class="sh_java">
public class Rekisterinumero {
    // HUOM: oliomuuttujissa on määre final eli niiden arvoa ei voi muuttaa!
    private final String rekNro;
    private final String maa;

    public Rekisterinumero(String rekNro, String maa) {
       this.rekNro = rekNro;
       this.maa = maa;
    }

    public String toString(){
        return maa+ " "+rekNro;
    }
}
</pre>

<p>Rekisterinumeroja halutaan tallettaa esim. ArrayList:eille ja käyttää HashMap:in avaimina, eli kuten yllä mainittu, tulee niille toteuttaa 
metodit <code>equals</code> ja <code>hashCode</code>, muuten ne eivät toimi halutulla tavalla. </p>

<p><strong>Vihje:</strong> ota equals- ja hashCode-metodeihin mallia yllä olevasta Book-esimerkistä. Rekisterinumeron hashCode voidaan muodostaa esim. maatunnuksen ja rekNro:n hashCodejen summana.</p>

<p>Esimerkkiohjelma:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Rekisterinumero rek1 = new Rekisterinumero("FI", "ABC-123");
        Rekisterinumero rek2 = new Rekisterinumero("FI", "UXE-465");
        Rekisterinumero rek3 = new Rekisterinumero("D", "B WQ-431");

        ArrayList&lt;Rekisterinumero&gt; suomalaiset = new ArrayList&lt;Rekisterinumero&gt;();
        suomalaiset.add(rek1);
        suomalaiset.add(rek2);

        Rekisterinumero uusi = new Rekisterinumero("FI", "ABC-123");
        if (!suomalaiset.contains(uusi)) {
            suomalaiset.add(uusi);
        }
        System.out.println("suomalaiset: " + suomalaiset);
        // jos equals-metodia ei ole ylikirjoitettu, menee sama rekisterinumero toistamiseen listalle

        HashMap&lt;Rekisterinumero, String&gt; omistajat = new HashMap&lt;Rekisterinumero, String&gt;();
        omistajat.put(rek1, "Arto");
        omistajat.put(rek3, "Jürgen");

        System.out.println("omistajat:");
        System.out.println(omistajat.get(new Rekisterinumero("FI", "ABC-123")));
        System.out.println(omistajat.get(new Rekisterinumero("D", "B WQ-431")));
        // jos hashCode ei ole ylikirjoitettu, eivät omistajat löydy
    }
</pre>

<p>Jos equals ja hashCode on toteutettu oikein, tulostus on seuraavanlainen</p>

<pre>
suomalaiset: [FI ABC-123, FI UXE-465]   
omistajat:
Arto
Jürgen

</pre>

<h4>Omistaja rekisterinumeron perusteella</h4>

<p>Toteuta luokka <code>Ajoneuvorekisteri</code> jolla on seuraavat metodit:</p>

<ul>
<li><code>public boolean lisaa(Rekisterinumero rekkari, String omistaja)</code> lisää parametrina olevaa rekisterinumeroa vastaavalle autolle parametrina olevan omistajan, metodi palauttaa true jos omistajaa ei ollut ennestään, jos rekisterinumeroa vastaavalla autolla oli jo omistaja, metodi palauttaa false ja ei tee mitään</li>
<li><code>public String hae(Rekisterinumero rekkari)</code> palauttaa parametrina olevaa rekisterinumeroa vastaavan auton omistajan. Jos auto ei ole rekisterissä, palautetaan <code>null</code></li>
<li><code>public boolean poista(Rekisterinumero rekkari)</code> poistaa parametrina olevaa rekisterinumeroa vastaavat tiedot, metodi palauttaa true jos tiedot poistetiin, ja false jos parametria vastaavia tietoja ei ollut rekisterissä</li>
</ul>

<p><strong>Huom:</strong> Ajoneuvorekisterin täytyy tallettaa omistajatiedot <code>HashMap&lt;Rekisterinumero, String&gt; omistajat</code> -tyyppiseen oliomuuttujaan!</p>

<h4>Ajoneuvorekisteri laajenee</h4>

<p>Lisää Ajoneuvorekisteriin vielä seuraavat metodit:</p>

<ul>
<li><code>public void tulostaRekisterinumerot()</code> tulostaa rekisterissä olevat rekisterinumerot</li>
<li><code>public void tulostaOmistajat()</code> tulostaa rekisterissä olevien autojen omistajat, yhden omistajan nimeä ei saa tulostaa kuin kertaalleen vaikka omistajalla olisikin useampi auto</li>
</ul>

</div>

        <h2 id="rajapinta">Rajapinta</h2>

        <p>Rajapinta (engl. <em>interface</em>) on väline luokilta vaaditun käyttäytymisen määrittelyyn. Rajapinnat määritellään kuten normaalit Javan olevat luokat, mutta luokan alussa olevan määrittelyn "<code>public class ...</code>" sijaan käytetään määrittelyä "<code>public interface ...</code>". Rajapintat määrittelevät käyttäytymisen metodien niminä ja palautusarvoina, mutta ne <em>eivät sisällä metodien toteutusta</em>. Näkyvyysmäärettä ei merkitä erikseen, sillä se on aina <code>public</code>. Tutkitaan luettavuutta kuvaavaa rajapintaa <em>Luettava</em>.</p>

<pre class="sh_java">
public interface Luettava {
    String lue();
}
</pre>

        <p>Rajapinta <code>Luettava</code> määrittelee metodin <code>lue()</code>, joka palauttaa String-tyyppisen olion. Rajapinnan toteuttavat luokat päättävät <em>miten</em> rajapinnassa määritellyt metodit lopulta toteutetaan. Luokka toteuttaa rajapinnan lisäämällä luokan nimen jälkeen avainsanalla <em>implements</em>, jota seuraa rajapinnan nimi. Luodaan luokka <code>Tekstiviesti</code>, joka toteuttaa rajapinnan <code>Luettava</code>.</p>

<pre class="sh_java">
public class Tekstiviesti implements Luettava {
    private String lahettaja;
    private String sisalto;

    public Tekstiviesti(String lahettaja, String sisalto) {
        this.lahettaja = lahettaja;
        this.sisalto = sisalto;
    }

    public String getLahettaja() {
        return this.lahettaja;
    }

    public String lue() {
        return this.sisalto;
    }
}
</pre>

        <p>Koska luokka <code>Tekstiviesti</code> toteuttaa rajapinnan <code>Luettava</code> (<code>public class Tekstiviesti implements Luettava</code>),  on luokassa <code>Tekstiviesti</code> <em>pakko</em> olla metodin <code>public String lue()</code> toteutus. Rajapinnassa määriteltyjen metodien toteutuksilla tulee aina olla näkyvyysmääre public.</p>

        <p><em>Rajapinta on sopimus käyttäytymisestä. Jotta käyttäytyminen toteutuu, tulee luokan toteuttaa rajapinnan määrittelemät metodit. Rajapinnan toteuttavan luokan ohjelmoijan vastuulla on määritellä millaista käyttäytyminen on. Rajapinnan toteuttaminen tarkoittaa sopimuksen tekemistä siitä, että luokka tarjoaa kaikki rajapinnan määrittelemät toiminnot eli rajapinnan määrittelemän käyttäytymisen. Luokkaa, joka toteuttaa rajapinnan, mutta ei toteuta rajapinnan metodeja, ei voi olla olemassa.</em></p>

        <p>Toteutetaan luokan <code>Tekstiviesti</code> lisäksi toinen <code>Luettava</code> rajapinnan toteuttava luokka. Luokka <code>Sahkokirja</code> on sähköinen toteutus kirjasta, joka sisältää kirjan nimen ja sivut. Sähkökirjaa luetaan sivu kerrallaan, metodin <code>public String lue()</code> kutsuminen palauttaa aina seuraavan sivun characterStringna.</p>

<pre class="sh_java">
public class Sahkokirja implements Luettava {
    private String name;
    private ArrayList&lt;String&gt; sivut;
    private int sivunumero;

    public Sahkokirja(String name, ArrayList&lt;String&gt; sivut) {
        this.name = nimi;
        this.sivut = sivut;
        this.sivunumero = 0;
    }

    public String getName() {
        return this.name;
    }

    public int sivuja() {
        return this.sivut.size();
    }

    public String lue() {
        String sivu = this.sivut.get(this.sivunumero);
        seuraavaSivu();
        return sivu;
    }

    private void seuraavaSivu() {
        this.sivunumero = this.sivunumero + 1;
        if(this.sivunumero % this.sivut.size() == 0) {
            this.sivunumero = 0;
        }
    }
}
</pre>

        <p>Rajapinnan toteuttavasta luokasta voi tehdä olioita aivan kuten normaaleistakin luokista, ja niitä voidaan käyttää myös esimerkiksi ArrayList-listojen tyyppinä.</p>

<pre class="sh_java">
    Tekstiviesti viesti = new Tekstiviesti("ope", "Huikeaa menoa!");
    System.out.println(viesti.lue());

    ArrayList&lt;Tekstiviesti&gt; tekstiviestit = new ArrayList&lt;Tekstiviesti&gt;();
    tekstiviestit.add(new Tekstiviesti("tuntematon numero", "I hid the body.");
</pre>

<pre>Huikeaa menoa!</pre>

<pre class="sh_java">
    ArrayList&lt;String&gt; sivut = new ArrayList&lt;String&gt;();
    sivut.add("Pilko metodisi lyhyiksi luettaviksi kokonaisuuksiksi.");
    sivut.add("Erota käyttöliittymälogiikka sovelluksen logiikasta.");
    sivut.add("Ohjelmoi aina ensin pieni ohjelma joka ratkaisee vain osan ongelmasta.");
    sivut.add("Harjoittelu tekee mestarin. Keksi joku hauska oma projekti.");

    Sahkokirja kirja = new Sahkokirja("Vinkkejä ohjelmointiin.", sivut);
    for(int sivu = 0; sivu < kirja.sivuja(); sivu++) {
        System.out.println(kirja.lue());
    }
</pre>

<pre>
Pilko metodisi lyhyiksi luettaviksi kokonaisuuksiksi.
Erota käyttöliittymälogiikka sovelluksen logiikasta.
Ohjelmoi aina ensin pieni ohjelma joka ratkaisee vain osan ongelmasta.
Harjoittelu tekee mestarin. Keksi joku hauska oma projekti.
</pre>

<div class="tehtavat">

<h3>Palvelusvelvollinen</h3>

<p>Tehtäväpohjassa on valmiina rajapinta <code>Palvelusvelvollinen</code>, jossa on seuraavat toiminnot:</p>

  <ul>
    <li> metodi <code>int getTJ()</code> palauttaa jäljellä olevien palveluspäivien määrän</li>
    <li> metodi <code>void palvele()</code> vähentää yhden palveluspäivän. Palveluspäivien määrä ei saa mennä negatiiviseksi.</li>
  </ul>

<pre class="sh_java">
public interface Palvelusvelvollinen {
    int getTJ();
    void palvele();
}
</pre>

<h4>Sivari</h4>

<p>Tee <code>Palvelusvelvollinen</code>-rajapinnan toteuttava luokka <code>Sivari</code>, jolla parametriton konstruktori. Luokalla on oliomuuttuja TJ, joka alustetaan konstruktorikutsun yhteydessä arvoon 362.</p>

<h4>Asevelvollinen</h4>

<p>Tee <code>Palvelusvelvollinen</code>-rajapinnan toteuttava luokka <code>Asevelvollinen</code>, jolla on parametrillinen konstruktori, jolla määritellään palvelusaika (<code>int tj</code>).</p>
</div>


<h3>Rajapinta muuttujan tyyppinä</h3>

        <p>Uutta muuttujaa esitellessä esitellään aina muuttujan tyyppi. Muuttujatyyppejä on kahdenlaisia, alkeistyyppiset muuttujat (int, double, ...) ja viitetyyppiset muuttujat (kaikki oliot). Olemme tähän mennessä käyttäneet viitetyyppisten muuttujien tyyppinä olion luokkaa.</p>

<pre class="sh_java">
    String characterString = "characterString-olio";
    Tekstiviesti viesti = new Tekstiviesti("ope", "Kohta tapahtuu huikeita");
</pre>

        <p>Olion tyyppi voi olla muutakin kuin sen luokka. Esimerkiksi rajapinnan <code>Luettava</code> toteuttavan luokan tyyppi on lisäksi <code>Luettava</code>. Esimerkiksi koska luokka <code>Tekstiviesti</code> toteuttaa rajapinnan <code>Luettava</code>, on sillä tyypin <code>Tekstiviesti</code> lisäksi myös tyyppi <code>Luettava</code>.</p>

<pre class="sh_java">
    Tekstiviesti viesti = new Tekstiviesti("ope", "Kohta tapahtuu huikeita");
    Luettava luettava = new Tekstiviesti("ope", "Tekstiviesti on Luettava!");
</pre>

<pre class="sh_java">
    ArrayList&lt;String&gt; sivut = new ArrayList&lt;String&gt;();
    sivut.add("Metodi voi kutsua itse itseään.");

    Luettava kirja = new Sahkokirja("Rekursion alkeet.", sivut);
    for(int sivu = 0; sivu < kirja.sivuja(); sivu++) {
        System.out.println(kirja.lue());
    }
</pre>

        <p>Koska rajapintaa voidaan käyttää tyyppinä, on mahdollista luoda rajapintaluokan tyyppisiä olioita sisältävä lista.</p>

<pre class="sh_java">
    ArrayList&lt;Luettava&gt; lukulista = new ArrayList&lt;Luettava&gt;();

    lukulista.add(new Tekstiviesti("ope", "never been programming before..."));
    lukulista.add(new Tekstiviesti("ope", "gonna love it i think!"));
    lukulista.add(new Tekstiviesti("ope", "give me something more challenging! :)"));
    lukulista.add(new Tekstiviesti("ope", "you think i can do it?"));
    lukulista.add(new Tekstiviesti("ope", "up here we send several messages each day"));

    for (Luettava luettava: lukulista) {
        System.out.println(luettava.lue());
    }
</pre>

        <p>Huomaa että vaikka rajapinnan <code>Luettava</code> toteuttava luokka <code>Sahkokirja</code> on aina rajapinnan tyyppinen, eivät kaikki <code>Luettava</code>-rajapinnan toteuttavat luokat ole tyyppiä <code>Sahkokirja</code>. Luokasta <code>Sahkokirja</code> tehdyn olion asettaminen <code>Luettava</code>-tyyppiseen muuttujaan onnistuu, mutta toiseen suuntaan asetus ei ole sallittua ilman erillistä tyyppimuunnosta.</p>

<pre class="sh_java">
    Luettava luettava = new Tekstiviesti("ope", "Tekstiviesti on Luettava!"); // toimii
    Tekstiviesti viesti = luettava; // ei toimi

    Tekstiviesti muunnettuViesti = (Tekstiviesti) luettava; // toimii
</pre>

        <p>Tyyppimuunnos onnistuu jos ja vain jos muuttuja on oikeastikin sitä tyyppiä johon sitä yritetään muuntaa. Tyyppimuunnoksen käyttöä ei yleisesti suositella, ja lähes ainut sallittu paikka sen käyttöön on <code>equals</code>-metodin toteutuksessa.</p>

        <h3>Rajapinta metodin parametrina</h3>

        <p>Rajapintojen todelliset hyödyt tulevat esille kun niitä käytetään metodille annettavan parametrin tyyppinä. Koska rajapintaa voidaan käyttää muuttujan tyyppinä, voidaan sitä käyttää metodikutsuissa parametrin tyyppinä. Esimerkiksi seuraavan luokan <code>Tulostin</code> metodi <code>tulosta</code> saa parametrina <code>Luettava</code>-tyyppisen muuttujan.</p>

<pre class="sh_java">
public class Tulostin {
    public void tulosta(Luettava luettava) {
        System.out.println(luettava.lue());
    }
}
</pre>

        <p>Luokan <code>Tulostin</code> tarjoaman metodin <code>tulosta</code> huikeus piilee siinä, että sille voi antaa parametrina <em>minkä tahansa</em> <code>Luettava</code>-rajapinnan toteuttavan luokan ilmentymän. Kutsummepa metodia millä tahansa Luettava-luokan toteuttaneen luokan oliolla, metodi osaa toimia oikein.</p>

<pre class="sh_java">
    Tekstiviesti viesti = new Tekstiviesti("ope", "Huhhuh, tää tulostinkin osaa tulostaa näitä!");
    ArrayList&lt;String&gt; sivut = new ArrayList&lt;String&gt;();
    sivut.add("Lukujen {1, 3, 5} ja {2, 3, 4, 5} yhteisiä lukuja ovat {3, 5}.");

    Sahkokirja kirja = new Sahkokirja("Yliopistomatematiikan perusteet.", sivut);

    Tulostin tulostin = new Tulostin();
    tulostin.tulosta(viesti);
    tulostin.tulosta(kirja);
</pre>

<pre>
Huhhuh, tää tulostinkin osaa tulostaa näitä!
Lukujen {1, 3, 5} ja {2, 3, 4, 5} yhteisiä lukuja ovat {3, 5}.
</pre>

        <p>Toteutetaan toinen luokka <code>Lukulista</code>, johon voidaan lisätä mielenkiintoisia luettavia asioita. Luokalla on oliomuuttujana <code>ArrayList</code>-luokan ilmentymä, johon luettavia asioita tallennetaan. Lukulistaan lisääminen tapahtuu <code>lisaa</code>-metodilla, joka saa parametrikseen <code>Luettava</code>-tyyppisen olion.</p>

<pre class="sh_java">
public class Lukulista {
    private ArrayList&lt;Luettava&gt; luettavat;

    public Lukulista() {
        this.luettavat = new ArrayList&lt;Luettava&gt;();
    }

    public void lisaa(Luettava luettava) {
        this.luettavat.add(luettava);
    }

    public int luettavia() {
        return this.luettavat.size();
    }
}
</pre>

        <p>Lukulistat ovat yleensä luettavia, joten toteutetaan luokalle <code>Lukulista</code> rajapinta <code>Luettava</code>. Lukulistan <code>lue</code>-metodi lukee kaikki <code>luettavat</code>-listalla olevat oliot läpi, ja lisää yksitellen niiden <code>lue()</code>-metodin palauttaman characterStringon.</p>

<pre class="sh_java">
public class Lukulista implements Luettava {
    private ArrayList&lt;Luettava&gt; luettavat;

    public Lukulista() {
        this.luettavat = new ArrayList&lt;Luettava&gt;();
    }

    public void lisaa(Luettava luettava) {
        this.luettavat.add(luettava);
    }

    public int luettavia() {
        return this.luettavat.size();
    }

    public String lue() {
        String luettu = "";
        for(Luettava luettava: this.luettavat) {
            luettu += luettava.lue() + "\n";
        }

        this.luettavat.clear();
        return luettu;
    }
}
</pre>

<pre class="sh_java">
    Lukulista joelinLista = new Lukulista();
    joelinLista.lisaa(new Tekstiviesti("matti", "teitkö jo testit?"));
    joelinLista.lisaa(new Tekstiviesti("matti", "katsoitko jo palautukset?"));

    System.out.println("Joelilla luettavia: " + joelinLista.luettavia());
</pre>

<pre>
Joelilla luettavia: 2
</pre>

        <p>Koska <code>Lukulista</code> on tyyppiä <code>Luettava</code>, voi lukulistalle lisätä <code>Lukulista</code>-olioita. Alla olevassa esimerkissä Joelilla on paljon luettavaa. Onneksi Mikael tulee hätiin ja lukee viestit Joelin puolesta.</p>

<pre class="sh_java">
    Lukulista joelinLista = new Lukulista();
    for (int i = 0; i < 1000; i++) {
        joelinLista.lisaa(new Tekstiviesti("matti", "teitkö jo testit?"));
    }

    System.out.println("Joelilla luettavia: " + joelinLista.luettavia());
    System.out.println("Delegoidaan lukeminen Mikaelille");

    Lukulista mikaelinLista = new Lukulista();
    mikaelinLista.lisaa(joelinLista);
    mikaelinLista.lue();

    System.out.println();
    System.out.println("Joelilla luettavia: " + joelinLista.luettavia());
</pre>

<pre>
Joelilla luettavia: 1000
Delegoidaan lukeminen Mikaelille

Joelilla luettavia: 0
</pre>

        <p>Ohjelmassa Mikaelin listalle kutsuttu <code>lue</code>-metodi käy kaikki sen sisältämät <code>Luettava</code>-oliot läpi, ja kutsuu niiden <code>lue</code>-metodia. Kutsuttaessa <code>lue</code>-metodia Mikaelin listalle käydään myös Mikaelin lukulistalla oleva Joelin lukulista läpi. Joelin lukulista käydään läpi kutsumalla sen <code>lue</code>-metodia. Jokaisen <code>lue</code>-metodin kutsun lopussa tyhjennetään juuri luettu lista. Eli Joelin lukulista tyhjenee kun Mikael lukee sen.</p>

        <p><em>Tässä on jo hyvin paljon viitteitä, kannattaa piirtää oliot paperille ja hahmotella miten <code>mikaelinLista</code>-oliolle tapahtuva metodikutsu <code>lue</code> etenee!</em></p>

<div class="tehtavat">

  <h3>Tavaroita ja laatikoita</h3>

  <h4 class="req">Talletettavia</h4>

  <p>Muuton yhteydessa tarvitaan muuttolaatikoita. Laatikoihin talletetaan erilaisia esineitä. Kaikkien laatikoihin talletettavien esineiden on toteutettava seuraava rajapinta:</p>

<pre class="sh_java">
public interface Talletettava {
    double paino();
}
</pre>

  <p>Lisää rajapinta ohjelmaasi. Rajapinta lisätään melkein samalla tavalla kuin luokka, <i>new Java class</i> sijaan valitaan <i>new Java interface</i>.</p>

  <p>Tee rajapinnan toteuttavat luokat <code>Book</code> ja <code>CDLevy</code>. Book saa konstruktorin parametreina kirjan kirjoittajan (String), kirjan nimen (String), ja kirjan painon (double). CD-Levyn konstruktorin parametreina annetaan artisti (String), levyn nimi (String), ja julkaisuvuosi (int). Kaikkien CD-levyjen paino on 0.1 kg.</p>

  <p>Muista toteuttaa luokilla myös rajapinta <code>Talletettava</code>. Luokkien tulee toimia seuraavasti:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Book kirja1 = new Book("Fedor Dostojevski", "Rikos ja Rangaistus", 2);
        Book kirja2 = new Book("Robert Martin", "Clean Code", 1);
        Book kirja3 = new Book("Kent Beck", "Test Driven Development", 0.5);

        CDLevy cd1 = new CDLevy("Pink Floyd", "Dark Side of the Moon", 1973);
        CDLevy cd2 = new CDLevy("Wigwam", "Nuclear Nightclub", 1975);
        CDLevy cd3 = new CDLevy("Rendezvous Park", "Closer to Being Here", 2012);

        System.out.println(kirja1);
        System.out.println(kirja2);
        System.out.println(kirja3);
        System.out.println(cd1);
        System.out.println(cd2);
        System.out.println(cd3);
    }
</pre>

  <p>Tulostus:</p>

<pre>
Fedor Dostojevski: Rikos ja Rangaistus
Robert Martin: Clean Code
Kent Beck: Test Driven Development
Pink Floyd: Dark Side of the Moon (1973)
Wigwam: Nuclear Nightclub (1975)
Rendezvous Park: Closer to Being Here (2012)
</pre>

  <p>Huom! Painoa ei ilmoiteta tulostuksessa.</p>

<h4 class="req">Laatikko</h4>

  <p>Tee luokka laatikko, jonka sisälle voidaan tallettaa <code>Talletettava</code>-rajapinnan toteuttavia tavaroita. Laatikko saa konstruktorissaan parametrina laatikon maksimikapasiteetin kiloina. Laatikkoon ei saa lisätä enempää tavaraa kuin sen maksimikapasiteetti määrää. Laatikon sisältämien tavaroiden paino ei siis koskaan saa olla yli laatikon maksimikapasiteetin.</p>

  <p>Seuraavassa esimerkki laatikon käytöstä:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Laatikko laatikko = new Laatikko(10);

        laatikko.lisaa( new Book("Fedor Dostojevski", "Rikos ja Rangaistus", 2) ) ;
        laatikko.lisaa( new Book("Robert Martin", "Clean Code", 1) );
        laatikko.lisaa( new Book("Kent Beck", "Test Driven Development", 0.7) );

        laatikko.lisaa( new CDLevy("Pink Floyd", "Dark Side of the Moon", 1973) );
        laatikko.lisaa( new CDLevy("Wigwam", "Nuclear Nightclub", 1975) );
        laatikko.lisaa( new CDLevy("Rendezvous Park", "Closer to Being Here", 2012) );

        System.out.println( laatikko );
    }
</pre>

  <p>Tulostuu</p>

<pre>
Laatikko: 6 esinettä, paino yhteensä 4.0 kiloa
</pre>

<p>Huom: koska painot esitetään doubleina, saattaa laskutoimituksissa tulla pieniä pyöristysvirheitä. Tehtävässä ei tarvitse välittää niistä.</p>

<h4 class="req">Laatikon paino</h4>

  <p>Jos teit laatikon sisälle oliomuuttujan <code>double paino</code>, joka muistaa laatikossa olevien esineiden painon, korvaa se metodilla, joka laskee painon:</p>

<pre class="sh_java">
public class Laatikko {
    //...

    public double paino() {
        double paino = 0;
        // laske laatikkoon talletettujen tavaroiden yhteispaino
        return paino;
    }
}
</pre>

  <p>Kun tarvitset laatikon sisällä painoa esim. uuden tavaran lisäyksen yhteydessä, riittää siis kutsua laatikon painon laskevaa metodia.</p>

  <p>Metodi toki voisi palauttaa myös oliomuuttujan arvon. Harjoittelemme tässä kuitenkin tilannetta, jossa oliomuuttujaa ei tarvitse eksplisiittisesti ylläpitää vaan se voidaan tarpeentullen laskea. Seuraavan tehtävän jälkeen laatikossa olevaan oliomuuttujaan talletettu painotieto ei kuitenkaan välttämättä enää toimisi. Miksi? </p>

  <h4 class="req">Laatikkokin on talletettava!</h4>

  <p>Rajapinnan <code>Talletettava</code> toteuttaminen siis edellyttää että luokalla on metodi <code>double paino()</code>. Laatikollehan lisättiin juuri tämä metodi. Laatikosta voidaan siis tehdä talletettava!</p>

  <p>Laatikot ovat oliota joihin voidaan laittaa <code>Talletettava</code>-rajapinnan toteuttavia olioita. Laatikot toteuttavat itsekin rajapinnan. Eli <b>laatikon sisällä voi olla myös laatikoita!</b></p>

  <p>Kokeile että näin varmasti on, eli tee ohjelmassasi muutama laatikko, laita laatikoihin tavaroita ja laita pienempiä laatikoita isompien laatikoiden sisään. Kokeile myös mitä tapahtuu kun laitat laatikon itsensä sisälle. Miksi näin käy?</p>
</div>

<h3>Rajapinta metodin paluuarvona</h3>

        <p>Kuten mitä tahansa muuttujan tyyppiä, myös rajapintaa voi käyttää metodin paluuarvona. Seuraavassa <code>Tehdas</code>, jota voi pyytää valmistamaan erilaisia <code>Talletettava</code>-rajapinnan toteuttavia oliota. Tehdas valmistaa aluksi satunnaisesti kirjoja ja levyjä.</p>

<pre class="sh_java">
   public class Tehdas {
      public Tehdas(){
          // HUOM: parametritonta tyhjää konstruktoria ei ole pakko kirjoittaa, jos luokalla ei ole muita konstruktoreja
          //       Java tekee automaattisesti tälläisissä tilanteissa luokalle oletuskonstruktorin eli parametrittoman tyhjän konstruktorin   
      }

       public Talletettava valmistaUusi(){
           Random arpa = new Random();
           int luku = arpa.nextInt(4);
           if ( luku==0 ) {
               return new CDLevy("Pink Floyd", "Dark Side of the Moon", 1973);
           } else if ( luku==1 ) {
               return new CDLevy("Wigwam", "Nuclear Nightclub", 1975);
           } else if ( luku==2 ) {
               return new Book("Robert Martin", "Clean Code", 1 );
           } else {
               return new Book("Kent Beck", "Test Driven Development", 0.7);
           }      
       }
   }
</pre>

<p>Tehdasta on mahdollista käyttää tuntematta tarkalleen mitä erityyppisiä Talletettava-rajapinnan luokkia on olemassa. Seuraavassa luokka Pakkaaja, jolta voi pyytää laatikollisen esineitä. Pakkaaja tuntee tehtaan, jota se pyytää luomaan esineet:</p>

<pre class="sh_java">
   public class Pakkaaja {
       private Tehdas tehdas; 

       public Pakkaaja(){
            tehdas = new Tehdas();
       }

       public Laatikko annaLaatikollinen() {
            Laatikko laatikko = new Laatikko(100);
             
            for ( int i=0; i &lt; 10; i++ ) {
                Talletettava uusiTavara = tehdas.valmistaUusi();
                laatikko.lisaa(uusiTavara);
            }
  
            return laatikko;
       }
   }
</pre>

<p>Koska pakkaaja ei tunne rajapinnan Talletettava toteuttavia luokkia, on ohjelmaan mahdollisuus lisätä uusia luokkia jotka toteuttavat rajapinnan ilman tarvetta muuttaa pakkaajaa. Seuraavassa on luotu uusi Talletettava-rajapinnan toteuttava luokka, <code>Suklaalevy</code>. Tehdasta on muutettu siten, että se luo kirjojen ja cd-levyjen lisäksi suklaalevyjä. Luokka <code>Pakkaaja</code> toimii muuttamatta tehtaan laajennetun version kanssa.</p>

<pre class="sh_java">
   public class Suklaalevy implements Talletettava {
      // koska Javan generoima oletuskonstruktori riittää, emme tarvitse konstruktoria! 

      public double paino(){
         return 0.2;
      }
   }

   public class Tehdas {
       // koska Javan generoima oletuskonstruktori riittää, emme tarvitse konstruktoria!

       public Talletettava valmistaUusi(){
           Random arpa = new Random();
           int luku = arpa.nextInt(5);
           if ( luku==0 ) {
               return new CDLevy("Pink Floyd", "Dark Side of the Moon", 1973);
           } else if ( luku==1 ) {
               return new CDLevy("Wigwam", "Nuclear Nightclub", 1975);
           } else if ( luku==2 ) {
               return new Book("Robert Martin", "Clean Code", 1 );
           } else if ( luku==3 ) {
               return new Book("Kent Beck", "Test Driven Development", 0.7);
           } else {
               return new Suklaalevy();
           }     
       }
   }
</pre>


  <p><em>Rajapintojen käyttö ohjelmoinnissa mahdollistaa luokkien välisten riippuvaisuuksien vähentämisen. Esimerkissämme Pakkaaja ei ole riippuvainen rajapinnan Talletettava-toteuttavista luokista vaan ainoastaan rajapinnasta. Tämä mahdollistaa rajapinnan toteuttavien luokkien lisäämisen ohjelmaan ilman tarvetta muuttaa luokkaa Pakkaaja. Myöskään pakkaajan käyttäjiin rajapinnan toteuttavien luokkien lisääminen ei vaikuta. Vähäisemmät riippuvuudet siis helpottavat ohjelman laajennettavuutta. 
</em></p>

<!--

<p> Toteutetaan luokat <code>Uutinen</code>, joka kuvaa yksittäistä luettavaa uutista, ja <code>Uutispalvelu</code>, jonka tehtävänä on luoda luettavia uutisia. Uutispalvelua käyttäville sovelluksille ei ole tärkeää tai edes mielekästä tietää uutisten todellisesta toteutuksesta, oleellista on vain niiden lukeminen. Uutispalvelu voi siis hyvin tarjota uutisensa <code>Luettava</code>-rajapinnan kautta.</p>

<pre class="sh_java">
public class Uutinen implements Luettava {
    private String teksti;

    public Uutinen(String teksti) {
        this.teksti = teksti;
    }

    public String lue() {
        return this.teksti;
    }
}
</pre>

<pre class="sh_java">
public class Uutispalvelu {

    public Luettava haeViimeisinUutinen() {
        return new Uutinen("uusinta hottia!");
    }
}
</pre>

        <p>Uutispalvelu tuottaa uutisensa aina <code>Luettava</code>-rajapinnan tyyppisenä. Tässä kohtaa nousee usein esille erinomainen kysymys "<code>Miksi emme käyttäisi vain luokkaa Uutinen?</code>". Vastaus on pitkähkö, mutta toivottavasti selvittää taustaidean.</p>

        <p>Pohditaan tilannetta, jossa meillä on uutisia julkaiseva <code>Julkaisupalvelu</code>. Julkaisupalvelun tehtävänä on lukea uutisia tasaisin väliajoin uutispalvelulta ja tulostaa viestit näkyville (julkaisupalvelu voisi lähettää hyvin viestin esimerkiksi eri medioille, mutta pidättäydytään pienemmässä esimerkissä). Oletetaan että Uutispalvelu palauttaa Uutinen-olioita.</p>

<pre class="sh_java">
public class Uutispalvelu {

    public Uutinen haeViimeisinUutinen() {
        return new Uutinen("uusinta hottia!");
    }
}
</pre>

        <p>Julkaisupalvelun oleellinen toiminnallisuus on toistolauseke, joka kutsuu tasaisin väliajoin uutispalvelun <code>haeViimeisinUutinen-metodia</code>.</p>

<pre class="sh_java">
public class Julkaisupalvelu {
    private Uutispalvelu uutispalvelu;

    public Julkaisupalvelu() {
        this.uutispalvelu = new Uutispalvelu();
    }

    public void kaynnista() {
        while (true) {
            Uutinen uutinen = uutispalvelu.haeViimeisinUutinen();
            System.out.println(uutinen.lue());

            try {
                Thread.sleep(10000);
            } catch (Exception e) {
            }
        }
    }
}
</pre>

        <p>Tässä vaiheessa kaikki toimii hyvin. Oletetaan että Uutispalvelun toimitusjohtaja huomaa, että he tarvitsevat uuden formaatin kuvallisille uutisille. Kuvallisia uutisia varten toteutetaan erillinen luokka <code>KuvaUutinen</code>. KuvaUutinen on luettava, joten Uutispalvelun ohjelmoijat toteuttavat myös sille rajapinnan Luettava-rajapinta.</p>

<pre class="sh_java">
public class KuvaUutinen implements Luettava {
    private String kuvaOsoite;
    private String teksti;

    public KuvaUutinen(String teksti, String kuvaOsoite) {
        this.teksti = teksti;
        this.kuvaOsoite = kuvaOsoite;
    }

    public String lue() {
        return this.teksti + " (kuvan osoite: " + this.kuvaOsoite + ")";
    }
}
</pre>

        <p>Samalla he joutuvat myös muuttamaan UutisPalvelu-luokan toteutusta, sillä se ei tue uutta uutisformaattia: </p>

<pre class="sh_java">
public class Uutispalvelu {

    public KuvaUutinen haeViimeisinUutinen() {
        return new KuvaUutinen("uusinta hottia!", "kuvan osoite");
    }
}
</pre>

        <p>Nyt julkaisupalvelun toteutusta on <em>pakko</em> muuttaa, sillä se ei enää toimi koska Uutispalvelu palauttaa <code>KuvaUutinen</code>-luokan ilmentymän. Kuinka montaa luokkaa pitäisi muuttaa jos uutispalvelua olisi käyttänyt kymmenen palvelua, entä jos tuhat? Tässä vaiheessa <em>jokaisen</em> uutispalvelua käyttävän sovelluksen tulee muuttaa omaa toimintaansa.</p>

        <p>Entä jos kaikissa uutisissa ei ole kuvia, ja haluaisimme silloin tällöin kuitenkin palauttaa <code>Uutinen</code>-luokan ilmentymän? Yllä oleva metodi <code>haeViimeisinUutinen</code> ei taida riittää..</p>

        <p>Pohditaan seuraavaksi yllä tehtyä uutisformaatin muutosta tilanteessa, jossa Uutispalvelun <code>haeViimeisinUutinen</code>-metodin palautustyyppi on <code>Luettava</code>.</p>


<pre class="sh_java">
public class Uutispalvelu {

    public Luettava haeViimeisinUutinen() {
        return new Uutinen("uusinta hottia!");
    }
}
</pre>

        <p>Kun Uutispalvelun toimitusjohtaja haluaa uuden kuvaformaatin, ei Uutispalvelun <code>haeViimeisinUutinen</code>-metodin palautustyypille tarvitse tehdä mitään.</p>

<pre class="sh_java">
public class Uutispalvelu {

    public Luettava haeViimeisinUutinen() {
        return new KuvaUutinen("uusinta hottia!", "kuvan osoite");
    }
}
</pre>

        <p>Julkaisupalveluunkaan ei tarvitse tehdä muutoksia.</p>

<pre class="sh_java">
public class Julkaisupalvelu {
    private Uutispalvelu uutispalvelu;

    public Julkaisupalvelu() {
        this.uutispalvelu = new Uutispalvelu();
    }

    public void kaynnista() {
        while (true) {
            Luettava luettava = uutispalvelu.haeViimeisinUutinen();
            System.out.println(luettava.lue());

            try {
                Thread.sleep(10000);
            } catch (Exception e) {
            }
        }
    }
}
</pre>

        <p>Kuinka montaa luokkaa olisi pitänyt muuttaa jos uutispalvelua olisi käyttänyt kymmenen palvelua, entä jos tuhat? Nollaa. Entä jos uutispalvelu haluaa välillä lähettää normaaleja uutisia, välillä kuvallisia uutisia? Helppo homma, muutos tarvitaan vain uutispalvelun puolelle.</p>

<pre class="sh_java">
public class Uutispalvelu {

    public Luettava haeViimeisinUutinen() {
        Random random = new Random();

        if(random.nextDouble() > 0.5) {
            return new Uutinen("uusinta hottia!");
        }

        return new KuvaUutinen("uusinta hottia!", "kuvan osoite");
    }
}
</pre>

    <p>Emme joudu tässäkään tapauksessa muuttamaan Uutispalvelua käyttäviä sovelluksia.</p>


    <p><em>Rajapintojen käyttö ohjelmoinnissa mahdollistaa riippuvaisuuksien vähentämisen. Jos kaikki uutispalvelua käyttävät palvelut käyttävät rajapintaa Luettava, eivät ne ole suoraan riippuvaisia jostain tietystä Luettava-rajapinnan toteuttavasta luokasta. Yllä olevassa esimerkissä uutispalvelun sisäistä toteutusta pystyi muuttamaan siten, että siinä tehdyt muutokset eivät vaikuttaneet uutispalvelua käyttäneisiin olioihin millään tavalla.</em></p>

-->

    <h3>Valmiit rajapinnat</h3>

    <p>Javan API tarjoaa huomattavan määrän valmiita rajapintoja. Tutustutaan tässä neljään ehkä Javan eniten käytettyyn rajapintaan: <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html" target="_blank">List</a></code>, <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Map.html" target="_blank">Map</a></code>, <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a></code> ja <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Collection.html" target="_blank">Collection</a></code>.</p>

    <h4>List</h4>

    <p>Rajapinta <a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html">List</a> määrittelee listoihin liittyvän peruskäyttäytymisen. Koska ArrayList-luokka toteuttaa <code>List</code>-rajapinnan, voi sitä käyttää myös <code>List</code>-rajapinnan kautta.</p>

<pre class="sh_java">
List&lt;String&gt; characterStringt = new ArrayList&lt;String&gt;();
characterStringt.add("characterString-olio arraylist-oliossa!");
</pre>

    <p>Kuten huomaamme <a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html">List-rajapinnan Java API</a>:sta, rajapinnan <code>List</code> toteuttavia luokkia on useita. Eräs tietojenkäsittelijöille tuttu listarakenne on linkitetty lista (<a href="http://docs.oracle.com/javase/6/docs/api/java/util/LinkedList.html" target="_blank">linked list</a>). Linkitettyä listaa voi käyttää rajapinnan List-kautta täysin samoin kuin ArrayLististä luotua oliota.</p>

<pre class="sh_java">
List&lt;String&gt; characterStringt = new LinkedList&lt;String&gt;();
characterStringt.add("characterString-olio linkedlist-oliossa!");
</pre>

    <p>Molemmat rajapinnan <code>List</code> toteutukset toimivat käyttäjän näkökulmasta samoin. Rajapinta siis <em>abstrahoi</em> niiden sisäisen toiminnallisuuden. ArrayListin ja LinkedListin sisäinen rakenne on kuitenkin huomattavan erilainen. ArrayList tallentaa alkioita taulukkoon, josta tietyllä indeksillä hakeminen on nopeaa. LinkedList taas rakentaa listan, jossa jokaisessa listan alkiossa on viite seuraavan listan alkioon. Kun linkitetyssä listassa haetaan alkiota tietyllä indeksillä, tulee listaa käydä läpi alusta indeksiin asti.</p>

    <p>Isoilla listoille voimme nähdä huomattaviakin suorituskykyeroja. Linkitetyn listan vahvuutena on se, että listaan lisääminen on aina nopeaa. ArrayListillä taas taustalla on taulukko, jota täytyy kasvattaa aina kun se täyttyy. Taulukon kasvattaminen vaatii uuden taulukon luonnin ja vanhan taulukon tietojen kopioinnin uuteen taulukkoon. Toisaalta, indeksin perusteella hakeminen on Arraylististä erittäin nopeaa, kun taas linkitetyssä listassa joudutaan käymään listan alkioita yksitellen läpi tiettyyn indeksiin pääsemiseksi. Tietorakenteiden kuten linkitetyn listan ja ArrayListin sisäisestä toteutuksesta tulee lisää tietoa kurssilla <em>Tietorakenteet ja algoritmit</em>.</p>

    <p>Ohjelmointikurssilla eteen tulevissa tilanteissa kannattaa käytännössä aina valita ArrayList. Rajapintoihin ohjelmointi kuitenkin kannattaa: toteuta ohjelmasi siten, että käytät tietorakenteita rajapintojen kautta.</p>

    <h4>Map</h4>

    <p>Rajapinta <a href="http://download.oracle.com/javase/6/docs/api/java/util/Map.html">Map</a> määrittelee hajautustauluihin liittyvän peruskäyttäytymisen. Koska HashMap-luokka toteuttaa <code>Map</code>-rajapinnan, voi sitä käyttää myös <code>Map</code>-rajapinnan kautta.</p>

<pre class="sh_java">
Map&lt;String, String&gt; kaannokset = new HashMap&lt;String, String&gt;();
kaannokset.put("gambatte", "tsemppiä");
kaannokset.put("hai", "kyllä");
</pre>

    <p>Hajautustaulun avaimet saa hajautustaulusta <code>keySet</code>-metodin avulla.</p>

<pre class="sh_java">
Map&lt;String, String&gt; kaannokset = new HashMap&lt;String, String&gt;();
kaannokset.put("gambatte", "tsemppiä");
kaannokset.put("hai", "kyllä");

for(String key: kaannokset.keySet()) {
    System.out.println(key + ": " + kaannokset.get(key));
}
</pre>

<pre>
gambatte: tsemppiä
hai: kyllä
</pre>

    <p>Metodi <code>keySet</code> palauttaa <code>Set</code>-rajapinnan toteuttavan joukon alkioita. <code>Set</code>-rajapinnan toteuttavan joukon voi käydä läpi for-each -toistorakenteella. Hajautustaulusta saa talletetut arvot metodin <code>values</code>-avulla. Metodi <code>values</code> palauttaa <code>Collection</code> rajapinnan toteuttavan joukon alkioita. Tutustutaan vielä pikaisesti Set- ja Collection-rajapintoihin.</p>

    <h4>Set</h4>

    <p>Rajapinta <a href="http://download.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a> kuvaa joukkoihin liittyvää toiminnallisuutta. Javassa joukot sisältävät aina joko 0 tai 1 kappaletta tiettyä oliota. Set-rajapinnan toteuttaa muun muassa <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html" target="_blank">HashSet</a></code>. Joukon alkioita pystyy käymään läpi for-each -rakenteen avulla seuraavasti.</p>

<pre class="sh_java">
Set&lt;String&gt; joukko = new HashSet&lt;String&gt;();
joukko.add("yksi");
joukko.add("yksi");
joukko.add("kaksi");

for (String alkio: joukko) {
    System.out.println(alkio);
}
</pre>

<pre>
yksi
kaksi
</pre>

    <p>Huomaa että HashSet ei ota millään tavalla kantaa joukon alkioiden järjestykseen.</p>

    <h4>Collection</h4>

    <p>Rajapinta <a href="http://download.oracle.com/javase/6/docs/api/java/util/Collection.html" target="_blank">Collection</a> kuvaa kokoelmiin liittyvää toiminnallisuutta. Javassa muun muassa listat ja joukot ovat kokoelmia -- rajapinnat List ja Set toteuttavat rajapinnan Collection. Kokoelmarajapinta tarjoaa metodit muun muassa alkioiden olemassaolon tarkistamiseen (metodi <code>contains</code>) ja kokoelman koon tarkistamiseen (metodi <code>size</code>). Kaikkia kokoelmarajapinnan toteuttavia luokkia voi käydä läpi <code>for-each</code> -toistolausekkeella. </p>

    <p>Luodaan vielä hajautustaulu ja käydään erikseen läpi siihen liittyvät avaimet ja arvot.</p>

<pre class="sh_java">
Map&lt;String, String&gt; kaannokset = new HashMap&lt;String, String&gt;();
kaannokset.put("gambatte", "tsemppiä");
kaannokset.put("hai", "kyllä");

Set&lt;String&gt; avaimet = kaannokset.keySet();
Collection&lt;String&gt; avainKokoelma = avaimet;

System.out.println("Avaimet:");
for(String avain: avainKokoelma) {
    System.out.println(avain);
}

System.out.println();
System.out.println("Arvot:");
Collection&lt;String&gt; arvot = kaannokset.values();
for(String arvo: arvot) {
    System.out.println(arvo);
}
</pre>

<pre>
Avaimet:
gambatte
hai

Arvot:
kyllä
tsemppiä
</pre>


    <p>Myös seuraavanlainen hajautustaulun käyttö olisi luonut saman tulostuksen.</p>

<pre class="sh_java">
Map&lt;String, String&gt; kaannokset = new HashMap&lt;String, String&gt;();
kaannokset.put("gambatte", "tsemppiä");
kaannokset.put("hai", "kyllä");

System.out.println("Avaimet:");
for(String avain: kaannokset.keySet()) {
    System.out.println(avain);
}

System.out.println();
System.out.println("Arvot:");
for(String arvo: kaannokset.values()) {
    System.out.println(arvo);
}
</pre>

    <p>Seuraavassa tehtävässä rakennetaan verkkokauppa ja harjoitellaan luokkien käyttämistä niiden tarjoamien rajapintojen kautta.</p>

<div class="tehtavat">
  <h3>Verkkokauppa</h3>

  <p>Teemme tehtävässä muutamia verkkokaupan hallinnointiin soveltuvia ohjelmakomponentteja.</p>

  <h4>Varasto</h4>

  <p>Tee luokka Varasto jolla on seuraavat metodit:</p>

  <ul>
    <li><code>public void lisaaTuote(String tuote, int hinta, int saldo)</code> lisää varastoon tuotteen jonka hinta ja varastosaldo ovat parametrina annetut values</li>
    <li><code>public int hinta(String tuote)</code> palauttaa parametrina olevan tuotteen hinnan, jos tuotetta ei ole varastossa, palauttaa metodi -99</li>
  </ul>


  <p>Varaston sisällä tuotteiden hinnat (ja seuraavassa kohdassa saldot) tulee tallettaa <code>Map&lt;String, Integer&gt;</code>-tyyppiseksi määriteltyyn muuttujaan! Luotava olio voi olla tyypiltään <code>HashMap</code>, muuttujan tyyppinä on kuitenkin käytettävä <code>Map</code>-rajapintaa (ks. <a href="#46.4.2">46.4.2.</a>)</p>

  <p>Seuraavassa esimerkki varaston käytöstä:</p>

<pre class="sh_java">
        Varasto varasto = new Varasto();
        varasto.lisaaTuote("maito", 3, 10);
        varasto.lisaaTuote("kahvi", 5, 7);

        System.out.println("hinnat:");
        System.out.println("maito:  " + varasto.hinta("maito"));
        System.out.println("kahvi:  " + varasto.hinta("kahvi"));
        System.out.println("sokeri: " + varasto.hinta("sokeri"));
</pre>

<p>Tulostuu:</p>

<pre>
hinnat:
maito:  3
kahvi:  5
sokeri: -99
</pre>

<h4>Tuotteen varastosaldo</h4>

  <p>Talleta tuotteiden varastosaldot samaan tapaan <code>Map&lt;String, Integer&gt;</code>-tyyppiseen muuttujaan kuin talletit hinnat. Täydennä varastoa seuraavilla metodeilla:</p>

  <ul>
    <li><code>public int saldo(String tuote)</code> palauttaa parametrina olevan tuotteen varastosaldon.</li>
    <li><code>public boolean ota(String tuote)</code> vähentää parametrina olevan tuotteen saldoa yhdellä ja palauuttaa <em>true</em> jos tuotetta oli varastossa. Jos tuotetta ei ole varastossa, palauttaa metodi <em>false</em>, tuotteen saldo ei saa laskea alle nollan.</li>
  </ul>


  <p>Esimerkki varaston käytöstä:</p>

<pre class="sh_java">
        Varasto varasto = new Varasto();
        varasto.lisaaTuote("kahvi", 5, 1);

        System.out.println("saldot:");
        System.out.println("kahvi:  " + varasto.saldo("kahvi"));
        System.out.println("sokeri: " + varasto.saldo("sokeri"));

        System.out.println("otetaan kahvi " + varasto.ota("kahvi"));
        System.out.println("otetaan kahvi " + varasto.ota("kahvi"));
        System.out.println("otetaan sokeri " + varasto.ota("sokeri"));

        System.out.println("saldot:");
        System.out.println("kahvi:  " + varasto.saldo("kahvi"));
        System.out.println("sokeri: " + varasto.saldo("sokeri"));
</pre>

<p>Tulostuu:</p>

<pre>
saldot:
kahvi:  1
sokeri: 0
otetaan kahvi true
otetaan kahvi false
otetaan sokeri false
saldot:
kahvi:  0
sokeri: 0
</pre>

<h4>Tuotteiden listaus</h4>

  <p>Listätään varastolle vielä yksi metodi:</p>

  <ul>
    <li><code>public Set&lt;String&gt; tuotteet()</code> palauttaa <em>joukkona</em> varastossa olevien tuotteiden nimet</li>
  </ul>

  <p>Metodi on helppo toteuttaa. Saat tietoon varastossa olevat tuotteet kysymällä ne joko hinnat tai saldot muistavalta Map:iltä metodin <code>keySet</code> avulla.</p>

<p>Esimerkki varaston käytöstä:</p>

<pre class="sh_java">
        Varasto varasto = new Varasto();
        varasto.lisaaTuote("maito", 3, 10);
        varasto.lisaaTuote("kahvi", 5, 6);
        varasto.lisaaTuote("piimä", 2, 20);
        varasto.lisaaTuote("jugurtti", 2, 20);

        System.out.println("tuotteet:");
        for (String tuote : varasto.tuotteet()) {
            System.out.println(tuote);
        }
</pre>

<p>Tulostuu:</p>

<pre>
tuotteet:
piimä
jugurtti
kahvi
maito
</pre>

<h4>Ostos</h4>

  <p>Ostoskoriin lisätään <em>ostoksia</em>. Ostoksella tarkoitetaan tiettyä määrää tiettyjä tuotteita. Koriin voidaan laittaa esim. ostos joka vastaa yhtä leipää tai ostos joka vastaa 24:ää kahvia.</p>

  <p>Tee luokka <code>Ostos</code> jolla on seuraavat toiminnot:</p>

  <ul>
    <li><code>public Ostos(String tuote, int kpl, int yksikkohinta)</code> konstruktori joka luo ostoksen joka vastaa parametrina annettua tuotetta. Tuotteita ostoksessa on <em>kpl</em> kappaletta ja yhden tuotteen hinta on kolmantena parametrina annettu <em>yksikkohinta</em></li>
    <li><code>public int hinta()</code> palauttaa ostoksen hinnan. Hinta saadaan kertomalla kappalemäärä yksikköhinnalla</li>
    <li><code>public void kasvataMaaraa()</code> kasvattaa ostoksen kappalemäärää yhdellä</li>
    <li><code>public String toString()</code> palauttaa ostoksen characterStringmuodossa, joka on alla olevan esimerkin mukainen</li>
  </ul>

  <p>Esimerkki ostoksen käytöstä</p>

<pre class="sh_java">
        Ostos ostos = new Ostos("maito", 4, 2);
        System.out.println( "ostoksen joka sisältää 4 maitoa yhteishinta on " + ostos.hinta() );
        System.out.println( ostos );
        ostos.kasvataMaaraa();
        System.out.println( ostos );
</pre>

<p>Tulostuu:</p>

<pre>
ostoksen joka sisältää 4 maitoa yhteishinta on 8
maito: 4
maito: 5
</pre>

  <p>Huom: <em>toString</em> on siis muotoa <em>tuote: kpl</em> hintaa ei characterStringesitykseen tule!</p>

<h4>Ostoskori</h4>

  <p>Vihdoin pääsemme toteuttamaan luokan ostoskori!</p>

  <p>Ostoskori tallettaa sisäisesti koriin lisätyt tuotteet <em>Ostos-olioina</em>. Ostoskorilla tulee olla oliomuuttuja jonka tyyppi on joko <code>Map&lt;String, Ostos&gt;</code> tai <code>List&lt;Ostos&gt;</code>. Älä laita mitään muita oliomuuttujia ostoskorille kuin ostosten talletukseen tarvittava Map tai List.</p>

  <p>Huom: jos talletat Ostos-oliot Map-tyyppiseen apumuuttujaan, on tässä ja seuraavassa tehtävässä hyötyä Map:in metodista values(), jonka avulla on helppo käydä läpi kaikki talletetut ostos-oliot.</p>

  <p>Tehdään aluksi ostoskorille parametriton konstruktori ja metodit:</p>

  <ul>
    <li><code>public void lisaa(String tuote, int hinta)</code> lisää ostoskoriin ostoksen joka vastaa parametrina olevaa tuotetta ja jolla on parametrina annettu hinta.</li>
    <li><code>public int hinta()</code> palauttaa ostoskorin kokonaishinnan</li>
</ul>

<p>Esimerkki ostoksen käytöstä</p>

<pre class="sh_java">
        Ostoskori kori = new Ostoskori();
        kori.lisaa("maito", 3);
        kori.lisaa("piimä", 2);
        kori.lisaa("juusto", 5);
        System.out.println("korin hinta: " + kori.hinta());
        kori.lisaa("tietokone", 899);
        System.out.println("korin hinta: " + kori.hinta());
</pre>

<p>Tulostuu:</p>

<pre>
korin hinta: 10
korin hinta: 909
</pre>

<h4>Ostoskorin tulostus</h4>

  <p>Tehdään ostoskorille metodi <code>public void tulosta()</code> joka tulostaa korin sisältämät <em>Ostos</em>-oliot. Tulostusjärjestyksessä ei ole merkitystä. Edellisen esimerkin ostoskori tulostetuna olisi:</p>

<pre>
piimä: 1
juusto: 1
tietokone: 1
maito: 1
</pre>

  <p>Huomaa, että tulostuva numero on siis tuotteen korissa oleva kappalemäärä, ei hinta!</p>

<h4>yhtä tuotetta kohti vain yksi Ostos-olio</h4>

  <p>Täydennetään Ostoskoria siten, että jos korissa on jo tuote joka sinne lisätään, ei koriin luoda uutta Ostos-olioa vaan päivitetään jo korissa olevaa tuotetta vastaavaa ostosolioa kutsumalla sen metodia <em>kasvataMaaraa()</em>.</p>

<p>Esimerkki:</p>

<pre class="sh_java">
        Ostoskori kori = new Ostoskori();
        kori.lisaa("maito", 3);
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta() +"\n");

        kori.lisaa("piimä", 2);
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta() +"\n");

        kori.lisaa("maito", 3);
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta() +"\n");

        kori.lisaa("maito", 3);
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta() +"\n");
</pre>

<p>Tulostuu:</p>

<pre>
maito: 1
korin hinta: 3

piimä: 1
maito: 1
korin hinta: 5

piimä: 1
maito: 2
korin hinta: 8

piimä: 1
maito: 3
korin hinta: 11
</pre>

  <p>Eli ensin koriin lisätään maito ja piimä ja niille omat ostos-oliot. Kun koriin lisätään lisää maitoa, ei luoda uusille maidoille omaa ostosolioa, vaan päivitetään jo korissa olevan maitoa kuvaavan ostosolion kappalemäärää.</p>

<h4>Kauppa</h4>

  <p>Nyt meillä on valmiina kaikki osat "verkkokauppaa" varten. Verkkokaupassa on varasto joka sisältää kaikki tuotteet. Jokaista asiakkaan asiointia varten on oma ostoskori. Aina kun asiakas valitsee ostoksen, lisätään se asiakkaan ostoskoriin jos tuotetta on varastossa. Samalla varastosaldoa pienennetään yhdellä.</p>

  <p>Seuraavassa on valmiina verkkokaupan koodin runko. Tee projektiin luokka <code>Kauppa</code> ja kopioi alla oleva koodi luokkaan.</p>

<pre class="sh_java">
import java.util.Scanner;

public class Kauppa {

    private Varasto varasto;
    private Scanner lukija;

    public Kauppa(Varasto varasto, Scanner lukija) {
        this.varasto = varasto;
        this.lukija = lukija;
    }

    // metodi jolla hoidetaan yhden asiakkaan asiointi kaupassa
    public void asioi(String asiakas) {
        Ostoskori kori = new Ostoskori();
        System.out.println("Tervetuloa kauppaan " + asiakas);
        System.out.println("valikoimamme:");

        for (String tuote : varasto.tuotteet()) {
            System.out.println( tuote );
        }

        while (true) {
            System.out.print("mitä laitetaan ostoskoriin (pelkkä enter vie kassalle):");
            String tuote = reader.nextLine();
            if (tuote.isEmpty()) {
                break;
            }

            // tee tänne koodi joka lisää tuotteen ostoskoriin jos sitä on varastossa
            // ja vähentää varastosaldoa
            // älä koske muuhun koodiin!

        }

        System.out.println("ostoskorissasi on:");
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta());
    }
}
</pre>

<p>Seuraavassa pääohjelma joka täyttää kaupan varaston ja laittaa Pekan asioimaan kaupassa:</p>

<pre class="sh_java">
    Varasto varasto = new Varasto();
    varasto.lisaaTuote("kahvi", 5, 10);
    varasto.lisaaTuote("maito", 3, 20);
    varasto.lisaaTuote("piimä", 2, 55);
    varasto.lisaaTuote("leipä", 7, 8);

    Kauppa kauppa = new Kauppa(varasto, new Scanner(System.in));
    kauppa.asioi("Pekka");
</pre>

  <p>Kauppa on melkein valmiina. Yhden asiakkaan asioinnin hoitavan metodin <code>public void asioi(String asiakas)</code> on kommenteilla merkitty kohta jonka joudut täydentämään. Lisää kohtaan koodi joka tarkastaa onko asiakkaan haluamaa tuotetta varastossa. Jos on, vähennä tuotteen varastosaldoa ja lisää tuote ostoskoriin.</p>

  <p><em>Vapise, verkkokauppa.com!</em></p>
</div>

<h2>Geneerisyys</h2>

    <p>Geneerisyys (<em>generics</em>) liittyy olioita säilövien luokkien tapaan säilöä vapaavalintaisen tyyppisiä olioita. Vapaavalintaisuus perustuu luokkien määrittelyssä käytettyyn geneeriseen tyyppiparametriin, jonka avulla voidaan määritellä <em>olion luontivaiheessa</em> valittavia tyyppejä. Luokan geneerisyys määritellään antamalla luokan nimen jälkeen haluttu määrä luokan tyyppiparametreja pienempi kuin ja suurempi kuin -merkkien väliin. Toteutetaan oma geneerinen luokka <code>Lokero</code>, johon voi asettaa yhden minkälaisen tahansa olion.</p>

<pre class="sh_java">
public class Lokero&lt;T&gt; {
    private T alkio;

    public void asetaArvo(T alkio) {
        this.alkio = alkio;
    }

    public T haeArvo() {
        return alkio;
    }
}
</pre>

    <p>Määrittely <code>public class Lokero&lt;T&gt;</code> kertoo että luokalle <code>Lokero</code> tulee antaa konstruktorissa tyyppiparametri. Konstruktorikutsun jälkeen kaikki olion sisäiset muuttujat tulevat olemaan kutsun yhteydessä annettua tyyppiä. Luodaan characterStringn tallentava lokero.</p>

<pre class="sh_java">
    Lokero&lt;String&gt; characterString = new Lokero&lt;String&gt;();
    characterString.asetaArvo(":)");

    System.out.println(characterString.haeArvo());
</pre>

<pre>
:)
</pre>

    <p>Tyyppiparametria vaihtamalla voidaan luoda myös muuntyyppisiä olioita tallentavia <code>Lokero</code>-olioita. Esimerkiksi kokonaisluvun saa tallennettua seuraavasti</p>

<pre class="sh_java">
    Lokero&lt;Integer&gt; luku = new Lokero&lt;Integer&gt;();
    luku.asetaArvo(5);

    System.out.println(luku.haeArvo());
</pre>


<pre>
5
</pre>

    <p>Huomattava osa Javan tietorakenteista on ohjelmoitu geneerisiksi. Esimerkiksi ArrayList saa yhden tyyppiparametrin, HashMap kaksi.</p>

<pre class="sh_java">
    List&lt;String&gt; characterStringt = new ArrayList&lt;String&gt;();
    Map&lt;String, String&gt; avainArvoParit = new HashMap&lt;String, String&gt;();
</pre>

    <p>Jatkossa kun näet esimerkiksi tyypin <code>ArrayList&lt;String&gt;</code> tiedät että sen sisäisessä rakenteessa on käytetty geneeristä tyyppiparametria.</p>

    <h3>Geneerisyyttä hyödyntävä rajapinta: Comparable</h3>

    <p>Normaalien rajapintojen lisäksi Javassa on geneerisyyttä hyödyntäviä rajapintoja. Geneerisille rajapinnoille määritellään sisäisten arvojen tyypit samalla tavalla kuin geneerisille luokille. Tutkitaan Javan valmista rajapintaa <code><a href="http://java.sun.com/javase/6/docs/api/java/lang/Comparable.html">Comparable</a></code>. Rajapinta <code>Comparable</code> määrittelee metodin <code>compareTo</code>, jonka tulee palauttaa <code>this</code>-olion paikan vertailujärjestyksessä verrattuna parametrina annettuun olioon (negatiivinen luku, 0 tai positiivinen luku). Jos <code>this</code>-olio on vertailujärjestyksessä ennen parametrina saatavaa olioa, tulee metodin palauttaa negatiivinen luku, jos taas parametrina saatava olio on järjestyksessä ennen, tulee metodin palauttaa positiivinen luku. Jos oliot ovat vertailujärjestykseltään samat, palautetaan 0. Vertailujärjestyksellä tarkoitetaan tässä ohjelmoijan määrittelemää olioiden "suuruusjärjestystä", eli jos oliot järjestetään sort-metodilla, mikä on niiden järjestys.</p>

    <p>Yksi <code>Comparable</code>-rajapinnan eduista on se, että se mahdollistaa Comparable-tyyppisistä alkioista koostuvan listan järjestämisen esimerkiksi standardikirjaston <code>Collections.sort</code>-metodin avulla. <code>Collections.sort</code> käyttää listan alkioiden <code>compareTo</code>-metodia selvittääkseen, missä järjestyksessä alkoiden kuuluisi olla. Tätä <code>compareTo</code>-metodin avulla johdettua järjestystä kutsutaan <em>luonnolliseksi järjestykseksi</em> (natural ordering).</p>

    <p>Luodaan luokka <code>Kerholainen</code>, joka kuvaa kerhossa käyvää lasta tai nuorta. Jokaisella kerholaisella on nimi ja pituus. Kerholaisten tulee mennä aina syömään pituusjärjestyksessä, joten toteutetaan kerholaisille rajapinta <code>Comparable</code>. Comparable-rajapinta ottaa tyyppiparametrinaan myös luokan, johon sitä verrataan. Käytetään tyyppiparametrina luokkaa <code>Kerholainen</code>-luokkaa.</p>

<pre class="sh_java">
public class Kerholainen implements Comparable&lt;Kerholainen&gt; {
    private String name;
    private int pituus;

    public Kerholainen(String name, int pituus) {
        this.name = nimi;
        this.pituus = pituus;
    }

    public String getName() {
        return this.name;
    }

    public int getPituus() {
        return this.pituus;
    }

    @Override
    public String toString() {
        return this.getName() + " (" + this.getPituus() + ")";
    }

    @Override
    public int compareTo(Kerholainen kerholainen) {
        if(this.pituus == kerholainen.getPituus()) {
            return 0;
        } else if (this.pituus &gt; kerholainen.getPituus()) {
            return 1;
        } else {
            return -1;
        }
    }
}
</pre>

    <p>Rajapinnan vaatima metodi <code>compareTo</code> palauttaa kokonaisluvun, joka kertoo vertausjärjestyksestä. Koska <code>compareTo()</code>-metodista riittää palauttaa negatiivinen luku, jos <code>this</code>-olio on pienempi kuin parametrina annettu olio ja nolla, kun pituudet ovat samat, voidaan edellä esitelty metodi <code>compareTo</code> toteuttaa myös seuraavasti:</p>

<pre class="sh_java">
    @Override
    public int compareTo(Kerholainen kerholainen) {
        return this.pituus - kerholainen.getPituus();
    }
</pre>

    <p>Kerholaisten järjestäminen on nyt helppoa.</p>

<pre class="sh_java">
    List&lt;Kerholainen&gt; kerholaiset = new ArrayList&lt;Kerholainen&gt;();
    kerholaiset.add(new Kerholainen("mikael", 182));
    kerholaiset.add(new Kerholainen("matti", 187));
    kerholaiset.add(new Kerholainen("joel", 184));

    System.out.println(kerholaiset);
    Collections.sort(kerholaiset);
    System.out.println(kerholaiset);
</pre>

<pre>
[mikael (182), matti (187), joel (184)]
[mikael (182), joel (184), matti (187)]
</pre>

    <p>Jos kerholaiset haluaa järjestää käänteiseen järjestykseen, riittää vain <code>compareTo</code>-metodissa olevien muuttujien paikan vaihtaminen.</p>


<div class="tehtavat">

  <h3>Köyhät kyykkyyn</h3>

  <p>Saat valmiin luokan Ihminen. Ihmisellä on nimi- ja palkkatiedot. Muokkaa Ihminen-luokasta <code>Comparable</code>-rajapinnan toteuttava niin, että <code>compareTo</code>-metodi lajittelee ihmiset palkan mukaan järjestykseen - suuripalkkaiset ensin, köyhät kyykkyyn listan loppuun.</p>


  <h3>Opiskelijat nimijärjestykseen</h3>

  <p>Saat valmiin luokan Opiskelija. Opiskelijalla on nimi. Muokkaa Opiskelija-luokasta <code>Comparable</code>-rajapinnan toteuttava niin, että <code>compareTo</code>-metodi lajittelee opiskelijat nimen mukaan aakkosjärjestykseen.</p>

  <p><b>Vinkki:</b> Opiskelijan nimi on String, ja String-luokka on itsessään <code>Comparable</code>. Voit hyödyntää String-luokan <code>compareTo</code>-metodia Opiskelija-luokan metodia toteuttaessasi. <code>String.compareTo</code> kohtelee kirjaimia eriarvoisesti kirjainkoon mukaan, ja tätä varten String-luokalla on myös metodi <code>compareToIgnoreCase</code> joka nimensä mukaisesti jättää kirjainkoon huomioimatta. Voit käyttää opiskelijoiden järjestämiseen kumpaa näistä haluat.</p>


  <h3>Kortit ojennukseen</h3>

<p>Tehtäväpohjan mukana on luokka, jonka oliot kuvaavat pelikortteja. Kortilla on arvo ja maa. Kortin arvo on <em>2, 3, ..., 10, J, Q, K </em> tai <em>A</em> ja maa <em>Risti, Ruutu, Hertta</em> tai <em>Pata</em>. Arvo ja maa kuitenkin esitetään olioiden sisällä kokonaislukuina. Kortilla on myös metodi toString, jota käyttäen kortin arvo ja maa tulostuvat "ihmisystävällisesti". </p>

<p>Jotta korttien käyttäjän ei tarvitsisi käsitellä korttien maita numeroina, on luokkaan määritelty neljä <strong>vakioa</strong> eli <code>public static final</code> -muuttujaa: </p>

<pre class="sh_java">
public class Kortti {
    public static final int RISTI  = 0;
    public static final int RUUTU  = 1;
    public static final int HERTTA = 2;
    public static final int PATA   = 3;

    // ...
}
</pre>

<p>Nyt ohjelmassa voidaan luvun 1 sijaan käyttää vakioa <code>Kortti.RUUTU</code>. Seuraavassa esimerkissä luodaan kolme korttia ja tulostetaan ne:</p>

<pre class="sh_java">
  Kortti eka = new Kortti(2, Kortti.RUUTU);
  Kortti toka = new Kortti(14, Kortti.PATA);  
  Kortti kolmas = new Kortti(12, Kortti.HERTTA);

  System.out.println(eka);
  System.out.println(toka);
  System.out.println(kolmas);
</pre>

<p>Tulostuu:</p>

<pre>
Ruutu 2
Pata A
Hertta Q
</pre>

<p><b>HUOM:</b> vaikioiden käyttö ylläolevaan tapaan ei ole tyylikkäin tapa asian hoitamiseen. Myöhemmin kurssilla opimme oikeaoppisen tyylin maan esittämiseen!</p>

  <h4>Kortti-luokasta Comparable</h4>

  <p>Tee Kortti-luokasta Comparable. Toteuta <code>compareTo</code>-metodi niin, että korttien järjestys on arvon mukaan nouseva. Jos verrattavien Korttien arvot ovat samat, verrataan niitä maan perusteella nousevassa järjestyksessä: <em>risti ensin, ruutu toiseksi, hertta kolmanneksi, pata viimeiseksi.</em> </p> 

<p>Järjestyksessä pienin kortti siis olisi risti kakkonen ja suurin pataässä.</p>

<h4>Käsi</h4>

<p>Tehdään seuraavaksi luokka <code>Kasi</code> joka edustaa pelaajan kädessään pitämää korttien joukkoa. Tee kädelle seuraavat metodit:</p>

<ul>
<li><code>public void lisaa(Kortti kortti)</code> lisää käteen kortin</li>
<li><code>public void tulosta()</code> tulostaa kädessä olevat kortit alla olevan esimerkin tyylillä</li>
</ul>

<pre class="sh_java">
  Kasi kasi = new Kasi();

  kasi.lisaa( new Kortti(2, Kortti.RUUTU) );
  kasi.lisaa( new Kortti(14, Kortti.PATA) );
  kasi.lisaa( new Kortti(12, Kortti.HERTTA) );
  kasi.lisaa( new Kortti(2, Kortti.PATA) );

  kasi.tulosta();
</pre>

<p>Tulostuu:</p>

<pre>
Ruutu 2
Pata A
Hertta Q
Pata 2
</pre>

<p>Talleta käden sisällä olevat kortit ArrayListiin.</p>

<h4>Käden järjestäminen</h4>

<p>Tee kädelle metodi <code>public void jarjesta()</code> jota kutsumalla käden sisällä olevat kortit menevät suuruusjärjestykseen. Järjestämisen jälkeen kortit tulostuvat järjestyksessä:</p>

<pre class="sh_java">
  Kasi kasi = new Kasi();

  kasi.lisaa( new Kortti(2, Kortti.RUUTU) );
  kasi.lisaa( new Kortti(14, Kortti.PATA) );
  kasi.lisaa( new Kortti(12, Kortti.HERTTA) );
  kasi.lisaa( new Kortti(2, Kortti.PATA) );

  kasi.jarjesta(); 

  kasi.tulosta();
</pre>

<p>Tulostuu:</p>

<pre>
Ruutu 2
Pata 2
Hertta Q
Pata A
</pre>

<h4>Käsien vertailu</h4>

<p>Eräässä korttipelissä kahdesta korttikädestä arvokkaampi on se, jonka sisältämien korttien arvon summa on suurempi. Tee luokasta <code>Kasi</code> vertailtava tämän kriteerin mukaan, eli laita luokka toteuttamaan rajapinta <code>Comparable&lt;Kasi&gt;</code>.</p>

<p>Esimerkkiohjelma, jossa vertaillaan käsiä:</p>

<pre class="sh_java">
  Kasi kasi1 = new Kasi();

  kasi1.lisaa( new Kortti(2, Kortti.RUUTU) );
  kasi1.lisaa( new Kortti(14, Kortti.PATA) );
  kasi1.lisaa( new Kortti(12, Kortti.HERTTA) );
  kasi1.lisaa( new Kortti(2, Kortti.PATA) );

  Kasi kasi2 = new Kasi();

  kasi2.lisaa( new Kortti(11, Kortti.RUUTU) );
  kasi2.lisaa( new Kortti(11, Kortti.PATA) );
  kasi2.lisaa( new Kortti(11, Kortti.HERTTA) );

  int vertailu = kasi1.compareTo(kasi2);

  if ( vertailu &lt; 0 ) {
    System.out.println("arvokkaampi käsi sisältää kortit");
    kasi2.tulosta();
  } else if ( vertailu &gt; 0 ){
    System.out.println("arvokkaampi käsi sisältää kortit");
    kasi1.tulosta(); 
  } else {
    System.out.println("kädet yhtä arvokkaat");
  }
</pre>

<p>Tulostuu</p>

<pre>
arvokkaampi käsi sisältää kortit
Ruutu J
Pata J
Hertta J
</pre>

<h4>Korttien järjestäminen eri kriteerein</h4>

<p>Entä jos haluaisimme välillä järjestää kortit hieman eri tavalla, esim. kaikki saman maan kortit peräkkäin? 
Luokalla voi olla vain yksi compareTo-metodi, joten joudumme muunlaisia järjestyksiä saadaksemme turvautumaan muihin keinoihin.</p>

<p>
Vaihtoehtoiset järjestämistavat toteutetaan erillisten vertailun suorittavien luokkien avulla. Korttien vaihtoehtoisten järjestyksen määräävän luokkien tulee toteuttaa <code>Comparator&lt;Kortti&gt;</code>-rajapinta. Järjestyksen määräävän luokan olio vertailee kahta parametrina saamaansa korttia. Metodeja on ainoastaan yksi compare(Kortti k1, Kortti k2), jonka tulee palauttaa negatiivinen arvo, jos kortti k1 on järjestyksessä ennen korttia k2, positiivinen arvo jos k2 on järjestyksessä ennen k1:stä ja 0 muuten.

<p>
Periaatteena on luoda jokaista järjestämistapaa varten oma vertailuluokka, esim. saman maan kortit vierekkäin vievän järjestyksen määrittelevä luokka:</p>

<pre class="sh_java">
import java.util.Comparator;

public class SamatMaatVierekkain implements Comparator&lt;Kortti&gt; {
    public int compare(Kortti k1, Kortti k2) {
        return k1.getMaa()-k2.getMaa();
    }
}
</pre>

<p>Maittainen järjestys on sama kuin kortin metodin <code>compareTo</code> maille määrittelemä järjestys eli <em>ristit ensin, ruudut toiseksi, hertat kolmanneksi, padat viimeiseksi.</em></p>

<p>Järjestäminen tapahtuu edelleen luokan Collections metodin sort avulla. Metodi saa nyt toiseksi parametrikseen järjestyksen määräävän luokan olion:</p>

<pre class="sh_java">
  ArrayList&lt;Kortti&gt; kortit = new ArrayList&lt;Kortti&gt;(); 

  kortit.add( new Kortti(3, Kortti.PATA) );
  kortit.add( new Kortti(2, Kortti.RUUTU) );
  kortit.add( new Kortti(14, Kortti.PATA) );
  kortit.add( new Kortti(12, Kortti.HERTTA) );
  kortit.add( new Kortti(2, Kortti.PATA) );

  SamatMaatVierekkain samatMaatVierekkainJarjestaja = new SamatMaatVierekkain();
  Collections.sort(kortit, samatMaatVierekkainJarjestaja ); 
  
  for (Kortti k : kortit) {
    System.out.println( k );
  }
</pre>

<p>Tulostuu:</p>

<pre>
Ruutu 2
Hertta Q
Pata 3
Pata A
Pata 2
</pre>

<p>Järjestyksen määrittelevä olio voidaan myös luoda suoraan sort-kutsun yhteydessä:</p>

<pre class="sh_java">
  Collections.sort(kortit, new SamatMaatVierekkain() ); 
</pre>
<p>

  <p>Tarkempia ohjeita vertailuluokkien tekemiseen <a href="http://leepoint.net/notes-java/data/collections/comparators.html">täällä</a></p>

<p>Tee nyt luokka Comparator-rajapinnan toteuttava luokka <code>SamatMaatVierekkainArvojarjestykseen</code>
jonka avulla saat kortit muuten samanlaiseen järjestykseen kuin edellisessä esimerkissä paitsi, että saman maan kortit järjestyvät arvon mukaiseesti.
</p>

<h4>Käden järjestäminen maittain</h4>

<p>Lisää luokalle <code>Kasi</code> metodi <code>public void jarjestaMaittain()</code> jota kutsumalla käden sisällä olevat kortit menevät edellisen tehtävän vertailijan määrittelemään järjestykseen. Järjestämisen jälkeen kortit tulostuvat järjestyksessä:</p>

<pre class="sh_java">
  Kasi kasi = new Kasi();

  kasi.lisaa( new Kortti(12, Kortti.HERTTA) );
  kasi.lisaa( new Kortti(4, Kortti.PATA) );
  kasi.lisaa( new Kortti(2, Kortti.RUUTU) );
  kasi.lisaa( new Kortti(14, Kortti.PATA) );
  kasi.lisaa( new Kortti(7, Kortti.HERTTA) );
  kasi.lisaa( new Kortti(2, Kortti.PATA) );

  kasi.jarjestaMaittain(); 

  kasi.tulosta();
</pre>

<p>Tulostuu:</p>

<pre>
Ruutu 2
Hertta 7
Hertta Q
Pata 2
Pata 4
Pata A
</pre>

</div>

<h2>Collections</h2>

    <p>Luokkakirjasto <code><a href="http://java.sun.com/javase/6/docs/api/java/util/Collections.html" target="_blank">Collections</a></code> on Javan yleishyödyllinen kokoelmaluokkiin liittyvä kirjasto. Kuten tiedämme, <code>Collections</code> tarjoaa metodit olioiden järjestämiseen joko <code>Comparable</code>- tai <code>Comparator</code> -rajapinnan kautta. Järjestämisen lisäksi luokkakirjaston avulla voi etsiä esimerkiksi minimi- (<code>min</code>-metodi) tai maksimialkioita (<code>max</code>-metodi), hakea tiettyä arvoa (<code>binarySearch</code>-metodi), tai kääntää listan (<code>reverse</code>-metodi).</p>

    <h3>Hakeminen</h3>

    <p>Collections-luokkakirjasto tarjoaa valmiiksi toteutetun binäärihaun. Metodi <code>binarySearch()</code> palauttaa haetun alkion indeksin listasta jos se löytyy. Jos alkiota ei löydy, hakualgoritmi palauttaa negatiivisen arvon. Metodi <code>binarySearch()</code> käyttää Comparable-rajapintaa haetun olion löytämiseen. Jos olion <code>compareTo()</code>-metodi palauttaa arvon 0, eli olio on sama, ajatellaan arvon löytyneen.</p>

    <p>Kerholainen-luokkamme vertaa pituuksia <code>compareTo()</code>-metodissaan, eli listasta etsiessä etsisimme samanpituista kerholaista.</p>

<pre class="sh_java">
    List&lt;Kerholainen&gt; kerholaiset = new ArrayList&lt;Kerholainen&gt;();
    kerholaiset.add(new Kerholainen("mikael", 182));
    kerholaiset.add(new Kerholainen("matti", 187));
    kerholaiset.add(new Kerholainen("joel", 184));

    Collections.sort(kerholaiset);

    Kerholainen haettava = new Kerholainen("Nimi", 180);
    int indeksi = Collections.binarySearch(kerholaiset, haettava);
    if(indeksi &gt;= 0) {
        System.out.println("180 senttiä pitkä löytyi indeksistä " + indeksi);
        System.out.println("nimi: " + kerholaiset.get(indeksi).getName());
    }

    haettava = new Kerholainen("Nimi", 187);
    int indeksi = Collections.binarySearch(kerholaiset, haettava);
    if(indeksi &gt;= 0) {
        System.out.println("187 senttiä pitkä löytyi indeksistä " + indeksi);
        System.out.println("nimi: " + kerholaiset.get(indeksi).getName());
    }
</pre>

    <p>Esimerkkimme tulostaa seuraavaa</p>

<pre>
187 senttiä pitkä löytyi indeksistä 2
nimi: matti
</pre>

    <p>Huomaa että esimerkissä kutsuttiin myös metodia <code>Collections.sort()</code>. Tämä tehdään sen takia, että binäärihakua ei voida tehdä jos taulukko tai lista ei ole valmiiksi järjestyksessä.</p>







<div class="tehtavat">

<h3>Mäkihyppy</h3>

        <p>Harjoitellaan taas ohjelman rakenteen omatoimista suunnittelua. Käyttöliittymän ulkomuoto ja vaadittu toiminnallisuus on määritelty ennalta, rakenteen saat toteuttaa vapaasti.</p>

<p><b>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. Älä myöskään käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</b></p>

        <p>Mäkihyppy on suomalaisille erittäin rakas laji, jossa pyritään hyppäämään hyppyrimäestä mahdollisimman pitkälle mahdollisimman tyylikkäästi. Tässä tehtävässä tulee toteuttaa simulaattori mäkihyppykilpailulle.</p>

        <p>Simulaattori kysyy ensin käyttäjältä hyppääjien nimiä. Kun käyttäjä antaa tyhjän characterStringn (eli painaa enteriä) hyppääjän nimeksi siirrytään hyppyvaiheeseen. Hyppyvaiheessa hyppääjät hyppäävät yksitellen käänteisessä pistejärjestyksessä. Hyppääjä jolla on vähiten pisteitä kerättynä hyppää aina kierroksen ensimmäisenä, toiseksi vähiten pisteitä omaava toisena jne, ..., eniten pisteitä kerännyt viimeisenä.</p>

        <p>Hyppääjän yhteispisteet lasketaan yksittäisten hyppyjen pisteiden summana. Yksittäisen hypyn pisteytys lasketaan hypyn pituudesta (käytä satunnaista kokonaisluku väliltä 60-120) ja tuomariäänistä. Jokaista hyppyä kohden annetaan 5 tuomariääntä (satunnainen luku väliltä 10-20). Tuomariääniä laskettaessa otetaan huomioon vain kolme keskimmäistä ääntä: pienintä ja suurinta ääntä ei oteta huomioon. Esimerkiksi jos Mikael hyppää 61 metriä ja saa tuomariäänet 11, 12, 13, 14 ja 15, on hänen hyppynsä yhteispisteet 100.</p>

        <p>Kierroksia hypätään niin monta kuin ohjelman käyttäjä haluaa. Kun käyttäjä haluaa lopettaa tulostetaan lopuksi kilpailun lopputulokset. Lopputuloksissa tulostetaan hyppääjät, hyppääjien yhteispisteet ja hyppääjien hyppäämien hyppyjen pituudet. Lopputulokset on järjestetty hyppääjien yhteispisteiden mukaan siten, että eniten pisteitä kerännyt on ensimmäinen.</p>

        <p>Tehtävän tekemisessä on hyötyä <em>muun muassa</em> metodeista <code>Collections.sort</code> ja <code>Collections.reverse</code>. Kannattaa aluksi hahmotella minkälaisia luokkia ja olioita ohjelmassa voisi olla. On myös hyvä pyrkiä tilanteeseen, jossa käyttöliittymäluokka on ainut luokka joka kutsuu tulostuskomentoa.</p>

<pre>
Kumpulan mäkiviikot

Syötä kilpailun osallistujat yksi kerrallaan, tyhjällä characterStringlla siirtyy hyppyvaiheeseen.
  Osallistujan nimi: <font color="red">Mikael</font>
  Osallistujan nimi: <font color="red">Mika</font>
  Osallistujan nimi:

Kilpailu alkaa!

Kirjoita "hyppaa" niin hypätään, muuten lopetetaan: <font color="red">hyppaa</font>

1. kierros

Hyppyjärjestys:
  1. Mikael (0 pistettä)
  2. Mika (0 pistettä)

Kierroksen 1 tulokset
  Mikael
    pituus: 95
    tuomaripisteet: [15, 11, 10, 14, 14]
  Mika
    pituus: 112
    tuomaripisteet: [14, 12, 18, 18, 17]

Kirjoita "hyppaa" niin hypätään, muuten lopetetaan: <font color="red">hyppaa</font>

2. kierros

Hyppyjärjestys:
  1. Mikael (134 pistettä)
  2. Mika (161 pistettä)

Kierroksen 2 tulokset
  Mikael
    pituus: 96
    tuomaripisteet: [20, 19, 15, 13, 18]
  Mika
    pituus: 61
    tuomaripisteet: [12, 11, 15, 17, 11]

Kirjoita "hyppaa" niin hypätään, muuten lopetetaan: <font color="red">hyppaa</font>

3. kierros

Hyppyjärjestys:
  1. Mika (260 pistettä)
  2. Mikael (282 pistettä)

Kierroksen 3 tulokset
  Mika
    pituus: 88
    tuomaripisteet: [11, 19, 13, 10, 15]
  Mikael
    pituus: 63
    tuomaripisteet: [12, 19, 19, 12, 12]

Kirjoita "hyppaa" niin hypätään, muuten lopetetaan: <font color="red">lopeta</font>

Kiitos!

Kilpailun lopputulokset:
Sija    Nimi
1       Mikael (388 pistettä)
          hyppyjen pituudet: 95 m, 96 m, 63 m
2       Mika (387 pistettä)
          hyppyjen pituudet: 112 m, 61 m, 88 m
</pre>



  <p><strong>Huom1:</strong> Testien kannalta on oleellista että <em>käyttöliittymä</em> toimii kuten yllä kuvattu, esim. rivien alussa olevien välilyöntien määrän on oltava oikea. <strong>Rivien alussa oleva tyhjä pitää tehdä välilyönneillä</strong>, testit eivät toimi jos tyhjä on tehty tabulaattoreilla. Ohjelman tulostamat tekstit kannattaneekin copypasteta ohjelmakoodiin joko tehtävänannosta tai testien virheilmoituksista. <em>Tehtävä on neljän yksittäisen tehtäväpisteen arvoinen.</em></p>

<p><strong>Huom2:</strong> älä käytä luokkein nimissä skandeja, ne saattavat aiheuttaa ongelmia testeihin!</p>

  <p><strong>Ohjelman tulee käynnistyä kun tehtäväpohjassa oleva main-metodi suoritetaan, muistutuksena vieltä, että tehtävässä saa luoda vain yhden Scanner-olion.</strong></p>

</div>

    <p>Screencast jossa tehdään viikon 1 ja 2 ydinasioita hyödyntävä hieman isompi sovellus:</p>

<a href="http://www.youtube.com/watch?feature=player_embedded&v=LFxtwce8chM" height="300" target="_blank"><img src="img/youtube.jpg"/></a>

<!--
    <p><iframe allowfullscreen="" frameborder="0"  height="450" width="700" src="http://www.youtube.com/embed/LFxtwce8chM"></iframe></p>
-->



<div class="tyhja"></div>

<div class="viikkoraja">Viikko 3</div>

<h2>Single responsibility principle</h2>

    <p>Isompia ohjelmia suunniteltaessa pohditaan usein mille luokalle minkäkin asian toteuttaminen kuuluu. Jos kaikki ohjelmaan kuuluva toiminnallisuus asetetaan samaan luokkaan, on tuloksena väistämättä kaaos. Ohjelmistojen suunnittelun osa-alue <em>oliosuunnittelu</em> sisältää periaatteen <em>Single responsibility principle</em>, jota meidän kannattaa seurata.</p>

    <p>Single responsibility principle sanoo että jokaisella luokalla tulee olla vain yksi vastuu ja selkeä tehtävä. Jos luokalla on yksi selkeä tehtävä, on tehtävässä tapahtuvien muutosten toteuttaminen helppoa, muutos tulee tehdä vain yhteen luokkaan. <em>Jokaisella luokalla tulisi olla vain yksi syy muuttua</em>.</p>

    <p>Tutkitaan seuraavaa luokkaa <code>Tyontekija</code>, jolla on metodit palkan laskemiseen ja tuntien raportointiin.</p>

<pre class="sh_java">
public class Tyontekija {
    // oliomuuttujat

    // työntekijään liittyvät konstruktorit ja metodit

    public double laskePalkka() {
        // palkan laskemiseen liittyvä logiikka
    }

    public String raportoiTunnit() {
        // työtuntien raportointiin liittyvä logiikka
    }
}
</pre>

    <p>Vaikka yllä olevasta esimerkistä puuttuvat konkreettiset toteutukset, tulisi hälytyskellojen soida. Luokalla <code>Tyontekija</code> on ainakin kolme eri vastuualuetta. Se kuvaa sovelluksessa työntekijää, se toteuttaa palkanlaskennan tehtävää palkan laskemisesta, ja tuntiraportointijärjestelmän tehtävää työtuntien raportoinnista. Yllä oleva luokka pilkkoa kolmeen osaan: yksi osa kuvaa työntekijää, toinen osa palkanlaskentaa ja kolmas osa tuntikirjanpitoa.</p>

<pre class="sh_java">
public class Tyontekija {
    // oliomuuttujat

    // työntekijään liittyvät konstruktorit ja metodit
}
</pre>

<pre class="sh_java">
public class Palkanlaskenta {
    // oliomuuttujat

    // palkanlaskentaan liittyvät metodit

    public double laskePalkka(Person henkilo) {
        // palkan laskemiseen liittyvä logiikka
    }
}
</pre>


<pre class="sh_java">
public class Tuntikirjanpito {
    // oliomuuttujat

    // tuntikirjanpitoon liittyvät metodit

    public String luoTuntiraportti(Person henkilo) {
        // työtuntien raportointiin liittyvä logiikka
    }
}
</pre>

    <p><em>Jokainen muuttuja, jokainen koodirivi, jokainen metodi, jokainen luokka, ja jokainen ohjelma pitäisi olla vain yhtä tarkoitusta varten. Usein ohjelman "parempi" rakenne on ohjelmoijalle selkeää vasta kun ohjelma on toteutettu jo kertaalleen. Tämä on täysin hyväksyttävää: vielä tärkeämpää on se, että ohjelmaa pyritään muuttamaan aina selkeämpään suuntaan. <strong>Refaktoroi eli muokkaa ohjelmaasi aina tarpeen tullen!</strong></em></p>


<h2>Luokkien organisointi pakkauksiin</h2>

    <p>Suurempia ohjelmia suunniteltaessa ja toteutettaessa luokkamäärä kasvaa helposti suureksi. Luokkien määrän kasvaessa niiden tarjoamien toiminnallisuuksien ja metodien muistaminen vaikeutuu. Järkevä luokkien nimentä helpottaa toiminnallisuuksien muistamista. Järkevän nimennän lisäksi lähdekooditiedostot kannattaa jakaa toiminnallisuutta, käyttötarkoitusta tai jotain muuta loogista kokonaisuutta kuvaaviin pakkauksiin. Pakkaukset (<em>package</em>) ovat käytännössä hakemistoja, joihin lähdekooditiedostot organisoidaan. Windowsissa ja puhekielessä hakemistoja (engl. directory) kutsutaan usein kansioiksi. Me käytämme kuitenkin termiä hakemisto.</p>

    <p>Ohjelmointiympäristöt tarjoavat valmiit työkalut pakkausten hallintaan. Olemme tähän mennessä luoneet luokkia ja rajapintoja vain projektiin liittyvän lähdekoodipakkaukset-osion (<code>Source Packages</code>) oletuspakkaukseen (<code>default package</code>). Uuden pakkauksen voi luoda NetBeansissa projektin pakkauksiin liittyvässä <code>Source Packages</code> -osiossa oikeaa hiirennappia painamalla ja valitsemalla <code>New -&gt; Java Package...</code>. Luodun pakkauksen sisälle voidaan luoda luokkia aivan kuten oletuspakkaukseenkin (<code>default package</code>).</p>

  <p>Pakkaus, jossa luokka sijaitsee, näkyy lähdekooditiedoston alussa ennen muita komentoja olevasta lauseesta <code>package <em>pakkaus</em></code>. Esimerkiksi alla oleva luokka <code>Sovellus</code> sijaitsee pakkauksessa <code>kirjasto</code>.</p>

<pre class="sh_java">
package kirjasto;

public class Sovellus {

    public static void main(String[] args) {
        System.out.println("Hello packageworld!");
    }
}
</pre>

  <p>Pakkaukset voivat sisältää pakkauksia. Esimerkiksi pakkausmäärittelyssä <code>package kirjasto.domain</code> pakkaus <code>domain</code> on pakkauksen <code>kirjasto</code> sisällä. Asettamalla pakkauksia pakkausten sisään rakennetaan sovelluksen luokille ja rajapinnoille hierarkiaa. Esimerkiksi kaikki Javan luokat sijaitsevat pakkauksen <code>java</code> alla olevissa pakkauksissa. Pakkausnimeä <code>domain</code> käytetään usein kuvaamaan sovellusalueen käsitteisiin liittyvien luokkien säilytyspaikkaa. Esimerkiksi luokka <code>Book</code> voisi hyvin olla pakkauksen <code>kirjasto.domain</code> sisällä sillä se kuvaa kirjastosovellukseen liittyvää käsitettä.</p>

<pre class="sh_java">
package kirjasto.domain;

public class Book {
    private String name;

    public Book(String name) {
        this.name = nimi;
    }

    public String getName() {
        return this.name;
    }
}
</pre>

  <p>Pakkauksissa olevia luokkia tuodaan luokan käyttöön <code>import</code>-lauseen avulla. Esimerkiksi <code>kirjasto</code>-pakkauksessa oleva luokka <code>Sovellus</code> saisi käyttöönsä pakkauksessa <code>kirjasto.domain</code> olevan luokan määrittelyllä <code>import kirjasto.domain.Book</code>.</p>


<pre class="sh_java">
package kirjasto;

import kirjasto.domain.Book;

public class Sovellus {

    public static void main(String[] args) {
        Book kirja = new Book("pakkausten ABC!");
        System.out.println("Hello packageworld: " + kirja.getName());
    }
}
</pre>

<pre>
Hello packageworld: pakkausten ABC!
</pre>

    <p>Import-lauseet asetetaan lähdekooditiedostossa pakkausmäärittelyn jälkeen mutta ennen luokkamäärittelyä. Niitä voi olla myös useita -- esimerkiksi kun haluamme käyttää useita luokkia. Javan valmiit luokat sijaitsevat yleensä ottaen pakkauksen <code>java</code> alipakkauksissa. Luokkiemme alussa usein esiintyvät lauseet <code>import java.util.ArrayList</code> ja <code>import java.util.Scanner;</code> alkavat nyt toivottavasti vaikuttaa merkityksellisimmiltä.</p>

    <p>Jatkossa <em>kaikissa</em> tehtävissämme käytetään pakkauksia. Luodaan seuraavaksi ensimmäiset pakkaukset itse.</p>

<div class="tehtavat" id="viikko9">

<NEXTWEEK></NEXTWEEK>

  <h3>Ensimmäisiä pakkauksia</h3>

  <h4>Käyttöliittymä-rajapinta</h4>

  <p>Luo projektipohjaan pakkaus <code>mooc</code>. Rakennetaan tämän pakkauksen sisälle sovelluksen toiminta. Lisää sovellukseen pakkaus <code>ui</code> (tämän jälkeen pitäisi olla käytössä pakkaus <code>mooc.ui</code>), ja lisää sinne rajapinta <code>Kayttoliittyma</code>.</p>

  <p>Rajapinnan <code>Kayttoliittyma</code> tulee määritellä metodi <code>void paivita()</code>. </p>

 <h4>Tekstikäyttöliittymä</h4>

<p>
Luo samaan pakkaukseen luokka <code>Tekstikayttoliittyma</code>, joka toteuttaa rajapinnan <code>Kayttoliittyma</code>. Toteuta luokassa <code>Tekstikayttoliittyma</code> rajapinnan <code>Kayttoliittyma</code> vaatima metodi <code>public void paivita()</code> siten, että sen ainut tehtävä on characterStringn "<code>Päivitetään käyttöliittymää</code>"-tulostaminen <code>System.out.println</code>-metodikutsulla.</p>

  <h4>Sovelluslogiikka</h4>

  <p>Luo tämän jälkeen pakkaus <code>mooc.logiikka</code>, ja lisää sinne luokka <code>Sovelluslogiikka</code>. Sovelluslogiikan APIn tulee olla seuraavanlainen.</p>

<p>
  <ul>
    <li><code>public Sovelluslogiikka(Kayttoliittyma kayttoliittyma)</code></li>Sovelluslogiikka-luokan konstruktori. Saa parametrina Kayttoliittyma-rajapinnan toteuttavan luokan. Huom: jotta sovelluslogiikka näkisi rajapinnan, on sen "importoitava" se, eli tarvitset tiedoston alkuun rivin <code>import mooc.ui.Kayttoliittyma;</code> <br/>
    <li><code>public void suorita(int montaKertaa)</code></li> Tulostaa <code>montaKertaa</code>-muuttujan määrittelemän määrän characterStringa "Sovelluslogiikka toimii". Jokaisen "Sovelluslogiikka toimii"-tulostuksen jälkeen tulee kutsua konstruktorin parametrina saadun rajapinnan <code>Kayttoliittyma</code>-toteuttaman olion määrittelemää <code>paivita()</code>-metodia.<br/>
  </ul>
</p>

  <p>Voit testata sovelluksen toimintaa seuraavalla pääohjelmaluokalla.</p>

<pre class="sh_java">
import mooc.logiikka.Sovelluslogiikka;
import mooc.ui.Kayttoliittyma;
import mooc.ui.Tekstikayttoliittyma;

public class Main {

    public static void main(String[] args) {
        Kayttoliittyma kayttoliittyma = new Tekstikayttoliittyma();
        new Sovelluslogiikka(kayttoliittyma).suorita(3);
    }
}
</pre>

  <p>Ohjelman tulostuksen tulee olla seuraava:</p>

<pre>
Sovelluslogiikka toimii
Päivitetään käyttöliittymää
Sovelluslogiikka toimii
Päivitetään käyttöliittymää
Sovelluslogiikka toimii
Päivitetään käyttöliittymää
</pre>

</div>

    <h3>Konkreettinen hakemistorakenne</h3>

    <p>Kaikki NetBeansissa näkyvät projektit ovat tietokoneesi <em><a href="http://fi.wikipedia.org/wiki/Tiedostoj%C3%A4rjestelm%C3%A4" target="_blank">tiedostojärjestelmässä</a></em>. Jokaiselle projektille on olemassa oma hakemisto (eli kansio), jonka sisällä on projektiin liittyvät tiedostot ja hakemistot.</p>

    <p>Projektin hakemistossa <code>src</code> on ohjelmaan liittyvät lähdekoodit. Jos luokan pakkauksena on kirjasto, sijaitsee se projektin lähdekoodihakemistoon <code>src</code> sisällä olevassa hakemistossa <code>kirjasto</code>. Jos olet kiinnostunut, NetBeansissa voi käydä katsomassa projektien konkreettista rakennetta <em>Files</em>-välilehdeltä joka on normaalisti <em>Projects</em>-välilehden vieressä. Jos et näe välilehteä <em>Files</em>, saa sen näkyville valitsemalla vaihtoehdon <em>Files</em> valikosta <em>Window</em>.</p>

    <p>Sovelluskehitystä tehdään normaalisti <em>Projects</em>-välilehdeltä, jossa NetBeans on piilottanut projektiin liittyviä tiedostoja joista ohjelmoijan ei tarvitse välittää.</p>

    <h3>Näkyvyysmääreet ja pakkaukset</h3>

    <p>Olemme aiemmin tutustuneet kahteen näkyvyysmääreeseen. Näkyvyysmääreellä <code>private</code> varustetut metodit ja muuttujat ovat näkyvissä vain sen luokan sisällä joka määrittelee ne. Niitä ei voi käyttää luokan ulkopuolelta. Näkyvyysmääreellä <code>public</code> varustetut metodit ja muuttujat ovat taas kaikkien käytettävissä.</p>

<pre class="sh_java">
package kirjasto.ui;

public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        tulostaOtsikko();

        // muu toiminnallisuus
    }

    private void tulostaOtsikko() {
        System.out.println("************");
        System.out.println("* KIRJASTO *");
        System.out.println("************");
    }
}
</pre>

    <p>Yllä olevasta <code>Kayttoliittyma</code>-luokasta tehdyn olion konstruktori ja <code>kaynnista</code>-metodi on kutsuttavissa mistä tahansa ohjelmasta. Metodi <code>tulostaOtsikko</code> ja <code>lukija</code>-muuttuja on käytössä vain luokan sisällä.</p>

    <p>Pakkausnäkyvyyttä käytettäessä muuttujille tai metodeille ei aseteta mitään näkyvyyteen liittyvää etuliitettä. Muutetaan yllä olevaa esimerkkiä siten, että metodilla <code>tulostaOtsikko</code> on pakkausnäkyvyys.</p>

<pre class="sh_java">
package kirjasto.ui;

public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        tulostaOtsikko();

        // muu toiminnallisuus
    }

    void tulostaOtsikko() {
        System.out.println("************");
        System.out.println("* KIRJASTO *");
        System.out.println("************");
    }
}
</pre>

    <p>Nyt <em>saman pakkauksen sisällä</em> olevat luokat voivat käyttää metodia <code>tulostaOtsikko</code>.

<pre class="sh_java">
package kirjasto.ui;

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner lukija = new Scanner(System.in);
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(lukija);

        kayttoliittyma.tulostaOtsikko(); // onnistuu!
    }
}
</pre>

    <p>Jos luokka on eri pakkauksessa, ei metodia <code>tulostaOtsikko</code> pysty käyttämään.</p>

<pre class="sh_java">
package kirjasto;

import java.util.Scanner;
import kirjasto.ui.Kayttoliittyma;

public class Main {

    public static void main(String[] args) {
        Scanner lukija = new Scanner(System.in);
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(lukija);

        kayttoliittyma.tulostaOtsikko(); // ei onnistu!
    }
}
</pre>

<h2>Monta rajapintaa ja rajapintojen tarjoamasta joustavuudesta</h2>

    <p>Viime viikolla tutustuimme rajapintoihin. Rajapinta siis määrittelee yhden tai useamman metodin, jotka sen toteuttavan luokan on pakko toteuttaa. Rajapintoja, kuten kaikkia luokkia voi asettaa pakkauksiin. Esimerkiksi seuraava <code>Tunnistettava</code>-rajapinta sijaitsee pakkauksessa <code>sovellus.domain</code>, ja määrittelee että <code>Tunnistettava</code>-rajapinnan toteuttavien luokkien tulee toteuttaa metodi <code>public String getTunnus()</code>.</p>

<pre class="sh_java">
package sovellus.domain;

public interface Tunnistettava {
    String getTunnus();
}
</pre>

    <p>Luokka toteuttaa rajapinnan <code>implements</code>-avainsanalla. Toteutetaan luokka <code>Person</code>, joka toteuttaa rajapinnan tunnistettava. Person-luokan metodi <code>getTunnus</code> palauttaa aina henkilön henkilötunnuksen.</p>

<pre class="sh_java">
package sovellus.domain;

public class Person implements Tunnistettava {
    private String name;
    private String henkilotunnus;

    public Person(String name, String henkilotunnus) {
        this.name = nimi;
        this.henkilotunnus = henkilotunnus;
    }

    public String getName() {
        return this.name;
    }

    public String getPersontunnus() {
        return this.henkilotunnus;
    }

    @Override
    public String getTunnus() {
        return getPersontunnus();
    }

    @Override
    pulic toString(){
        return this.name + " hetu: " +this.henkilotunnus; 
    }
}
</pre>


    <p>Rajapintojen vahvuus on se, että rajapinta on myös <em>tyyppi</em>. Kaikki rajapinnan toteuttavista luokista tehdyt oliot ovat myös rajapinnan tyyppisiä. Tämä helpottaa sovellusten rakentamista huomattavasti.</p>

    <p>Tehdään luokka <code>Rekisteri</code>, josta voimme hakea henkilöitä tunnisteen perusteella. Yksittäisten henkilöiden hakemisen lisäksi <code>Rekisteri</code> tarjoaa metodin kaikkien henkilöiden hakemiseen listana.</p>

<pre class="sh_java">
public class Rekisteri {
    private HashMap&lt;String, Tunnistettava&gt; rekisteroidyt;

    public Rekisteri() {
        this.rekisteroidyt = new HashMap&lt;String, Tunnistettava&gt;();
    }

    public void lisaa(Tunnistettava lisattava) {
        this.rekisteroidyt.put(lisattava.getTunnus(), lisattava);
    }

    public Tunnistettava hae(String tunnus) {
        return this.rekisteroidyt.get(tunnus);
    }

    public List&lt;Tunnistettava&gt; haeKaikki() {
        return new ArrayList&lt;Tunnistettava&gt;(rekisteroidyt.values());
    }
}
</pre>

<p>Rekisterin käyttö on helppoa</p>

<pre class="sh_java">
Rekisteri henkilokunta = new Rekisteri();
henkilokunta.lisaa( new Person("Pekka", "221078-123X") );
henkilokunta.lisaa( new Person("Jukka", "110956-326B") );

System.out.println( rekisteri.hae("280283-111A") );

Person loydetty = (Person)rekisteri.hae("110956-326B");
System.out.println( loydetty.getName() );
</pre>

<p>Koska henkilöt on talletettu rekisteriin <code>Tunnistettava</code>-tyyppisinä, joudumme muuntanaan ne takaisin oikeaan tyyppiin jos haluamme käsitellä henkilöitä sellaisten metodien kautta, joita ei rajapinnassa ole määritelty. Näin tapahtuu yllä olevan esimerkin kahdella viimeisellä rivillä.</p>

    <p>Entä jos haluaisimme operaation, joka palauttaa rekisteriin talletetut henkilöt tunnisteen mukaan järjestettynä?</p>

    <p>Yksi luokka voi toteuttaa useamman rajapinnan, eli voimme toteuttaa <code>Person</code>-luokalla rajapinnan <code>Tunnistettava</code> lisäksi viime viikolta tutun rajapinnan <code>Comparable</code>. Useamman rajapinnan toteuttaminen tapahtuu erottamalla toteutettavat rajapinnat toisistaan pilkuilla (<code>public class ... implements <em>RajapintaEka</em>, <em>RajapintaToka</em> ...</code>). Toteuttaessamme useampaa rajapintaa, tulee meidän toteuttaa kaikki rajapintojen vaatimat metodit. Toteutetaan seuraavaksi luokalla <code>Person</code> rajapinta <code>Comparable</code>.</p>

<pre class="sh_java">
package sovellus.domain;

public class Person implements Tunnistettava, Comparable&lt;Person&gt; {
    private String name;
    private String henkilotunnus;

    public Person(String name, String henkilotunnus) {
        this.name = nimi;
        this.henkilotunnus = henkilotunnus;
    }

    public String getName() {
        return this.name;
    }

    public String getPersontunnus() {
        return this.henkilotunnus;
    }

    @Override
    public String getTunnus() {
        return getPersontunnus();
    }

    @Override
    public int compareTo(Person toinen) {
        return this.getTunniste().compareTo(toinen.getTunniste());
    }
}
</pre>

    <p>Nyt voimme lisätä rekisterille metodin haeKaikkiJarjestyksessa:</p>

<pre class="sh_java">
    public List&lt;Tunnistettava&gt; haeKaikkiJarjestyksessa() {
        ArrayList&lt;Tunnistettava&gt; kaikki = new ArrayList&lt;Tunnistettava&gt;(rekisteroidyt.values());;
        Collections.sort(kaikki);
        return kaikki;
    }
</pre>

<p>Huomaamme kuitenkin, että ratkaisumme ei toimi. Koska henkilöt on talletettu rekisteriin <code>Tunnitettava</code>-tyyppisinä, onkin Henkilön toteutettava rajapinta <code>Comparable&lt;Tunnistettava&gt;</code> jotta rekisteri osaisi järjestää henkilöt metodin <code>Collections.sort()</code> avulla. Eli muutamme henkilön toteuttamaa rajapintaa:</p>

<pre class="sh_java">
public class Person implements Tunnistettava, Comparable&lt;Tunnistettava&gt; {
    // ... 

    @Override
    public int compareTo(Tunnistettava toinen) {
        return this.getTunniste().compareTo(toinen.getTunniste());
    }
}
</pre>

<p>Nyt ratkaisu toimii!</p>

<p>Rekisteri on täysin tietämätön sinne talletettavien olioiden todellisesta tyypistä. Voimmekin käyttää luokkaa rekisteri myös muuntyyppisten olioiden kuin henkilöiden rekisteröintiin, kunhan olioiden luokka vaan toteuttaa rajapinnan <code>Tunnistettava</code>. Esim. seuraavassa käytetään rekisteriä kaupassa myytävien tuotteiden hallintaan:</p>

<pre class="sh_java">
public class Tuote implements Tunnistettava {
    private String name;
    private String viivakoodi;
    private int varastosaldo;
    private int hinta;

    public Tuote(String name, String viivakoodi) {
        this.name = nimi;
        this.viivakoodi = viivakoodi;
    }

    public String getTunniste() {
        return viivakoodi;
    }

    // ...
}

Rekisteri tuotteet = new Rekisteri();
tuotteet.lisaa( new Tuote("maito", "11111111") );
tuotteet.lisaa( new Tuote("piimä", "11111112") );
tuotteet.lisaa( new Tuote("juusto", "11111113") );

System.out.println( tuotteet.hae("99999999") );

Tuote tuote = (Tuote)tuotteet.hae("11111112");
tuote.kasvataSaldoa(100);
tuote.muutaHinta(23);
</pre>

<p>Eli olemme tehneet luokasta <code>Rekisteri</code> melko yleiskäyttöisen pitämällä sen riippumattomana konkreettisista luokista. Mikä tähänsa luokka, joka toteuttaa rajapinnan <code>Tunnistettava</code> on rekisterin kanssa käyttökelpoinen. Metodin <code>haeKaikkiJarjestyksessä</code> toimiminen tosin edellyttää luokalta myös vertailtavuuden eli Comparable&lt;Tunnistettava&gt;-rajapinnan toteuttamisen.</p>

<!--

    <p>Tehdään luokka <code>Personrekisteri</code>, josta voimme hakea henkilöitä <code>Tunnistettava</code>-rajapinnan avulla. Yksittäisten henkilöiden hakemisen lisäksi <code>Personrekisteri</code> tarjoaa metodin kaikkien henkilöiden hakemiseen listana.</p>

<pre class="sh_java">
public class Personrekisteri {
    private HashMap&lt;String, Person&gt; henkilot;

    public Personrekisteri(HashMap&lt;String, Person&gt; henkilot) {
        this.henkilot = henkilot;
    }

    public void lisaaPerson(Person henkilo) {
        this.henkilot.put(henkilo.getTunnus(), henkilo);
    }

    public void haePersonTunnuksella(Tunnistettava tunnistettava) {
        this.henkilot.get(tunnistettava.getTunnus());
    }

    public List&lt;Person&gt; getPersont() {
        return new ArrayList&lt;Person&gt;(henkilot.values());
    }
}
</pre>

    <p>Entä jos haluaisimme järjestää henkilölistan aakkosjärjestykseen?</p>


    <p>Yksi luokka voi toteuttaa useamman rajapinnan, eli voimme toteuttaa <code>Person</code>-luokalla rajapinnan <code>Tunnistettava</code> lisäksi viime viikolta tutun rajapinnan <code>Comparable</code>. Useamman rajapinnan toteuttaminen tapahtuu erottamalla toteutettavat rajapinnat toisistaan pilkuilla (<code>public class ... implements <em>RajapintaEka</em>, <em>RajapintaToka</em> ...</code>). Toteuttaessamme useampaa rajapintaa, tulee meidän toteuttaa kaikki rajapintojen vaatimat metodit. Toteutetaan seuraavaksi luokalla <code>Person</code> rajapinta <code>Comparable</code>.</p>

<pre class="sh_java">
package sovellus.domain;

public class Person implements Tunnistettava, Comparable&lt;Person&gt; {
    private String name;
    private String henkilotunnus;

    public Person(String name, String henkilotunnus) {
        this.name = nimi;
        this.henkilotunnus = henkilotunnus;
    }

    public String getName() {
        return this.name;
    }

    public String getPersontunnus() {
        return this.henkilotunnus;
    }

    @Override
    public String getTunnus() {
        return getPersontunnus();
    }

    @Override
    public int compareTo(Person toinen) {
        return this.name.compareTo(toinen.getName());
    }
}
</pre>

    <p>Nyt henkilöstörekisterin listaa-metodia voidaan laajentaa seuraavaan tapaan:</p>

<pre class="sh_java">
    public List&lt;Person&gt; getPersont() {
        ArrayList&lt;Person&gt; henkilot = new ArrayList&lt;Person&gt;(henkilot.values());
        Collections.sort(henkilot);
        return henkilot;
    }
</pre>

-->

<!--

    <h3>Kassaesimerkki</h3>

    <p>Pohditaan seuraavaksi kauppojen kassalaitteessa olevaan lukijalaitteeseen liittyvää tuotteen tunnistamistoimintoa. Oletetaan että tuotteet sisältävät niihin liittyvän viivakoodin, nimen ja hinnan. Tuotteita kuvastava <code>Tuote</code>-olio toteuttaa aiemmin määritellyn rajapinnan <code>Tunnistettava</code>.</p>

<pre class="sh_java">
package sovellus.domain;

public class Tuote implements Tunnistettava {
    private String viivakoodi;
    private String name;
    private int hinta;

    public Tuote(String viivakoodi, String name, int hinta) {
        this.viivakoodi = viivakoodi;
        this.name = nimi;
        this.hinta = hinta;
    }

    public String getName() {
        return this.name;
    }

    public int getHinta() {
        return this.hinta;
    }

    @Override
    public String getTunnus() {
        return this.viivakoodi;
    }
}
</pre>

    <p>Toteutetaan seuraavaksi <code>Lukijalaite</code>, joka osaa muuntaa tunnistettavat oliot tuotteiksi. Lukijalaitteen tulee lukea ja tunnistaa tuotteet rajapinnan <code>Tunnistettava</code>-avulla. Toteutetaan luokka <code>Lukijalaite</code> siten, että se sisältää hajautustaulun, josta tuotteet löytyvät tunnisteen perusteella. Lukijalaite on osa sovelluksen logiikkaa, joten lisätään se pakkaukseen <code>sovellus.logiikka</code>.</p>

<pre class="sh_java">
package sovellus.logiikka;

public class Lukijalaite {
    private HashMap&lt;String, Tuote&gt; tuotteet;

    public Lukijalaite(HashMap&lt;String, Tuote&gt; tuotteet) {
        this.tuotteet = tuotteet;
    }

    public Tuote tunnista(Tunnistettava tunnistettava) {
        return this.tuotteet.get(tunnistettava.getTunnus());
    }
}
</pre>

    <p>Lukijalaite-olio palauttaa <code>Tuote</code>-olion jos sen tunnus löytyy lukijalaitteen sisältämästä hajautustaulusta. Luodaan seuraavaksi kassa, joka käyttää lukijalaitetta tuotteiden lisäämiseen ostettujen tuotteiden listalle. Kassalla on metodi <code>public void osta</code>, jolle annetaan luokan <code>Tunnistettava</code>-ilmentymä parametrina. Ostaminen lisää lukijalaitteella tunnistetun tuotteen ostettujen listalle. Jos tuotetta ei tunnisteta, ei tehdä mitään. Metodi <code>tulostaOstokset</code> tulostaa ostettujen tuotteiden nimet.</p>

<pre class="sh_java">
package sovellus.domain;

public class Kassa {
    private Lukijalaite laite;
    private List&lt;Tuote&gt; tuotteet;

    public Kassa(Lukijalaite lukijalaite) {
        this.laite = lukijalaite;
        this.tuotteet = new ArrayList&lt;Tuote&gt;();
    }

    public void osta(Tunnistettava tunnistettava) {
        Tuote tunnistettu = this.laite.tunnista(tunnistettava);
        if (tunnistettu == null) {
            return;
        }

        this.tuotteet.add(tunnistettu);
    }

    public void tulostaOstokset() {
        for(Tuote tuote: this.tuotteet) {
            System.out.println(tuote.getName());
        }
    }
}
</pre>

    <p>Huomaamme tässä vaiheessa että tuotteiden lukeminen listalta, joka on tulostettu tuotteiden lisäysjärjestyksessä, on hyvin kuormittavaa asiakkaalle. Muokataan tulostusta siten, että tuotteet listataan aakkosjärjestyksessä. Lisätään <code>Tuote</code>-luokalle rajapinta <code>Comparable</code>, jonka avulla tuotteet voidaan järjestää aakkosjärjestyksessä.</p>

<pre class="sh_java">
package sovellus.domain;

public class Tuote implements Tunnistettava, Comparable&lt;Tuote&gt; {
    private String viivakoodi;
    private String name;
    private int hinta;

    public Tuote(String viivakoodi, String name, int hinta) {
        this.viivakoodi = viivakoodi;
        this.name = nimi;
        this.hinta = hinta;
    }

    public String getName() {
        return this.name;
    }

    public int getHinta() {
        return this.hinta;
    }

    @Override
    public String getTunnus() {
        return this.viivakoodi;
    }

    @Override
    public int compareTo(Tuote tuote) {
        return this.name.compareTo(tuote.getName());
    }
}
</pre>

    <p>Muokataan vielä kassaan liittyvää toiminnallisuutta siten, että tuotteet järjestetään tarvittaessa. Huomaa että tuotteita tarvitsee järjestää vain silloin kun tuotteita <em>ostetaan</em>. Ostaminen on ainut tilanne, jossa tuotteita sisältävän listan järjestys mahdollisesti muuttuu. Tällöin ostokset ovat aina järjestyksessä metodia <code>tulostaOstokset</code> kutsuttaessa.</p>

<pre class="sh_java">
package sovellus.domain;

public class Kassa {
    private Lukijalaite laite;
    private List&lt;Tuote&gt; tuotteet;

    public Kassa(Lukijalaite lukijalaite) {
        this.laite = lukijalaite;
        this.tuotteet = new ArrayList&lt;Tuote&gt;();
    }

    public void osta(Tunnistettava tunnistettava) {
        Tuote tunnistettu = this.laite.tunnista(tunnistettava);
        if (tunnistettu == null) {
            return;
        }

        this.tuotteet.add(tunnistettu);
        Collections.sort(this.tuotteet);
    }

    public void tulostaOstokset() {
        for(Tuote tuote: this.tuotteet) {
            System.out.println(tuote.getName());
        }
    }
}
</pre>

-->

<div>
<big><big><b>Muutama NetBeans-vihje</b></big></big>	

<ul>
<li> Kaikki NetBeans-vihjeet löytyvät <a href="../ohpe/netbeans.html">täältä</a> </li>
<p></p>

<li> <b>Implement all abstract methods</b>

<p>
Oletetaan että ohjelmassasi on rajapinta <code>Rajapinta</code>, ja olet tekemässä rajapinnan toteuttavaa luokkaa <code>Luokka</code>. Joudut näkemään hieman vaivaa kirjoittaessasi toteuttavaan luokkaan rajapinnan määrittelemien metodien esittelyrivit.
</p>

<p>On kuitenkin mahdollista pyytää NetBeansia täydentämään automaattisesti metodirungot toteuttavalle luokalle. Kun olet määritellyt luokan toteuttavan rajapinnan, eli kirjoittanut</p>

<pre class="sh_java">
public class Luokka implements Rajapinta {
}
</pre>

<p>NetBeans värjää luokan nimen punaisella. Mene rivin vasemmassa reunassa olevan lamppusymbolin kohdalle, klikkaa ja valitse <em>Implement all abstract methods</em> ja metodirungot ilmestyvät koodiin!</p>

</li>

<li> <b>Clean and Build</b>

<p>
Tietyissä tilanteissa NetBeans saattaa mennä sekaisin ja yrittää ajaa koodista versiota johon ei ole huomioitu kaikkia koodiin kirjoitettuja muutoksia. Yleensä huomaat tilanteen siten, että jotain "outoa" vaikuttaa tapahtuvan. Ongelman korjaa usein <em>Clean and build</em> -operaation suorittaminen. Operaatio löytyy Run-valikosta ja sen voi suorittaa myös painamalla <em>harja ja vasara</em> -symbolia. Clean and build poistaa koodista olemassa olevat käännetyt versiot ja tekee uuden käännöksen.
</p>

</li>
</ul>
</div>

<div class="tehtavat">

  <h3>Muuttaminen</h3>

  <p>Muuttokuormaa pakattaessa esineitä lisätään muuttolaatikoihin siten, että tarvittujen muuttolaatikoiden määrä on mahdollisimman pieni. Tässä tehtävässä simuloidaan esineiden pakkaamista muuttolaatikoihin. Jokaisella esineellä on tilavuus, ja muuttolaatikoilla on maksimitilavuus.</p>


  <h4>Tavara ja Esine</h4>

  <p>Muuttomiehet siirtävät tavarat myöhemmin rekka-autoon (ei toteuteta tässä), joten toteutetaan ensin kaikkia esineitä ja laatikoita kuvaava <code>Tavara</code>-rajapinta.</p>

  <p>Tavara-rajapinnan tulee määritellä metodi <code>int getTilavuus()</code>, jonka avulla tavaroita käsittelevät saavat selville kyseisen tavaran tilavuuden. Toteuta rajapinta <code>Tavara</code> pakkaukseen <code>muuttaminen.domain</code>.</p>

  <p>Toteuta seuraavaksi pakkaukseen <code>muuttaminen.domain</code> luokka <code>Esine</code>, joka saa konstruktorin parametrina esineen nimen (String) ja esineen tilavuuden (int). Luokan tulee toteuttaa rajapinta <code>Tavara</code>.</p>

  <p>Lisää luokalle <code>Esine</code> myös metodit <code>public String getName()</code> ja korvaa metodi <code>public String toString()</code> siten että se tuotta characterStringja muotoa "<code>nimi (tilavuus dm^3)</code>". Esineen pitäisi toimia nyt jotakuinkin seuraavasti</p>

<pre class="sh_java">
    Tavara esine = new Esine("hammasharja", 2);
    System.out.println(esine);
</pre>

<pre>
hammasharja (2 dm^3)
</pre>

  <h4>Esine vertailtavaksi</h4>

  <p>Pakatessamme esineitä muuttolaatikkoon haluamme aloittaa pakkaamisen järjestyksessä olevista esineistä. Toteuta <code>Esine</code>-luokalla rajapinta <code>Comparable</code> siten, että esineiden <em>luonnollinen järjestys</em> on tilavuuden mukaan nouseva. Kun olet toteuttanut esineellä rajapinnan <code>Comparable</code>, tulee niiden toimia <code>Collections</code>-luokan <code>sort</code>-metodin kanssa seuraavasti.</p>


<pre class="sh_java">
    List&lt;Esine&gt; esineet = new ArrayList&lt;Esine&gt;();
    esineet.add(new Esine("passi", 2));
    esineet.add(new Esine("hammasharja", 1));
    esineet.add(new Esine("sirkkeli", 100));

    Collections.sort(esineet);
    System.out.println(esineet);
</pre>

<pre>
[hammasharja (1 dm^3), passi (2 dm^3), sirkkeli (100 dm^3)]
</pre>

  <h4>Muuttolaatikko</h4>

  <p>Toteuta tämän jälkeen pakkaukseen <code>muuttaminen.domain</code> luokka <code>Muuttolaatikko</code>. Tee aluksi muuttolaatikolle seuraavat:</p>

<p>
  <ul>
    <li><code>public Muuttolaatikko(int maksimitilavuus)</code></li>Muuttolaatikko-luokan konstruktori. Saa parametrina muuttolaatikon maksimitilavuuden.<br/>
    <li><code>public boolean lisaaTavara(Tavara tavara)</code></li> Lisää muuttolaatikkoon <code>Tavara</code>-rajapinnan toteuttaman esineen. Jos laatikkoon ei mahdu, metodi palauttaa arvon <code>false</code>. Jos tavara mahtuu laatikkoon, metodi palauttaa arvon <code>true</code>. Muuttolaatikon tulee tallettaa tavarat listaan.<br/>
  </ul>
</p>

  <p>Laita vielä  <code>Muuttolaatikko</code> toteuttamaan rajapinta <code>Tavara</code>. Metodilla <code>getTilavuus</code> tulee saada selville muuttolaatikossa olevien tavaroiden tämänhetkinen yhteistilavuus.</p>

  <h4>Esineiden pakkaaminen</h4>

  <p>Toteuta luokka <code>Pakkaaja</code> pakkaukseen <code>muuttaminen.logiikka</code>. Luokan <code>Pakkaaja</code> konstruktorille annetaan parametrina <code>int laatikoidenTilavuus</code>, joka määrittelee minkä kokoisia muuttolaatikoita pakkaaja käyttää.</p>

  <p>Toteuta tämän jälkeen luokalle metodi <code>public List&lt;Muuttolaatikko&gt; pakkaaTavarat(List&lt;Tavara&gt; tavarat)</code>, joka pakkaa tavarat muuttolaatikoihin.</p>

  <p>Tee metodista sellainen, että kaikki parametrina annetussa listassa olevat tavarat päätyvät palautetussa listassa oleviin muuttolaatikoihin. Sinun ei tarvitse varautua tilanteisiin, joissa tavarat ovat suurempia kuin pakkaajan käyttämä muuttolaatikon koko. Testit eivät välitä siitä kuinka täyteen pakkaaja täyttää muuttolaatikot.</p>

<p>Seuraavassa pakkaajan toimintaa demonstroiva esimerkki:</p>

<pre class="sh_java">
    // tavarat jotka haluamme pakata
    List&lt;Tavara&gt; tavarat = new ArrayList&lt;Tavara&gt;();
    tavarat.add(new Esine("passi", 2));
    tavarat.add(new Esine("hammasharja", 1));
    tavarat.add(new Esine("kirja", 4));
    tavarat.add(new Esine("sirkkeli", 8));

    // luodaan pakkaaja, joka käyttää tilavuudeltaan 10:n kokoisia muuttolaatikoita
    Pakkaaja pakkaaja = new Pakkaaja(10);

    // pyydetään pakkaajaa pakkaamaan tavarat laatikoihin
    List&lt;Muuttolaatikko&gt; laatikot = pakkaaja.pakkaaTavarat( tavarat );

    System.out.println("laatikoita: "+laatikot.size());

    for (Muuttolaatikko laatikko : laatikot) {
        System.out.println("  laatikossa tavaraa: "+laatikko.getTilavuus()+" dm^3");
    }
</pre>

<p>Tulostuu:</p>

<pre>
laatikoita: 2
  laatikossa tavaraa: 7 dm^3
  laatikossa tavaraa: 8 dm^3
</pre>

<p>Pakkaaja on siis pakannut tavarat kahteen laatikkoon, ensimmäiseen laatikkoon on mennyt 3 ensimmäistä tavaraa, yhteistilavuudeltaan 7, ja listan viimeinen tavara eli sirkkeli jonka tilavuus on 8 on mennyt toiseen laatikkoon. Testit eivät aseta rajoitusta pakkaajan käyttävien muuttolaatioiden määrälle, tavarat olisi siis voitu pakata vaikka jokainen eri laatikkoon, eli tuloste olisi ollut:</p>

<p>Tulostuu:</p>

<pre>
laatikoita: 4
  laatikossa tavaraa: 2 dm^3
  laatikossa tavaraa: 1 dm^3
  laatikossa tavaraa: 7 dm^3
  laatikossa tavaraa: 8 dm^3
</pre>

<p><strong>Huom:</strong> tehtävän testaamista helpottamaan kannatanee tehdä luokalle <code>Muuttolaatikko</code> esim. toString-metodi, jonka avulla voi printata laatikon sisällön.</p>

<!--

  <h4>Tehokkaampi pakkaaminen</h4>

  <p>Alla on kuvattu eräs hieman tehokkaampi pakkaustapa <em>pseudokoodina</em>, eli ohjelmointikielen tapaisena koodina. Pseudokoodia käytetään muun muassa ohjelmointikieliriippumattomaan algoritmien eli ohjelmien kuvaamiseen.</p>

<pre>
pakkaaEsineet( esineet ):
    jarjesta( esineet )

    laatikot = [] // huom, kannattaa käyttää ArrayListiä

    while esineet is not empty:
        Muuttolaatikko pakattu = pakkaaLaatikko( esineet )
        laatikot.add( pakattu )

    return laatikot

pakkaaLaatikko( esineet ):
    Muuttolaatikko laatikko = new Muuttolaatikko

    lisaaSuuria( esineet, laatikko )
    lisaaPienia( esineet, laatikko )

    return laatikko

lisaaSuuria( esineet, laatikko ):
    while esineet is not empty:
        esine = suurin( esineet )

        if lisaa ( laatikko, esine ) == false:
            return

lisaaPienia(List esineet, Muuttolaatikko laatikko):
    while esineet is not empty:
        esine = pienin( esineet )

        if lisaa ( laatikko, esine ) == false:
            return
</pre>

  <p>Muokkaa luokkaa <code>Pakkaaja</code> siten, että se toimii samoin tai paremmin kuin yllä kuvattu lähestymistapa.</p>

  <p>Metodissa <code>pakkaaEsineet</code> pakataan muuttolaatikoita niin pitkään kun <code>esineet</code>-listalla on esineitä. Muuttolaatikkoa pakattaessa algoritmi lisää laukkuun ensiksi niin paljon suurimpia esineitä kuin laatikkoon mahtuu. Kun laatikkoon ei enää mahdu suurimpia esineitä, aletaan täyttämään sitä pienimmillä esineillä.</p>

  <p>Toteutuksesta: Kun esineesi ovat järjestyksessä, suurin tavara löytyy indeksistä <code>esinelistan koko - 1</code>, pienin tavara löytyy indeksistä <code>0</code>. Älä käytä tässä <code>Collections.min</code> ja <code>Collections.max</code>-metodeja, sillä ne eivät osaa arvata että <code>ArrayList</code>-lista on jo järjestyksessä.</p>

  <p>Poista esineitä <code>esineet</code>-listalta sitä mukaa kun niitä on lisätty muuttolaatikoihin. Sinun ei tarvitse varautua tilanteisiin joissa esineet ovat suurempia kuin muuttolaatikko.</p>

  <p><em>Huom!</em> Saadaksesi pisteen tästä viimeisestä tehtävästä algoritmisi tulee toimia <em>vähintään</em> yhtä hyvin kuin yllä kuvattu algoritmi. Hyvyydellä tarkoitetaan sitä, että pakkaukseen kulunut aika tulee olla vähintään yhtä pieni kuin pseudokoodiratkaisun. Muuttolaatikkojen määrän tulee myös olla vähintään yhtä pieni.</p>

  <p>Voit käyttää seuraavaa metodia satunnaisten esineiden luomiseen.</p>

<pre class="sh_java">
    public static List&lt;Esine&gt; luoEsineet(int kpl, int maxTilavuus) {
        Random rand = new Random();

        List&lt;Esine&gt; esineet = new ArrayList&lt;Esine&gt;();
        for (int i = 0; i &lt; kpl; i++) {
            esineet.add(new Esine("hammasharja", 1 + rand.nextInt(maxTilavuus)));
        }

        return esineet;
    }
</pre>

  <p>Yllä kuvatulla algoritmilla pakkaamisen pitäisi toimia nopeasti jopa 100000 esinettä sisältävillä listoilla. Voit testata pakkaajasi nopeutta esimerkiksi seuraavasti:</p>

<pre class="sh_java">
        List&lt;Esine&gt esineet = luoEsineet(100000, 10);
        Pakkaaja pakkaaja = new Pakkaaja(50);

        long start = System.nanoTime();
        List&lt;Muuttolaatikko&gt laatikot = pakkaaja.pakkaaEsineet(esineet);
        long kulunutAika = ((System.nanoTime() - start) / 1000000);

        System.out.println("Pakkaukseen kului " + kulunutAika + " ms.");
        System.out.println("Tarvittiin " + laatikot.size() + " laatikkoa.");
</pre>

-->
</div>

<h2>Poikkeustilanteet</h2>

    <p>Poikkeustilanteet ovat tilanteita joissa ohjelman suoritus ei ole edennyt toivotusti. Ohjelma on saattanut esimerkiksi kutsua <em>null</em>-viitteeseen liittyvää metodia, jolloin käyttäjälle <em>heitetään</em> poikkeus <code>NullPointerException</code>. Jos yritämme hakea taulukon ulkopuolella olevaa indeksiä, käyttäjälle heitetään poikkeus <code>IndexOutOfBoundsException</code>. Kaikki poikkeukset ovat tyyppiä <code>Exception</code>.</p>

    <p>Poikkeukset käsitellään <code>try { } catch (Exception e) { }</code> -lohkorakenteella. Avainsanan <code>try</code> aloittaman lohkon sisällä on <em>mahdollisesti</em> poikkeuksen heittävä ohjelmakoodi. Avainsanan <code>catch</code> aloittaman lohkon sisällä taas määritellään mitä tehdään jos try-lohkossa suoritettavassa koodissa tapahtuu poikkeus. Catch-lauseelle määritellään kiinniotettavan poikkeuksen tyyppi (<code>catch (Exception e)</code>).</p>

<pre class="sh_java">
    try {
        // poikkeuksen mahdollisesti heittävä ohjelmakoodi
    } catch (Exception e) {
        // lohko johon päädytään poikkeustilanteessa
    }
</pre>

    <p>characterStringn numeroksi muuttava <code>Integer</code>-luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Integer.html#parseInt(java.lang.String)" target="_blank">parseInt</a></code>-metodi heittää poikkeuksen <code>NumberFormatException</code> jos sille parametrina annettu characterString ei ole muunnettavissa numeroksi. Toteutetaan ohjelma, joka yrittää muuntaa käyttäjän syöttämän characterStringn numeroksi.</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    System.out.print("Syötä numero: ");

    int numero = Integer.parseInt(reader.nextLine());
</pre>

<pre>
Syötä numero: <font color="red">tatti</font>
<font color="red">Exception in thread "..." java.lang.NumberFormatException: For input string: "tatti"</font>
</pre>

    <p>Yllä oleva ohjelma heittää poikkeuksen kun käyttäjä syöttää virheellisen numeron. Ohjelman suoritus päättyy virhetilanteeseen, eikä suoritusta voi enää jatkaa. Lisätään ohjelmaan poikkeuskäsittely. Kutsu, joka saattaa heittää poikkeuksen asetetaan <code>try</code>-lohkon sisään, ja virhetilanteessa tapahtuva toiminta <code>catch</code>-lohkon sisään. </p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    System.out.print("Syötä numero: ");

    try {
        int numero = Integer.parseInt(reader.nextLine());
    } catch (Exception e) {
        System.out.println("Et syöttänyt kunnollista numeroa.");
    }
</pre>

<pre>
Syötä numero: <font color="red">5</font>
</pre>

<pre>
Syötä numero: <font color="red">enpäs!</font>
Et syöttänyt kunnollista numeroa.
</pre>

    <p>Avainsanan <code>try</code> määrittelemän lohkon sisältä siirrytään <code>catch</code>-lohkoon heti poikkeuksen tapahtuessa.  Visualisoidaan tätä lisäämällä tulostuslause <code>try</code>-lohkossa metodia <code>Integer.parseInt</code> kutsuvan rivin jälkeen.</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    System.out.print("Syötä numero: ");

    try {
        int numero = Integer.parseInt(reader.nextLine());
        System.out.println("Hienosti syötetty!");
    } catch (Exception e) {
        System.out.println("Et syöttänyt kunnollista numeroa.");
    }
</pre>


<pre>
Syötä numero: <font color="red">5</font>
Hienosti syötetty!
</pre>

<pre>
Syötä numero: <font color="red">enpäs!</font>
Et syöttänyt kunnollista numeroa.
</pre>

    <p>Ohjelmalle syötetty characterString <code>enpäs!</code> annetaan parametrina <code>Integer.parseInt</code>-metodille, joka heittää poikkeuksen jos parametrina saadun characterStringn muuntaminen luvuksi epäonnistuu. Huomaa että <code>catch</code>-lohkossa oleva koodi suoritetaan <em>vain</em> poikkeustapauksissa -- muulloin ohjelma ei pääse sinne.</p>

    <p>Tehdään luvun muuntajasta hieman hyödyllisempi: Tehdään siitä metodi, joka kysyy numeroa yhä uudestaan kunnes käyttäjä syöttää oikean numeron. Metodista pääsee pois <em>vain</em> jos käyttäjä syöttää oikean luvun.</p>

<pre class="sh_java">
public int lueLuku(Scanner lukija) {
    while (true) {
        System.out.print("Syötä numero: ");

        try {
            int numero = Integer.parseInt(reader.nextLine());
            return numero;
        } catch (Exception e) {
            System.out.println("Et syöttänyt kunnollista numeroa.");
        }
    }
}
</pre>

    <p>Metodin <code>lueLuku</code> kutsuminen voisi toimia esimerkiksi seuraavasti</p>

<pre>
Syötä numero: <font color="red">enpäs!</font>
Et syöttänyt kunnollista numeroa.
Syötä numero: <font color="red">Matilla on ovessa tatti.</font>
Et syöttänyt kunnollista numeroa.
Syötä numero: <font color="red">43</font>

</pre>


<h3>Poikkeusten heittäminen</h3>

    <p>Metodit ja konstruktorit voivat <em>heittää</em> poikkeuksia. Heitettäviä poikkeuksia on karkeasti ottaen kahdenlaisia. On poikkeuksia jotka on pakko käsitellä, ja on poikkeuksia joita ei ole pakko käsitellä. Pakosti käsiteltävät poikkeukset käsitellään joko <code>try-catch</code> -lohkossa, tai <em>heittämällä ne ulos metodista</em>. </p>

<p>
Ohjelmoinnin perusteiden tehtävän <em>kellosta olio</em> bonusversiossa kerrottiin, että ohjelma saadaan viivyttämään itseään sekunnin verran kutsumalla komentoa <code>Thread.sleep(1000)</code>. Komento saattaa heittää poikkeuksen, joka on <em>pakko</em> käsitellä. Poikkeuksen käsittely siis tapahtuu  <code>try-catch</code> -lauseella, seuraavassa esimerkissä olemme välittämättä mahdollisista poikkeustilanteista ja jätimme <code>catch</code>-lohkon tyhjäksi:</p>

<pre class="sh_java">
    try {
        // nukutaan 1000 millisekuntia
        Thread.sleep(1000);
    } catch (Exception e) {
        // ei tehdä mitään poikkeustilanteessa
    }
</pre>

    <p>Metodeissa on myös mahdollista jättää poikkeus itse käsittelemättä ja <em>siirtää vastuu</em> poikkeuksen käsittelystä metodin kutsujalle. Vastuun siirto tapahtuu heittämällä poikkeus metodista eteenpäin sanomalla <code>throws Exception</code>.</p>

<pre class="sh_java">
    public void nuku(int sekuntia) <strong>throws Exception</strong> {
        Thread.sleep(sekuntia * 1000);   // nyt try-catchia ei tarvita!
    }
</pre>

    <p>Nyt metodia <code>nuku</code>-kutsuvan metodin tulee joko käsitellä poikkeus <code>try-catch</code> -lohkossa, tai siirtää poikkeuksen käsittelyn vastuuta eteenpäin heittää poikkeus eteenpäin. Joskus poikkeuksen käsittelyä pakoillaan viimeiseen asti, ja <code>main</code>-metodikin heittää poikkeuksen käsiteltäväksi eteenpäin:</p> 
<pre class="sh_java">
public class Paaohjelma {
   public static void main(String[] args) throws Exception {
       // ...
   }
}
</pre>

<p>Tällöin poikkeus päätyy Javan virtuaalikoneelle, joka keskeyttää ohjelman suorituksen poikkeukseen johtavan virheen tapahtuessa.</p>

    <p>Osa poikkeuksista, kuten <code>Integer.parseInt</code>-metodin heittämä <code>NumberFormatException</code>, on sellaisia joihin ohjelmoijan ei ole pakko varautua. Poikkeukset, joihin käyttäjän ei tarvitse varautua ovat aina myös tyyppiä tyyppiä <code>RuntimeException</code>, palaamme siihen <em>miksi</em> muuttujilla voi olla useita eri tyyppejä tarkemmin ensi viikolla.</p>

    <p>Voimme itse heittää poikkeuksen lähdekoodista <code>throw</code>-komennolla. Esimerkiksi <code>NumberFormatException</code>-luokasta luodun poikkeuksen heittäminen tapahtuisi komennolla <code>throw new NumberFormatException()</code>.</p>

    <p>Eräs poikkeus johon käyttäjän ei ole pakko varautua on <code>IllegalArgumentException</code>. Poikkeuksella <code>IllegalArgumentException</code> kerrotaan että metodille tai konstruktorille annettujen parametrien arvot ovat <em>vääränlaiset</em>. IllegalArgumentException-poikkeusta käytetään esimerkiksi silloin kun halutaan varmistaa että parametreilla on tietyt arvot. Luodaan luokka <code>Arvosana</code>, joka saa konstruktorin parametrina kokonaislukutyyppisen arvosanan.</p>

<pre class="sh_java">
public class Arvosana {
    private int arvosana;

    public Arvosana(int arvosana) {
        this.arvosana = arvosana;
    }

    public int getArvosana() {
        return this.arvosana;
    }
}
</pre>

    <p>Haluamme seuraavaksi <em>validoida</em> Arvosana-luokan konstruktorin parametrina saadun arvon. Arvosanan tulee olla aina välillä 0-5. Jos arvosana on jotain muuta, haluamme <em>heittää poikkeuksen</em>. Lisätään <code>Arvosana</code>-luokan konstruktoriin ehtolause, joka tarkistaa onko arvosana arvovälin 0-5 ulkopuolella. Jos on, heitetään poikkeus <code>IllegalArgumentException</code> sanomalla <code>throw new IllegalArgumentException("Arvosanan tulee olla välillä 0-5");</code>.</p>

<pre class="sh_java">
public class Arvosana {
    private int arvosana;

    public Arvosana(int arvosana) {
        if (arvosana &lt; 0 || arvosana &gt; 5) {
            throw new IllegalArgumentException("Arvosanan tulee olla välillä 0-5");
        }
        this.arvosana = arvosana;
    }

    public int getArvosana() {
        return this.arvosana;
    }
}
</pre>

<pre class="sh_java">
    Arvosana arvosana = new Arvosana(3);
    System.out.println(arvosana.getArvosana());

    Arvosana virheellinenArvo = new Arvosana(22);
    // tapahtuu poikkeus, tästä ei jatketa eteenpäin
</pre>

<pre>
3
Exception in thread "..." java.lang.IllegalArgumentException: Arvosanan tulee olla välillä 0-5
</pre>


<div class="tehtavat">
  <h3>Parametrien validointi</h3>

  <p>Harjoitellaan hieman parametrien validointia <code>IllegalArgumentException</code>-poikkeuksen avulla. Tehtäväpohjassa tulee kaksi luokkaa, <code>Person</code> ja <code>Laskin</code>. Muuta luokkia seuraavasti:</p>

  <h4>Henkilön validointi</h4>

  <p>Luokan <code>Person</code> konstruktorin tulee varmistaa että parametrina annettu nimi ei ole null, tyhjä tai yli 40 merkkiä pitkä. Myös iän tulee olla väliltä 0-120. Jos joku edelläolevista ehdoista ei päde, tulee konstruktorin heittää <code>IllegalArgumentException</code>-poikkeus.</p>

  <h4>Laskimen validointi</h4>

  <p>Luokan <code>Laskin</code> metodeja tulee muuttaa seuraavasti: Metodin <code>kertoma</code> tulee toimia vain jos parametrina annetaan ei-negatiivinen luku (0 tai suurempi). Metodin <code>binomikerroin</code> tulee toimia vain jos parametrit ovat ei-negatiivisia ja osajoukon koko on pienempi kuin joukon koko. Jos jompikumpi metodeista saa epäkelpoja arvoja metodikutsujen yhteydessä, tulee metodien heittää poikkeus <code>IllegalArgumentException</code>.</p>

<h3>Sensorit ja lämpötilan mittausta</h3>

<p>Kakki sovelluksessa oleva koodi tulee sijoittaa pakkaukseen <code>sovellus</code>.</p>

<p>Käytössämme on seuraava rajapinta:</p>

<pre class="sh_java">
public interface Sensori {
    boolean onPaalla();  // palauttaa true jos sensori on päällä
    void paalle();       // käynnistä sensorin
    void poisPaalta();   // sulkee sensorin
    int mittaa();        // palauttaa sensorin lukeman jos sensori on päällä
                         // jos sensori ei päällä heittää poikkeuksen IllegalStateException
}
</pre>

<h4>Vakiosensori</h4>

<p>Tee luokka <code>Vakiosensori</code> joka toteuttaa rajapinnan <code>Sensori</code>.</p>

<p>Vakiosensori on koko ajan päällä. Metodien paalle ja poisPaalta kutsuminen ei tee mitään. Vakiosensorilla tulee olla konstruktori, jonka parametrina on kokonaisluku. Metodikutsu <code>mittaa</code> palauttaa aina konstruktorille parametrina annetun luvun.
</p>

<p>Esimerkki:</p>

<pre class="sh_java">
public static void main(String[] args) {
  Vakiosensori kymppi = new Vakiosensori(10);
  Vakiosensori miinusViis = new Vakiosensori(-5);

  System.out.println( kymppi.mittaa() );
  System.out.println( miinusViis.mittaa() );

  System.out.println( kymppi.onPaalla() );
  kymppi.poisPaalta();
  System.out.println( kymppi.onPaalla() );
}
</pre>

<p>Tulostuu:</p>

<pre>
10
-5
true
true
</pre>

<h4>Lampomittari</h4>

<p>Tee luokka <code>Lampomittari</code> joka toteuttaa rajapinnan <code>Sensori</code>.</p>

<p>
Aluksi lämpömittari on poissa päältä. Kutsuttaessa metodia <code>mittaa</code> kun mittari on päällä mittari arpoo luvun väliltä -30...30 ja palauttaa sen kutsujalle. Jos mittari ei ole päällä, heitetään poikkeus </code>IllegalStateException</code>. 
</p>

<h4>Keskiarvosensori</h4>

<p>Tee luokka <code>Keskiarvosensori</code> joka toteuttaa rajapinnan </code>Sensori</code>.</p>

<p>
Keskiarvosensori sisältää useita sensoreita. Rajapinnan <code>Sensori</code> määrittelemien metodien lisäksi keskiarvosensorilla on metodi 
<code>public void lisaaSensori(Sensori lisattava)</code> jonka avulla keskiarvosensorin hallintaan lisätään uusi sensori.
</p>

<p>
Keskiarvosensori on päällä silloin kuin <em>kaikki</em> sen sisältävät sensorit ovat päällä. Kun keskiarvosensori käynnistetään, täytyy kaikkien sen sisältävien sensorien käynnistyä jos ne eivät ole käynnissä. Kun keskiarvosensori suljetaan, täytyy ainakin yhden sen sisältävän sensorin mennä pois päältä. Saa myös käydä niin että kaikki sen sisältävät sensorit menevät pois päältä.
</p>

<p>
Keskiarvosensorin metodi <code>mittaa</code> palauttaa sen sisältämien sensoreiden lukemien keskiarvon (koska paluuarvo on <code>int</code>, pyöristyy lukema alaspäin kuten kokonaisluvuilla tehdyissä jakolaskuissa). Jos keskiarvosensorin metodia <code>mittaa</code> kutsutaan sensorin ollessa poissa päältä, tai jos keskiarvosensorille ei vielä ole lisätty yhtään sensoria heitetään poikkeus <code>IllegalStateException</code>.
</p>

<p>Seuraavassa sensoreja käyttävä esimerkkiohjelma (huomaa, että sekä Lämpömittarin että Keskiarvosensorin konstruktorit ovat parametrittomia):</p>

<pre class="sh_java">
public static void main(String[] args) {
    Sensori kumpula = new Lampomittari();         
    kumpula.paalle();
    System.out.println("lämpötila Kumpulassa "+kumpula.mittaa() + " astetta");
    
    Sensori kaisaniemi = new Lampomittari();        
    Sensori helsinkiVantaa = new Lampomittari();
        
    Keskiarvosensori paakaupunki = new Keskiarvosensori();
    paakaupunki.lisaaSensori(kumpula);
    paakaupunki.lisaaSensori(kaisaniemi);
    paakaupunki.lisaaSensori(helsinkiVantaa);
        
    paakaupunki.paalle();
    System.out.println("lämpötila Pääkaupunkiseudulla "+paakaupunki.mittaa() + " astetta");     
}
</pre>

<p>tulostuu (tulostetut lukuarvot riippuvat tietenkin arvotuista lämpötiloista):</p>

<pre class="sh_java">
lämpötila Kumpulassa -7 astetta
lämpötila Pääkaupunkiseudulla -10 astetta
</pre>

<p><b>Huom:</b> kannatata käyttää Vakiosensori-oliota keskiarvosensorin testaamiseen!</p>

<h4>Kaikki mittaukset</h4>

<p>Lisää luokalle Keskiarvosensori metodi <code>public List&lt;Integer&gt; mittaukset()</code>, joka palauttaa listana kaikkien keskiarvosensorin avulla suoritettujen mittausten tulokset. Seuraavassa esimerkki metodin toiminnasta: </p>

<pre class="sh_java">
public static void main(String[] args) {
    Sensori kumpula = new Lampomittari();         
    Sensori kaisaniemi = new Lampomittari();        
    Sensori helsinkiVantaa = new Lampomittari();
        
    Keskiarvosensori paakaupunki = new Keskiarvosensori();
    paakaupunki.lisaaSensori(kumpula);
    paakaupunki.lisaaSensori(kaisaniemi);
    paakaupunki.lisaaSensori(helsinkiVantaa);
        
    paakaupunki.paalle();
    System.out.println("lämpötila Pääkaupunkiseudulla "+paakaupunki.mittaa() + " astetta");     
    System.out.println("lämpötila Pääkaupunkiseudulla "+paakaupunki.mittaa() + " astetta");    
    System.out.println("lämpötila Pääkaupunkiseudulla "+paakaupunki.mittaa() + " astetta");    

    System.out.println("mittaukset: "+paakaupunki.mittaukset());
}
</pre>

<p>tulostuu (tulostetut lukuarvot riippuvat jälleen arvotuista lämpötiloista):</p>

<pre class="sh_java">
lämpötila Pääkaupunkiseudulla -10 astetta
lämpötila Pääkaupunkiseudulla -4 astetta
lämpötila Pääkaupunkiseudulla 5 astetta

mittaukset: [-10, -4, 5]
</pre>

</div>




<h3>Poikkeukset ja rajapinnat</h3>

    <p>Rajapintaluokilla ei ole metodirunkoa, mutta metodimäärittely on vapaasti rajapinnan suunnittelijan toteutettavissa. Rajapintaluokat voivat määritellä myös poikkeusten heiton. Esimerkiksi seuraavan rajapinnan <code>Tiedostopalvelin</code> toteuttavat luokat heittävät <em>mahdollisesti</em> poikkeuksen <code>lataa</code>- ja <code>tallenna</code>-metodissa.</p>

<pre class="sh_java">
public interface Tiedostopalvelin {
    String lataa(String tiedosto) throws Exception;
    void tallenna(String tiedosto, String characterString) throws Exception;
}
</pre>

    <p>Jos rajapinta määrittelee metodeille <code>throws Exception</code>-määreet, eli että metodit heittävät mahdollisesti poikkeuksen, tulee samat määreet olla myös rajapinnan toteuttavassa luokassa. Luokan ei kuitenkaan ole pakko heittää poikkeusta kuten alla olevasta esimerkistä näkee.</p>

<pre class="sh_java">
public class Tekstipalvelin implements Tiedostopalvelin {

    private Map&lt;String, String&gt; data;

    public Tekstipalvelin() {
        this.data = new HashMap&lt;String, String&gt;();
    }

    @Override
    public String lataa(String tiedosto) throws Exception {
        return this.data.get(tiedosto);
    }

    @Override
    public void tallenna(String tiedosto, String characterString) throws Exception {
        this.data.put(tiedosto, characterString);
    }
}
</pre>

<h3>Poikkeuksen tiedot</h3>

    <p>Poikkeusten käsittelytoiminnallisuuden sisältämä <code>catch</code>-lohko määrittelee catch-osion sisällä poikkeuksen johon varaudutaan <code>catch (<em>Exception e</em>)</code>. Poikkeuksen tiedot tallennetaan <code>e</code>-muuttujaan.</p>

<pre class="sh_java">
    try {
        // ohjelmakoodi, joka saattaa heittää poikkeuksen
    } catch (Exception e) {
        // poikkeuksen tiedot ovat tallessa muuttujassa e
    }
</pre>

    <p>Luokka <code>Exception</code> tarjoaa hyödyllisiä metodeja. Esimerkiksi metodi <code>printStackTrace()</code> tulostaa <em>polun</em>, joka kertoo mistä päädyttiin poikkeukseen. Tutkitaan seuraavaa metodin <code>printStackTrace()</code> tulostamaa virhettä.</p>

<pre>
Exception in thread "main" java.lang.NullPointerException
  at pakkaus.Luokka.tulosta(Luokka.java:43)
  at pakkaus.Luokka.main(Luokka.java:29)
</pre>

    <p>Poikkeuspolun lukeminen tapahtuu alhaalta ylöspäin. Alimpana on ensimmäinen kutsu, eli ohjelman suoritus on alkanut luokan <code>Luokka</code> metodista <code>main()</code>. Luokan <code>Luokka</code> main-metodin rivillä 29 on kutsuttu metodia <code>tulosta()</code>. Metodin <code>tulosta</code> rivillä 43 on tapahtunut poikkeus <code>NullPointerException</code>. Poikkeuksen tiedot ovatkin hyvin hyödyllisiä virhekohdan selvittämisessä.</p>


<h2>Tiedoston lukeminen</h2>

    <p>Huomattava osa ohjelmista käsittelee jollain tavalla tallennettua tietoa. Otetaan ensiaskeleet tiedostojen käsittelyyn Javassa. Javan API tarjoaa luokan <a href="http://docs.oracle.com/javase/6/docs/api/java/io/File.html" target="_blank">File</a>, jonka sisältö voidaan lukea kurssilla jo tutuksi tulleen <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html" target="_blank">Scanner</a>-luokan avulla.</p>

    <p>Luokan <code>File</code> <a href="http://docs.oracle.com/javase/6/docs/api/java/io/File.html" target="_blank">API-kuvausta</a> lukiessamme huomaamme <code>File</code>-luokalla on konstruktori <code>File(String pathname)</code> (<em>Creates a new File instance by converting the given pathname string into an abstract pathname</em>). Voimme siis antaa avattavan tiedoston polun <code>File</code>-luokan konstruktorille.</p>

    <p><em>NetBeans-ohjelmointiympäristössä tiedostoille on oma välilehti nimeltä <em>Files</em>. Files-välilehdellä on määritelty kaikki projektiin liittyvät tiedostot. Jos projektin <em>juureen</em>, eli ei yhdenkään hakemiston sisälle, lisätään tiedosto, voidaan siihen viitata projektin sisältä suoraan tiedoston nimellä. Tiedosto-olion luominen tapahtuu antamalla sille parametrina polku tiedostoon, esimerkiksi seuraavasti</em></p>

<pre class="sh_java">
    File tiedosto = new File("tiedoston-nimi.txt");
</pre>

    <p>Scanner-luokan konstruktorille voi antaa myös muita lukemislähteitä kuin <code>System.in</code>-syöttövirran. Lukemislähteenä voi olla näppäimistön lisäksi muun muassa tiedosto. Scanner tarjoaa tiedoston lukemiseen samat metodit kuin näppäimistöltä syötetyn syötteen lukemiseen. Seuraavassa esimerkissä avataan tiedosto ja tulostetaan kaikki tiedoston sisältämän tekstit <code>System.out.println</code>-komennolla Lopuksi tiedosto suljetaa komennolla <code>close</code>.</p>

<pre class="sh_java">
        // tiedosto mistä luetaan
        File tiedosto = new File("tiedosto.txt");

        Scanner lukija = new Scanner(tiedosto);
        while (reader.hasNextLine()) {
            String rivi = reader.nextLine();
            System.out.println(rivi);
        }

        reader.close();
</pre>

    <p>Scanner-luokan konstruktori <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html#Scanner(java.io.File)" target="_blank">public Scanner(File source)</a></code> (<em>Constructs a new Scanner that produces values scanned from the specified file.</em>) heittää <code><a href="http://docs.oracle.com/javase/6/docs/api/java/io/FileNotFoundException.html" target="_blank">FileNotFoundException</a></code>-poikkeuksen jos luettavaa tiedostoa ei löydy. Poikkeus <code>FileNotFoundException</code> ei ole tyyppiä <code>RuntimeException</code>, joten se tulee joko käsitellä tai heittää eteenpäin. Tässä vaiheessa riittää tietää että ohjelmointiympäristö kertoo jos sinun tulee käsitellä poikkeus erikseen. Luodaan ensin vaihtoehto, jossa poikkeus käsitellään tiedostoa avattaessa.</p>

<pre class="sh_java">
    public void lueTiedosto(File tiedosto) {
        // tiedosto mistä luetaan
        Scanner lukija = null;

        try {
            lukija = new Scanner(tiedosto);
        } catch (Exception e) {
            System.out.println("Tiedoston lukeminen epäonnistui. Virhe: " + e.getMessage());
            return; // poistutaan metodista
        }

        while (reader.hasNextLine()) {
            String rivi = reader.nextLine();
            System.out.println(rivi);
        }

        reader.close();
    }
</pre>

    <p>Toinen vaihtoehto poikkeuksen käsittelyyn on poikkeuksen käsittelyvastuun siirtäminen metodin kutsujalle. Poikkeuksen käsittelyvastuu siirretään metodin kutsujalle lisäämällä metodiin määre <code>throws <em>PoikkeuksenTyyppi</em></code>, eli esimerkiksi <code>throws Exception</code> sillä kaikki poikkeukset ovat tyyppiä <code>Exception</code>. Kun metodilla on määre <code>throws Exception</code>, tietävät kaikki sitä kutsuvat että se saattaa heittää poikkeuksen johon tulee varautua.</p>

<pre class="sh_java">
    public void lueTiedosto(File tiedosto) throws Exception {
        // tiedosto mistä luetaan
        Scanner lukija = new Scanner(tiedosto);

        while (reader.hasNextLine()) {
            String rivi = reader.nextLine();
            System.out.println(rivi);
        }

        reader.close();
    }
</pre>

    <p>Esimerkki avaa tiedoston <code>tiedosto.txt</code> projektin juuripolusta ja tulostaa sen rivi riviltä käyttäjälle näkyville. Lopuksi lukija suljetaan, jolloin tiedosto myös suljetaan. Määre <code>throws Exception</code> kertoo että metodi saattaa heittää poikkeuksen. Samanlaisen määreen voi laittaa kaikkiin metodeihin jotka käsittelevät tiedostoja.</p>

    <p>Huomaa että <code>Scanner</code>-olio ei liitä rivinvaihtomerkkejä osaksi <code>nextLine</code>-metodin palauttamaa characterStringa. Yksi vaihtoehto tiedoston lukemiseen siten, että rivinvaihdot säilyvät, on lisätä jokaisen rivin jälkeen rivinvaihtomerkki:</p>

<pre class="sh_java">
    public String lueTiedostocharacterStringon(File tiedosto) throws Exception {
        // tiedosto mistä luetaan
        Scanner lukija = new Scanner(tiedosto);

        String characterString = "";

        while (reader.hasNextLine()) {
            String rivi = reader.nextLine();
            characterString += rivi;
            characterString += "\n";
        }

        reader.close();
        return characterString;
    }
</pre>

    <p>Koska käytämme tiedoston lukemiseen <code>Scanner</code>-luokkaa, käytössämme on kaikki Scanner-luokan tarjoamat metodit. Esimerkiksi metodi <code>hasNext()</code> palauttaa totuusarvon <code>true</code>, jos luettavassa tiedostossa on vielä luettavaa jäljellä, ja metodi <code>next()</code> lukee seuraavan sanan metodin palauttamaan <code>String</code>-olioon. </p>

    <p>Seuraava ohjelma luo <code>Scanner</code>-olion, joka avaa tiedoston <code>tiedosto.txt</code>. Sen jälkeen se tulostaa joka viidennen sanan tiedostosta.</p>

<pre class="sh_java">
        File tiedosto = new File("tiedosto.txt");
        Scanner lukija = new Scanner(tiedosto);

        int monesko = 0;
        while (reader.hasNext()) {
            monesko++;
            String sana = reader.next();

            if (monesko % 5 == 0) {
                System.out.println(sana);
            }
        }
</pre>

    <p>Alla on ensin luetun tiedoston sisältämä teksti ja sitten ohjelman tulostus</p>

<pre>
Poikkeukset (exceptions) ovat &quot;poikkeuksellisia tilanteita&quot; kesken normaalin ohjelmansuorituksen:
tiedosto loppuu, characterString ei kelpaa kokonaisluvuksi, odotetun olion tilalla onkin null-arvo,
taulukon indeksi menee ohjelmointivirheen takia sopimattomaksi, ...
</pre>

<pre>
tilanteita&quot;
loppuu,
odotetun
taulukon
sopimattomaksi,
</pre>

<h3>Merkistöongelmista</h3>

    <p>Tekstiä tiedostosta luettaessa (tai tiedostoon tallennettaessa) Java joutuu päättelemään käyttöjärjestelmän käyttämän merkistön. Merkistön tuntemusta tarvitaan sekä tekstin tallentamiseen tietokoneen kovalevylle binäärimuotoiseksi että binäärimuotoisen datan tekstiksi kääntämiseksi.</p>

    <p>Merkistöihin on kehitetty standardeja, joista "UTF-8" on nykyään yleisin. UTF-8 -merkistö sisältää sekä jokapäiväisessä käytössä olevien aakkosten että erikoisempien merkkien kuten Japanin kanji-merkistön tai shakkipelin nappuloiden tallentamiseen ja lukemiseen tarvittavat tiedot. Ohjelmointimielessä merkistöä voi hieman yksinkertaistaen ajatella hajautustauluna merkistä numeroon ja numerosta merkkiin. Merkistä numeroon oleva hajautustaulu kuvaa minkälaisena binäärilukuna kukin merkki tallennetaan tiedostoon. Numerosta merkkiin oleva hajautustaulu taas kuvaa miten tiedostoa luettaessa saadut values muunnetaan merkeiksi.</p>

    <p>Lähes jokaisella käyttöjärjestelmävalmistajalla on myös omat standardinsa. Osa tukee ja haluaa osallistua avoimien standardien käyttöön, osa ei. Mikäli sinulla on ongelmia ääkkösellisten sanojen kanssa (eritoten mac ja windows käyttäjät) voit kertoa <code>Scanner</code>-oliota luodessa käytettävän merkistön. Tällä kurssilla käytämme aina merkistöä "UTF-8".</p>

    <p>UTF-8 -merkistöä käyttävän tiedostoa lukevan Scanner-olion voi luoda seuraavasti:</p>

<pre class="sh_java">
    File tiedosto = new File("esimerkkitiedosto.txt");
    Scanner lukija = new Scanner(tiedosto, "UTF-8");
</pre>

    <p>Toinen vaihtoehto merkistön asettamiseksi on ympäristömuuttujan käyttäminen. Macintosh ja Windows-käyttäjät voivat asettaa ympäristömuuttujan <code>JAVA_TOOL_OPTIONS</code> arvoksi characterStringn <code>-Dfile.encoding=UTF8</code>. Tällöin Java käyttää oletuksena aina UTF-8-merkistöä.</p>

<div class="tehtavat">
  <h3>Rivit joilla sana</h3>

<p>Tee luokka <code>Tulostaja</code> ja sille konstruktori <code>public Tulostaja(String tiedostonNimi)</code>, joka saa parametrinaan tiedoston nimeä vastaavan characterStringn sekä metodi <code>public void tulostaRivitJoilla(String sana)</code> tulostaa tiedostosta ne rivit, joilla esiintyy parametrina oleva sana (<em>pienet ja isot kirjaimet erotellaan tehtävässä, eli esim. "koe" ja "Koe" eivät ole sama sana</em>), rivit tulostetaan samassa järjestyksessä missä ne ovat tiedostossa. </p>

<p>Jos parametri on tyhjä characterString, tulostuu koko tiedosto.</p> 

<p>Jos tiedostoa ei ole olemassa, heittää konstruktori aiheutuvan poikkeuksen eteenpäin, eli try-catch-komentoa ei tarvita, riittää määritellä konstruktori seuraavasti:</p>

<pre class="sh_java">
public Tulostaja {

   public Tulostaja(String tiedostonNimi) throws Exception {
      // ...
   }

   // ...
}
</pre>

<p>Projektisi default-pakkauksessa on testausta varten tiedosto <em>testitiedosto.txt</em>. Ohjelmasta avatessa tiedoston nimeksi tulee antaa <code>src/testitiedosto.txt</code>. Tiedoston sisältö on seuraava:</p> 

<pre>
Siinä vanha Väinämöinen
katseleikse käänteleikse 
Niin tuli kevätkäkönen
näki koivun kasvavaksi 
Miksipä on tuo jätetty
koivahainen kaatamatta  
Sanoi vanha Väinämöinen 
</pre>

<p>Seuraavassa esimerkki ohjelman toiminnasta testitiedostolla:</p>

<pre class="sh_java">
    Tulostaja tulostaja = new Tulostaja("src/testitiedosto.txt");

    tulostaja.tulostaRivitJoilla("Väinämöinen");
    System.out.println("-----");
    tulostaja.tulostaRivitJoilla("Frank Zappa");
    System.out.println("-----");
    tulostaja.tulostaRivitJoilla("");
    System.out.println("-----");
</pre>

<p>Tulostuu:</p>

<pre>
Siinä vanha Väinämöinen
Sanoi vanha Väinämöinen 
-----
-----
Siinä vanha Väinämöinen
katseleikse käänteleikse 
Niin tuli kevätkäkönen
näki koivun kasvavaksi 
Miksipä on tuo jätetty
koivahainen kaatamatta  
Sanoi vanha Väinämöinen 
</pre>

<p>Projektipohjasta löytyy myös koko Kalevala, tiedoston nimi on <code>src/kalevala.txt</code></p>


  <h3>Tiedoston analyysi</h3>

  <p>Tässä tehtävässä tehdään sovellus tiedoston rivi- ja merkkimäärän laskemiseen.</p>

  <h4>Rivien laskeminen</h4>


  <p>Tee pakkaukseen <code>tiedosto</code> luokka <code>Analyysi</code>, jolla on konstruktori <code>public Analyysi(File tiedosto)</code>. Toteuta luokalle metodi <code>public int rivimaara()</code>, joka palauttaa konstruktorille annetun tiedoston rivimäärän.</p>

<p>Metodi ei saa olla "kertakäyttöinen", eli sen pitää tuottaa oikea tulos myös usealla peräkkäisellä kutsulla. Huomaa, että kun teet tiedostoa vastaavan Scanner-olion, ja luet tiedoston koko sisällön <code>nextLine</code>-komennoilla, et voi käyttää enää <em>samaa</em> skanneria tiedoston uudelleenlukemiseen!</p>

<p><strong>Huom:</strong> jos testit sanovat <em>timeout</em>, et todennäköisesti muista lukea tiedostoa ollenkaan, eli <code>nextLine</code>-kutsut puuttuvat!</p>

  <h4>Merkkien laskeminen</h4>

  <p>Toteuta luokkaan <code>Analyysi</code> metodi <code>public int merkkeja()</code>, joka palauttaa luokan konstruktorille annetun tiedoston merkkien määrän.</p>

<p>Metodi ei saa olla "kertakäyttöinen", eli sen pitää tuottaa oikea tulos myös usealla peräkkäisellä kutsulla.</p>

  <p>Voit itse päättää miten reagoidaan jos konstruktorin parametrina saatua tiedostoa ei ole olemassa.</p>

<p>Projektisi testipakkauksessa on testausta varten tiedosto <em>testitiedosto.txt</em>. Ohjelmasta avatessa tiedoston nimeksi tulee antaa <code>test/testitiedosto.txt</code>. Tiedoston sisältö on seuraava:</p> 

<pre>
rivejä tässä on 3 ja merkkejä 
koska rivinvaihdotkin ovat
merkkejä
</pre>

<p>Ohjelman toiminta testaustiedostolla:</p>

<pre class="sh_java">
    File tiedosto = new File("src/testitiedosto.txt");
    Analyysi analyysi = new Analyysi(tiedosto);
    System.out.println("Rivejä: " + analyysi.rivimaara());
    System.out.println("Merkkejä: " + analyysi.merkkeja());
</pre>

<pre>
Rivejä: 3
Merkkejä: 67
</pre>

  <h3>Sanatutkimus</h3>

  <p>Tee luokka Sanatutkimus, jolla voi tehdä erilaisia tutkimuksia tiedoston sisältämille sanoille. Toteuta luokka pakkaukseen <code>sanatutkimus</code>.</p>

  <p>Kotimaisten kielten tutkimuskeskus (Kotus) on julkaissut netissä suomen kielen sanalistan. Tässä tehtävässä käytetään listan muokattua versiota, joka löytyy tehtäväpohjasta <code>src</code>-hakemistosta nimellä <code>sanalista.txt</code>, eli suhteellisesta polusta <code>"src/sanalista.txt"</code>.
Koska sanalista on varsin pitkä, on projektissa testausta varten myös <code>pienilista.txt</code> joka löytyy polusta <code>"src/pienilista.txt"</code>.
</p>

  <p><strong>Mikäli sinulla on ongelmia ääkkösellisten sanojen kanssa</strong> (mac ja windows käyttäjät) luo <code>Scanner</code>-olio antaen sille parametrina merkistö "UTF-8" seuraavasti: <code> Scanner lukija = new Scanner(tiedosto, "UTF-8");</code> Ongelmat liittyvät erityisesti testien suoritukseen.</p>

  <h4 class="req">Sanojen määrä</h4>

  <p>Luo Sanatutkimus-luokalle konstruktori <code>public Sanatutkimus(File tiedosto)</code> joka luo uuden Sanatutkimus-olion, joka tutkii parametrina annettavaa tiedostoa.</p>

  <p>Tee luokkaan metodi <code>public int sanojenMaara()</code>, joka lukee tiedostossa olevat sanat ja tulostaa niiden määrän. Tässä vaiheessa sanoilla ei tarvitse tehdä mitään, riittää laskea niiden määrä. Voit olettaa tässä tehtävässä, että tiedostossa on vain yksi sana riviä kohti.</p>


  <h4 class="req">z-kirjain</h4>

  <p>Tee luokkaan metodi <code>public List&lt;String&gt; kirjaimenZSisaltavatSanat()</code>, joka palauttaa tiedoston kaikki sanat, joissa on z-kirjain. Tällaisia sanoja ovat esimerkiksi jazz ja zombi.</p>

  <h4 class="req">l-pääte</h4>

  <p>Tee luokkaan metodi <code>public List&lt;String&gt; kirjaimeenLPaattyvatSanat()</code>, joka palauttaa tiedoston kaikki sanat, jotka päättyvät l-kirjaimeen. Tällaisia sanoja ovat esimerkiksi kannel ja sammal.</p>

  <p><em>Huom! Jos luet tiedoston uudestaan ja uudestaan jokaisessa metodissa huomaat viimeistään tässä vaiheessa copy-paste koodia. Kannattaa miettiä olisiko tiedoston lukeminen helpompi tehdä osana konstruktoria tai metodina, jota konstruktori kutsuu. Metodeissa voitaisiin käyttää tällöin jo luettua listaa ja luoda siitä aina uusi, hakuehtoihin sopiva lista. Viikolle 6 on tulossa oikeaoppinen tapa copypasten eliminointiin.</em></p>

  <h4>Palindromit</h4>

  <p>Tee luokkaan metodi <code>public List&lt;String&gt; palindromit()</code>, joka palauttaa tiedoston kaikki sanat, jotka ovat palindromeja. Tällaisia sanoja ovat esimerkiksi ala ja enne.</p>

  <h4 class="req">Kaikki vokaalit</h4>

  <p>Tee luokkaan metodi <code>public List&lt;String&gt; kaikkiVokaalitSisaltavatSanat()</code>, joka palauttaa tiedoston kaikki sanat, jotka sisältävät kaikki suomen kielen vokaalit (aeiouyäö). Tällaisia sanoja ovat esimerkiksi myöhäiselokuva ja ympäristönsuojelija.</p>
</div>







<h2>Hajautustauluista ja joukoista</h2>

<h3>Monta arvoa yhtä avainta kohti</h3>

<p>Kuten muistamme, voi HashMapiin tallettaa tiettyä avainta kohti vaan yhden arvon. Seuraavassa esimerkissä tallennamme henkilöiden puhelinnumeroita HashMap:iin.</p>

<pre class="sh_java">
  Map&lt;String, String&gt; puhelinnumerot = new HashMap&lt;String, String&gt;();

  puhelinnumerot.put("Pekka", "040-12348765");

  System.out.println( "Pekan numero: "+ puhelinnumerot.get("Pekka") );

  puhelinnumerot.put("Pekka", "09-111333");

  System.out.println( "Pekan numero: "+ puhelinnumerot.get("Pekka") );
</pre>

<p>Kuten odotettua, tulostus kertoo, että</p>

<pre>
Pekan numero: 040-12348765
Pekan numero: 09-111333
</pre>

<p>Entä jos haluaisimmekin tallettaa yhtä avainta kohti useita arvoja, eli esim yhtä henkilöä kohti monta puhelinnumeroa? Onnistuuko se HashMap:in avulla? Kyllä, esim. tallettamalla HashMap:iin Stringien sijaan esim. ArrayList:eja arvoiksi, voidaan yhteen avaimeen "liittää" useampia oliota. Muutetaan puhelinnumeroiden talletustapaa seuraavasti:</p>

<pre class="sh_java">
  Map&lt;String, ArrayList&lt;String&gt;&gt; puhelinnumerot = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();
</pre>

<p>Nyt siis HashMapissa jokaiseen avaimeen littyy lista. Vaikka new-komento luokin HashMapin, on mapin sisälle talletettavat listatu luotava erikseen. Seuraavassa lisätään HashMapiin Pekalle kaksi numeroa ja tulostataan ne:</p>

<pre class="sh_java">
  Map&lt;String, ArrayList&lt;String&gt;&gt; puhelinnumerot = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();

  // liitetään Pekka-nimeen ensin tyhjä ArrayList
  puhelinnumerot.put( "Pekka", new  ArrayList&lt;String&gt;() );
  
  // ja lisätään Pekkaa vastaavalle listalle puhelinnumero
  puhelinnumerot.get("Pekka").add("040-12348765");
 
  // ja lisätään toinenkin puhelinnumero
  puhelinnumerot.get("Pekka").add("09-111333");

  System.out.println( "Pekan numerot: "+ puhelinnumerot.get("Pekka") );
</pre>

<p>Tulostuu</p>

<pre>
Pekan numero: [040-12348765, 09-111333]
</pre>

<p>Määrittelimme muuttujan puhelinnumero tyypiksi <code>Map&lt;String, ArrayList&lt;String&gt;&gt;</code> eli Map jonka avaimena on characterString ja arvona characterStringja sisältävä lista. Konkreettinen toteutus, eli luotu olio oli HasMap. Olisimme voineet määritellä muuttujan myös seuraavasti:
</p>

<pre class="sh_java">
Map&lt;String, List&lt;String&gt;&gt; puhelinnumero = new HashMap&lt;String, List&lt;String&gt;&gt;();
</pre>

<p>
Eli nyt muuttujan tyyppi on Map, jonka avaimena on characterString ja arvona characterStringja sisältävä <code>List</code>, joka siis on rajapinta joka määrittelee listatoiminnallisuuden, esim. ArrayList toteuttaa tämän rajapinnan. Konkreettinen olio on HashMap.
</p>

<p>HashMap:iin talletettavat arvot siis ovat <code>List&lt;String&gt;</code>-rajapinnan toteuttavia konkreettisia olioita, esim. ArrayListeja. Eli lisäys HashMapiin tapahtuu edelleen seuraavasti:</p>

<pre class="sh_java">
  // liitetään Pekka-nimeen ensin tyhjä ArrayList
  puhelinnumerot.put( "Pekka", new  ArrayList&lt;String&gt;() );

  // ...
</pre>

<p>Jatkossa pyrkimyksemme on käyttää tyyppimäärittelyissä konkreettisten luokkien, esim. <code>HashMap</code> ja <code>ArrayList</code> sijaan niitä vastaavia rajapintoja <code>Map</code> ja <code>List</code>.</p>

<h3>Joukoista</h3>

    <p>Rajapinta <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a></code> kuvaa joukon toiminnallisuutta. Toisin kuin listalla, on joukossa kutakin alkioita korkeintaan yksi kappale, eli yhtän samanlaista oliota ei ole kahdesti. Olioiden samankaltaisuuden tarkistaminen toteutetaan <code>equals</code> ja <code>hashCode</code> -metodeja käyttämällä. </p>

<p>Yksi rajapinnan <code>Set</code> toteuttava luokka on  <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html" target="_blank">HashSet</a></code>. Toteutetaan sen avulla luokka <code>Tehtavakirjanpito</code>, joka tarjoaa mahdollisuuden tehtävien kirjanpitoon ja tehtyjen tehtävien tulostamiseen. Oletetaan että tehtävät ovat aina kokonaislukuja.</p>

<pre class="sh_java">
public class Tehtavakirjanpito {
    private Set&lt;Integer&gt; tehdytTehtavat;

    public Tehtavakirjanpito() {
        this.tehdytTehtavat = new HashSet&lt;Integer&gt;();
    }

    public void lisaa(int tehtava) {
        this.tehdytTehtavat.add(tehtava);
    }

    public void tulosta() {
        for (int tehtava: this.tehdytTehtavat) {
            System.out.println(tehtava);
        }
    }
}
</pre>

<pre class="sh_java">
        Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
        kirjanpito.lisaa(1);
        kirjanpito.lisaa(1);
        kirjanpito.lisaa(2);
        kirjanpito.lisaa(3);

        kirjanpito.tulosta();
</pre>

<pre>
1
2
3
</pre>

    <p>Yllä oleva ratkaisu toimii tilanteessa, jossa emme tarvitse tietoa käyttäjistä eri käyttäjien tekemistä tehtävistä. Muutetaan tehtävien tallennuslogiikkaa siten, että tehtävät tallennetaan <em>käyttäjäkohtaisesti</em> hajautustaulua hyödyntäen. Käyttäjät tunnistetaan käyttäjän yksilöivällä characterStringlla (esimerkiksi opiskelijanumero), ja jokaiselle käyttäjälle on oma joukko tehdyistä tehtävistä.</p>

<pre class="sh_java">
public class Tehtavakirjanpito {
    private Map&lt;String, Set&lt;Integer&gt;&gt; tehdytTehtavat;

    public Tehtavakirjanpito() {
        this.tehdytTehtavat = new HashMap&lt;String, Set&lt;Integer&gt;&gt;();
    }

    public void lisaa(String kayttaja, int tehtava) {
        // huomaa miten uudelle käyttäjälle on lisättävä HashMapiin ensin tyhjä tehtäväjoukko
        if (!this.tehdytTehtavat.containsKey(kayttaja)) {
            this.tehdytTehtavat.put(kayttaja, new HashSet&lt;Integer&gt;());
        }

        // haetaan ensin käyttäjän tehtävät sisältävä joukko ja tehdään siihen lisäys
        Set&lt;Integer&gt; tehdyt = this.tehdytTehtavat.get(kayttaja);
        tehdyt.add(tehtava);

        // edellinen olisi onnitunut myös ilman apumuuttujaa seuraavasti
        //  this.tehdytTehtavat.get(kayttaja).add(tehtava);
    }

    public void tulosta() {
        for (String kayttaja: this.tehdytTehtavat.keySet()) {
            System.out.println(kayttaja + ": " + this.tehdytTehtavat.get(kayttaja));
        }
    }
}
</pre>

<pre class="sh_java">
        Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
        kirjanpito.lisaa("Mikael", 3);
        kirjanpito.lisaa("Mikael", 4);
        kirjanpito.lisaa("Mikael", 3);
        kirjanpito.lisaa("Mikael", 3);

        kirjanpito.lisaa("Pekka", 4);
        kirjanpito.lisaa("Pekka", 4);

        kirjanpito.lisaa("Matti", 1);
        kirjanpito.lisaa("Matti", 2);

        kirjanpito.tulosta();
</pre>

<pre>
Matti: [1, 2]
Pekka: [4]
Mikael: [3, 4]
</pre>


    <p>Huomaamme että käyttäjien nimet eivät tulostu esimerkissä	 järjestyksessä. Tämä selittyy sillä että <code>HashMap</code>-tyyppisessä hajautustaulussa alkioiden tallennus tapahtuu <code>hashCode</code>-metodin palauttaman hajautusarvon perusteella, eikä se liity millään tavalla alkioiden järjestykseen.</p>
 
<div class="tehtavat">

<h3>Sanakirja usealle käännökselle</h3>

<p>Tehdään hieman laajennettu versio viikolla 1 tehdystä sanakirjasta. Tehtävänäsi on toteuttaa pakkaukseen <code>sanakirja</code> luokka <code>OmaUseanKaannoksenSanakirja</code>, joka voi tallettaa yhden tai useamman käännöksen jokaiselle sanalle. Luokan tulee toteuttaa tehtäväpohjassa annettu rajapinta <code>UseanKaannoksenSanakirja</code>, jossa on seuraavat toiminnot:</p>

<p>
  <ul>
    <li><code>public void lisaa(String sana, String kaannos)</code></li>lisää käännöksen sanalle säilyttäen vanhat käännökset<br/>
    <li><code>public Set&lt;String&gt; kaanna(String sana)</code></li>palauttaa <code>Set</code>-olion, jossa on kaikki käännökset sanalle, tai <code>null</code>-viitteen, jos sanaa ei ole sanakirjassa<br/>
    <li><code>public void poista(String sana)</code></li>poistaa sanan ja sen kaikki käännökset sanakirjasta<br/>
  </ul>
</p>

<p>Käännökset kannattanee tallentaa yllä olevan esimerkin Tehtavakirjanpito tapaan <code>Map&lt;String, Set&lt;String&gt;&gt;</code>-tyyppiseen oliomuuttujaan.</p>

<p>Rajapinnan koodi:</p>

<pre class="sh_java">
package sanakirja;

import java.util.Set;

public interface UseanKaannoksenSanakirja {
    void lisaa(String sana, String kaannos);
    Set&lt;String&gt; kaanna(String sana);
    void poista(String sana);
}
</pre>

<p>Esimerkkiohjelma:</p>

<pre class="sh_java">
    UseanKaannoksenSanakirja sanakirja = new OmaUseanKaannoksenSanakirja();
    sanakirja.lisaa("kuusi", "six");
    sanakirja.lisaa("kuusi", "spruce");

    sanakirja.lisaa("pii", "silicon");
    sanakirja.lisaa("pii", "pi");

    System.out.println(sanakirja.kaanna("kuusi"));
    sanakirja.poista("pii");
    System.out.println(sanakirja.kaanna("pii"));
</pre>

<p>Tulostuu:</p>

<pre>
[six, spruce]
null
</pre>

</div>



<div class="tehtavat">
  <h3>Duplikaattien poistaja</h3>

  <p>Tehtävänäsi on toteuttaa pakkaukseen <code>tyokalut</code> luokka <code>OmaDuplikaattienPoistaja</code>, joka tallettaa annetut characterStringt siten, että annetuista characterStringista poistetaan samanlaiset characterStringt (eli duplikaatit). Lisäksi luokka pitää kirjaa duplikaattien määrästä. Luokan tulee toteuttaa tehtäväpohjassa annettu rajapinta <code>DuplikaattienPoistaja</code>, jossa on seuraavat toiminnot:</p>

  <p>
    <ul>
      <li><code>public void lisaa(String characterString)</code></li> tallettaa characterStringn, jos se ei ole duplikaatti<br/>
      <li><code>public int getHavaittujenDuplikaattienMaara()</code></li> palauttaa tähän mennessä havaittujen duplikaattien määrän<br/>
      <li><code>public Set&lt;String&gt; getUniikitcharacterStringt()</code></li> palauttaa <code>Set&lt;String&gt;</code>-rajapinnan toteuttavan olion, jossa on kaikki uniikit lisätyt characterStringt (ei siis duplikaatteja!). Jos characterStringja ei ole, palautetaan tyhjä joukko-olio.<br/>
      <li><code>public void tyhjenna()</code></li> poistaa talletetut characterStringt ja nollaa havaittujen duplikaattien määrän<br/>
    </ul>
  </p>

  <p>Rajapinnan koodi:</p>

<pre class="sh_java">
package tyokalut;

import java.util.Set;

public interface DuplikaattienPoistaja {
    void lisaa(String characterString);
    int getHavaittujenDuplikaattienMaara();
    Set&lt;String&gt; getUniikitcharacterStringt();
    void tyhjenna();
}
</pre>

  <p>Rajapintaa voi käyttää esimerkiksi näin:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        DuplikaattienPoistaja poistaja = new OmaDuplikaattienPoistaja();
        poistaja.lisaa("eka");
        poistaja.lisaa("toka");
        poistaja.lisaa("eka");

        System.out.println("Duplikaattien määrä nyt: " +
            poistaja.getHavaittujenDuplikaattienMaara());

        poistaja.lisaa("vika");
        poistaja.lisaa("vika");
        poistaja.lisaa("uusi");

        System.out.println("Duplikaattien määrä nyt: " +
            poistaja.getHavaittujenDuplikaattienMaara());

        System.out.println("Uniikit characterStringt: " +
            poistaja.getUniikitcharacterStringt());

        poistaja.tyhjenna();

        System.out.println("Duplikaattien määrä nyt: " +
            poistaja.getHavaittujenDuplikaattienMaara());

        System.out.println("Uniikit characterStringt: " +
            poistaja.getUniikitcharacterStringt());
    }
</pre>

  <p>Yllä oleva ohjelma tulostaisi: (characterStringjen järjestys saa vaihdella, sillä ei ole merkitystä)</p>

<pre>
Duplikaattien määrä nyt: 1
Duplikaattien määrä nyt: 2
Uniikit characterStringt: [eka, toka, vika, uusi]
Duplikaattien määrä nyt: 0
Uniikit characterStringt: []
</pre>

</div>

<h3>Yksi olio useammassa eri listassa, Map-rakenteessa tai joukossa</h3>

<p>Kuten muistamme, oliomuuttujat ovat viitetyyppisiä, eli muuttuja ei tallenna olioa itseään vaan viitteen olioon. Vastaavasti jos olio laitetaan esim. ArrayListaan, ei listalle talleteta olioa itseään vaan <em>viite</em> olioon. Mikään ei estäkään tallentamasta samaan olioon viitettä esim. useaan listaan tai HashMapiin. </p>

<p>Tarkastellaan esimerkkinä kirjastoa joka tallettaa kirjat hashMapeihin sekä kirjailijan että kirjan isbn-numeron perusteella. Tämän lisäksi kirjasto pitää kaikkia lainassa olevia sekä hyllyssä olevia kirjoja omalla listallaan.</p>

<pre class="sh_java">
public class Book {
    private String ISBN;
    private String kirjailija;
    private String name;
    private int vuosi;
    // ...
}

public class Booksto {
    private Map&lt String, Book&gt kirjaIsbnNumeronPerusteella;
    private Map&lt String, List&ltString&gt&gt kirjatBookilijanPerusteella;
    private List&ltBook&gt lainassaOlevatBookt;
    private List&ltBook&gt hyllyssaOlevatBookt;

    public void lisaaBookKokoelmaan(Book uusiBook){
        kirjaIsbnNumeronPerusteella.put(uusiBook.getIsbn(), uusiBook);
        kirjatBookilijanPerusteella.get(uusikirja.getBookilija()).add(uusiBook);
        hyllyssaOlevatBookt.add(uusiBook);
    }

    public Book haeBookIsbnNumeronPerusteella(String isbn){
        return kirjaIsbnNumeronPerusteella.get(isbn);
    }

    // ...
}
</pre>

<p>Jos olio on yhtäaikaa useassa kokoelmassa (listalla, joukossa tai map-rakenteessa), on kiinnitettävä erityistä huomiota, että kokoelmien tila on konsistentti. Jos esim. kirja päätetään poistaa, on se poistettava molemmista mapeista sekä lainassa/hyllyssä olevia kuvaavalta listalta.</p>

<div class="tehtavat">

  <h3>Numerotiedustelu</h3>

<p><b>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. Älä myöskään käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</b></p>


<p>Tehdään sovellus jonka avulla on mahdollista hallinnoida ihmisten puhelinnumeroita ja osoitteita.</p>

<p>Tehtävän voi suorittaa 1-5 pisteen laajuisena. Yhden pisteen laajuuteen on toteutettava seuraavat toiminnot:</p>

<ul>
  <li>1 puhelinnumeron lisäys henkilölle</li>
  <li>2 henkilön puhelinnumeroiden haku</li>
</ul>

<p>kahteen pisteeseen vaadittaan edellisten lisäksi</p>

<ul>
  <li>3 numeroa vastaavan henkilön nimen haku</li>
</ul>

<p>kolmeen pisteeseen vaadittaan edellisten lisäksi</p>

<ul>
  <li>4 osoitteen lisäys henkilölle</li>
  <li>5 henkilön tietojen (osoite ja puhelinnumero) haku</li>
</ul>

<p>neljään pisteeseen vaadittaan toiminto</p>

<ul>
  <li>6 henkilön tietojen poisto</li>
</ul>

<p>ja täysiin pisteeseen vaaditaan vielä</p>

<ul>
  <li>7 hakusanalla filtteröity listaus (nimen mukaan aakkostettuna), hakusana voi esiintyä henkilön nimessä tai osoitteessa</li>
</ul>

<p>Esimerkki ohjelman toiminnasta:</p>

<pre>
numerotiedustelu
käytettävissä olevat komennot:
 1 lisää numero
 2 hae numerot
 3 hae puhelinnumeroa vastaava henkilö
 4 lisää osoite
 5 hae henkilön tiedot
 6 poista henkilön tiedot
 7 filtteröity listaus
 x lopeta

komento: <font color="red">1</font>
kenelle: <font color="red">pekka</font>
numero: <font color="red">040-123456</font>

komento: <font color="red">2</font>
kenen: <font color="red">jukka</font>
  ei löytynyt

komento: <font color="red">2</font>
kenen: <font color="red">pekka</font>
 <font color="red">040-123456</font>

komento: <font color="red">1</font>
kenelle: <font color="red">pekka</font>
numero: <font color="red">09-222333</font>

komento: <font color="red">2</font>
kenen: <font color="red">pekka</font>
 040-123456
 09-222333

komento: <font color="red">3</font>
numero: <font color="red">02-444123</font>
 ei löytynyt

komento: <font color="red">3</font>
numero: <font color="red">09-222333</font>
 pekka

komento: <font color="red">5</font>
kenen: <font color="red">pekka</font>
  osoite ei tiedossa
  puhelinnumerot:
   040-123456
   09-222333

komento: <font color="red">4</font>
kenelle: <font color="red">pekka</font>
katu: <font color="red">ida ekmanintie</font>
kaupunki: <font color="red">helsinki</font>

komento: <font color="red">5</font>
kenen: <font color="red">pekka</font>
  osoite: ida ekmanintie helsinki
  puhelinnumerot:
   040-123456
   09-222333

komento: <font color="red">4</font>
kenelle: <font color="red">jukka</font>
katu: <font color="red">korsontie</font>
kaupunki: <font color="red">vantaa</font>

komento: <font color="red">5</font>
kenen: <font color="red">jukka</font>
  osoite: korsontie vantaa
  ei puhelinta

komento: <font color="red">7</font>
hakusana (jos tyhjä, listataan kaikki): <font color="red">kk</font>

 jukka
  osoite: korsontie vantaa
  ei puhelinta

 pekka
  osoite: ida ekmanintie helsinki
  puhelinnumerot:
   040-123456
   09-222333

komento: <font color="red">7</font>
hakusana (jos tyhjä, listataan kaikki): <font color="red">vantaa</font>

 jukka
  osoite: korsontie vantaa
  ei puhelinta

komento: <font color="red">7</font>
hakusana (jos tyhjä, listataan kaikki): <font color="red">seppo</font>
 ei löytynyt

komento: <font color="red">6</font>
kenet: <font color="red">jukka</font>

komento: <font color="red">5</font>
kenen: <font color="red">jukka</font>
  ei löytynyt

komento: <font color="red">x</font>
</pre>

<p>Huomioita:</p>
<ul>
  <li> Testien kannalta on oleellista että <em>käyttöliittymä</em> toimii kuten yllä olevassa esimerkissä. Sovellus voi itse päättää kuinka epäkelvot syötteet käsitellään. Testit sisältävät vaan kelvollisia syötteitä.</li>
  <li><em><strong>Ohjelman tulee käynnistyä kun tehtäväpohjassa oleva main-metodi suoritetaan, tehtävässä saa luoda vain yhden Scanner-olion.</strong></em></li>
<li> Älä käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</li>
<li>Älä käytä luokkein nimissä skandeja, ne saattavat aiheuttaa ongelmia testeihin!</li>
  <li>Yksinkertaisuuden vuoksi oletetaan että nimi on yksittäinen characterString, eli jos halutaan sukunimen mukaan aakkostetun tulostus viimeiseen toimintoon , nimi on annettava muodossa <em>mikkola pekka</em>.</li>
  <li>Henkilöllä voi olla useita puhelinnumeroja sekä osoite. Henkilöllä ei kuitenkaan ole välttämättä yhtään puhelinnumeroa tai osoite ei ole tiedossa.</li>
  <li>Jos henkilö poistetaan, ei mikään haku saa enää palauttaa henkilön tietoja.</li>
</ul>
</div>

<div class="tyhja"></div>



<div class="viikkoraja">Viikko 4</div>

<div class="tehtavat">


<NEXTWEEK></NEXTWEEK>
<h3>Rengastustoimisto</h3>

<p>Ohjelmoinnin perusteiden kuudennella viikolla teimme lintubongaria varten havaintotietokannan. Jatkamme hieman samasta teemasta, tällä kertaa teemme rengastustoimistolle ohjelman, jonka avulla pidetään kirjaa tiettynä vuotena rengastettujen lintujen havaintopaikoista.</p>

<big>
<p><strong>HUOM:</strong> saatat törmätä tehtävässä kummalliseen virheilmoitukseen <code>NoSuchMethodError: Lintu.equals(LLintu;)Z</code>, jos näin käy suorita <strong>clean and build</strong> eli paina harja ja vasara -kuvakkeesta.</p>
</big>

<h4>Linnun equals ja toString</h4>

<p>Rengastustoimisto tallettaa tiettynä vuotena rengastettettujen lintujen tiedot <code>Lintu</code>-olioihin:</p>

<pre class="sh_java">
public class Lintu {

    private String name;
    private String latinankielinenNimi;
    private int rengastusvuosi;

    public Lintu(String name, String latinankielinenNimi, int rengastusvuosi) {
        this.name = nimi;
        this.latinankielinenNimi = latinankielinenNimi;
        this.rengastusvuosi = rengastusvuosi;
    }

    @Override
    public String toString() {
        return this.latinankielinenNimi + "(" + this.rengastusvuosi + ")";
    }
}

</pre>

<p>Ideana on toteuttaa rengastustoimistoon toiminnallisuus jonka avulla voidaan pitää kirjaa tiettynä vuotena rengastettujen lintujen havaintojen lukumääristä ja havaintopaikoista. Havaintomääriä ja -paikkoja ei kuitenkaan talleteta Lintu-olioihin, vaan erilliseen HashMap:iin jonka avaimena käytetään Lintu-olioita. Kuten muistamme viikolta 2, on tälläisessä tapauksessa toteutettava luokalle <code>Lintu</code> metodit <code>equals(Object t)</code> ja <code>hashCode()</code>.</p>

<p>Joillain linnuilla on useita suomenkielisä nimiä (esim. punakottaraisesta käytetään edelleen joskus sen vanhaa nimitystä rusokottarainen), latinankielinen nimi on kuitenkin aina yksikäsitteinen. Tee luokalle <code>Lintu</code> <code>equals-</code> ja <code>hashCode-</code>metodit jotka toimivat siten, että lintu-oliot tulkitaan samoiksi jos niiden latinankielinen nimi ja rengastusvuosi ovat samat.</p>

<p>Esimerkki:</code>

<pre>
    Lintu lintu1 = new Lintu("punakottarainen", "Sturnus roseus", 2012);
    Lintu lintu2 = new Lintu("rusokottarainen", "Sturnus roseus", 2012);
    Lintu lintu3 = new Lintu("varis", "Corvus corone cornix", 2012);
    Lintu lintu4 = new Lintu("punakottarainen", "Sturnus roseus", 2000);

    System.out.println( lintu1.equals(lintu2));   // ovat sama koska sama latinankielinen nimi ja rengastusvuosi
    System.out.println( lintu1.equals(lintu3));   // eivät ole sama koska eri rengastusvuosi
    System.out.println( lintu1.equals(lintu4));   // eivät ole sama koska latinankielinen nimi eri
    System.out.println( lintu1.hashCode()==lintu2.hashCode() );
</pre>

<p>tulostuu:</p>

<pre>
true
false
false
true
</pre>

<h4>Rengastustoimisto</h4>

<p>Rengastustoimistolla on kaksi metodia: <code>public void havaitse(Lintu lintu, String paikka)</code> lisää linnulle havainnon ja havaintopaikan ja metodi <code>public void havainnot(Lintu lintu)</code> tulostaa alla olevan esimerkin mukaisesti parametrina olevan linnun havaintojen määrän ja havaintopaikat. Havaintopaikkojen tulostusjärjestyksellä ei ole testien läpimenon kannalta merkitystä.</p>

<p>Rengastustoimisto tallettaa havaintopaikat <code>Map&lt;Lintu, List&lt;String&gt;&gt;</code>-tyyppiseen oliomuuttujaan. Havaintojen lukumäärä selviää havaintopaikkojen listan pituudesta. Tarvittaessa voit ottaa tehtävään mallia luvusta 16.</p>

<p>Esimerkki rengastustoimiston käytöstä:</p>

<pre class="sh_java">
    Rengastustoimisto kumpulanRengas = new Rengastustoimisto();
  
    kumpulanRengas.havaitse( new Lintu("punakottarainen", "Sturnus roseus", 2012), "Arabia" );
    kumpulanRengas.havaitse( new Lintu("rusokottarainen", "Sturnus roseus", 2012), "Vallila" );
    kumpulanRengas.havaitse( new Lintu("harmaalokki", "Larus argentatus", 2008), "Kumpulanmäki" );
    kumpulanRengas.havaitse( new Lintu("punakottarainen", "Sturnus roseus", 2008), "Mannerheimintie" );

    kumpulanRengas.havainnot( new Lintu("rusokottarainen", "Sturnus roseus", 2012 ) );
    System.out.println("--");
    kumpulanRengas.havainnot( new Lintu("harmaalokki", "Larus argentatus", 2008 ) );
    System.out.println("--");
    kumpulanRengas.havainnot( new Lintu("harmaalokki", "Larus argentatus", 1980 ) );
</pre>

<p>tulostuu:</p>

<pre>
Sturnus roseus (2012) havaintoja: 2
Arabia
Vallila
--
Larus argentatus (2008) havaintoja: 1
Kumpulanmäki
--
Larus argentatus (1980) havaintoja: 0
</pre>

</div>


<h2>Olioiden monimuotoisuus</h2>

    <p>Olemme aiemmissa kappaleissa törmänneet tilanteisiin, joissa muuttujilla on oman tyyppinsä lisäksi muita tyyppejä. Esimerkiksi kappaleessa <a href="#45">45</a> huomasimme että <em>kaikki</em> oliot ovat tyyppiä <code>Object</code>. Jos olio on jotain tiettyä tyyppiä, voidaan se myös esittää <code>Object</code>-tyyppisenä muuttujana. Esimerkiksi <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html" target="_blank">String</a></code> on myös tyyppiä <code>Object</code>, joten kaikki <code>String</code>-tyyppiset muuttujat voidaan esitellä <code>Object</code> tyypin avulla.</p>

<pre class="sh_java">
    String characterString = "characterString";
    Object characterStringString = "toinen characterString";
</pre>

    <p>characterString-olion asettaminen <code>Object</code>-tyyppiseen viitteeseen onnistuu.</p>

<pre class="sh_java">
    String characterString = "characterString";
    Object characterStringString = characterString;
</pre>

    <p>Toiseen suuntaan asettaminen ei onnistu. Koska <code>Object</code>-tyyppiset muuttujat eivät ole tyyppiä <code>String</code>, ei object-tyyppistä muuttujaa voi asettaa <code>String</code>-tyyppiseen muuttujaan.</p>

<pre class="sh_java">
    Object characterStringString = "toinen characterString";
    String characterString = characterStringString; // EI ONNISTU!
</pre>

    <p>Mistä tässä oikein on kyse?</p>

    <p>Muuttujilla on oman tyyppinsä lisäksi aina perimiensä luokkien ja toteuttamiensa rajapintojen tyypit. Luokka <code>String</code> perii <code>Object</code>-luokan, joten <code>String</code>-oliot ovat aina myös tyyppiä <code>Object</code>. Luokka <code>Object</code> ei peri <code>String</code>-luokkaa, joten <code>Object</code>-tyyppiset muuttujat eivät ole automaattisesti tyyppiä <code>String</code>. Tutustutaan tarkemmin <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html">String</a></code>-luokan API-dokumentaatioon, erityisesti HTML-sivun yläosaan.</p>

    <p><img src="img-ohja/perinta/string-api.png"/></p>

    <p>String-luokan API-dokumentaatio alkaa yleisellä otsakkeella jota seuraa luokan pakkaus (<code>java.lang</code>). Pakkauksen jälkeen tulee luokan nimi (<code>Class String</code>), jota seuraa luokan <em>perintähierarkia</em>.</p>

<pre>
<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html">java.lang.Object</a>
  <img src="img-ohja/perinta/perinta.gif"/><strong>java.lang.String</strong>
</pre>

    <p>Perintähierarkia listaa luokat, jotka luokka on perinyt. Perityt luokat listataan perimisjärjestyksessä, tarkasteltava luokka aina alimpana. String-luokan perintähierarkiasta näemme, että <code>String</code>-luokka perii luokan <code>Object</code>. <em>Javassa jokainen luokka voi periä korkeintaan yhden luokan</em>, mutta välillisesti niitä voi periä useampia.</p>
    <p>Perintähierarkiaa voi ajatella myös listana tyypeistä, joita olio toteuttaa.</p>

    <p>Se, että kaikki oliot ovat tyyppiä <code>Object</code> helpottaa ohjelmointia. Jos tarvitsemme metodissa vain <code>Object</code>-luokassa määriteltyjä toimintoja, voimme käyttää metodin parametrina tyyppiä <code>Object</code>. Koska kaikki oliot ovat myös tyyppiä object, voi metodille antaa <em>minkä tahansa</em> olion parametrina. Luodaan metodi <code>tulostaMonesti</code>, joka saa parametrinaan <code>Object</code>-tyyppisen muuttujan ja tulostusten lukumäärän.</p>

<pre class="sh_java">
public class Tulostin {
    ...
    public void tulostaMonesti(Object object, int times) {
        for (int i = 0; i &lt; kertaa; i++) {
            System.out.println(object.toString());
        }
    }
    ...
}
</pre>

    <p>Metodille <code>tulostaMonesti</code> voi antaa parametrina minkä tahansa olion. Metodin <code>tulostaMonesti</code> sisässä oliolla on käytössään vain <code>Object</code>-luokassa määritellyt metodit koska olio <em>esitellään</em> metodissa <code>Object</code>-tyyppisenä.</p>

<pre class="sh_java">
    Tulostin tulostin = new Tulostin();

    String characterString = " o ";
    List&lt;String&gt; sanat = new ArrayList&lt;String&gt;();
    sanat.add("polymorfismi");
    sanat.add("perintä");
    sanat.add("kapselointi");
    sanat.add("abstrahointi");

    tulostin.tulostaMonesti(characterString, 2);
    tulostin.tulostaMonesti(sanat, 3);
</pre>

<pre>
 o
 o
[polymorfismi, perintä, kapselointi, abstrahointi]
[polymorfismi, perintä, kapselointi, abstrahointi]
[polymorfismi, perintä, kapselointi, abstrahointi]
</pre>


    <p>Jatketaan <code>String</code>-luokan API-kuvauksen tarkastelua. Kuvauksessa olevaa perintähierarkiaa seuraa listaus luokan toteuttamista rajapinnoista.</p>

<pre>
<strong>All Implemented Interfaces:</strong>
  <A HREF="http://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html" title="interface in java.io">Serializable</A>, <A HREF="http://docs.oracle.com/javase/6/docs/api/java/lang/CharSequence.html" title="interface in java.lang">CharSequence</A>, <A HREF="http://docs.oracle.com/javase/6/docs/api/java/lang/Comparable.html" title="interface in java.lang">Comparable</A>&lt;<A HREF="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html" title="class in java.lang">String</A>&gt;
</pre>

    <p>Luokka <code>String</code> toteuttaa rajapinnat <code>Serializable</code>, <code>CharSequence</code>, ja <code>Comparable&lt;String&gt;</code>. Myös rajapinta on tyyppi. Luokan String API-kuvauksen mukaan String-olion tyypiksi voi asettaa seuraavat rajapinnat.</p>

<pre class="sh_java">
    Serializable serializableString = "characterString";
    CharSequence charSequenceString = "characterString";
    Comparable&lt;String&gt; comparableString = "characterString";
</pre>

    <p>Koska metodeille voidaan määritellä metodin parametrin tyyppi, voimme määritellä metodeja jotka vastaanottavat <em>tietyn rajapinnan toteuttavan</em> olion. Kun metodille määritellään parametrina rajapinta, sille voidaan antaa parametrina mikä tahansa olio joka toteuttaa kyseisen rajapinnan, metodi ei välitä olion oikeasta tyypistä.</p>

    <p>Täydennetään <code>Tulostin</code>-luokkaa siten, että sillä on metodi <code>CharSequence</code>-rajapinnan toteuttavien olioiden merkkien tulostamiseen. Rajapinta <code>CharSequence</code> tarjoaa muunmuassa metodit <code>int length()</code>, jolla saa characterStringn pituuden, ja <code>char charAt(int index)</code>, jolla saa merkin tietyssä indeksissä.</p>

<pre class="sh_java">
public class Tulostin {
    ...
    public void tulostaMonesti(Object object, int times) {
        for (int i = 0; i &lt; kertaa; i++) {
            System.out.println(object.toString());
        }
    }

    public void tulostaMerkit(CharSequence charSequence) {
        for (int i = 0; i &lt; charSequence.length(); i++) {
            System.out.println(charSequence.charAt(i);
        }
    }
    ...
}
</pre>

    <p>Metodille <code>tulostaMerkit</code> voi antaa minkä tahansa <code>CharSequence</code>-rajapinnan toteuttavan olion. Näitä on muunmuassa <code>String</code> ja characterStringjen rakentamisessa usein Stringiä tehokkaampi <code>StringBuilder</code>. Metodi <code>tulostaMerkit</code> tulostaa annetun olion jokaisen merkin omalle rivilleen.</p>

<pre class="sh_java">
    Tulostin tulostin = new Tulostin();

    String mjono = "toimii";

    tulostin.tulostaMerkit(mjono);
</pre>

<pre>
t
o
i
m
i
i
</pre>

<div class="tehtavat">

<h3>Joukkoja</h3>

<p>Tässä tehtävässä teemme eliöita ja eliöistä koostuvia laumoja jotka liikkuvat ympäriinsä. Eliöiden sijaintien ilmoittamiseen käytetään  <em>kaksiulotteista koordinaatistoa</em>. Jokaiseen sijaintiin liittyy kaksi lukua, <code>x</code>- ja <code>y</code>-koordinaatti. Koordinaatti <code>x</code> kertoo, kuinka pitkällä "nollapisteestä" mitattuna sijainti on vaakasuunnassa, ja koordinaatti <code>y</code> vastaavasti kuinka pitkällä sijainti on pystysuunnassa. Jos koordinaatiston käsite ei ole tuttu, voit lukea siitä lisää esimerkiksi <a href="http://fi.wikipedia.org/wiki/Koordinaatisto">wikipediasta</a>.</p>

<p>Tehtävän mukana tulee rajapinta <code>Siirrettava</code>, joka kuvaa asiaa jota voidaan siirtää paikasta toiseen. Rajapinta sisältää metodin <code>void siirra(int dx, int dy)</code>. Parametri <code>dx</code> kertoo, paljonko asia siirtyy x-akselilla ja <code>dy</code> y-akselilla.</p>

<p>Tehtävässä toteutat luokat <code>Elio</code> ja <code>Lauma</code>, jotka molemmat ovat siirrettäviä. Toteuta kaikki toiminnallisuus pakkaukseen <code>siirrettava</code>.</p>

<h4>Elio-luokan toteuttaminen</h4>

<p>Luo pakkaukseen <code>siirrettava</code> luokka <code>Elio</code>, joka toteuttaa rajapinnan <code>Siirrettava</code>. Eliön tulee tietää oma sijaintinsa (x, y -koordinaatteina). Luokan <code>Elio</code> APIn tulee olla seuraava:</p>

  <ul>
    <li><strong>public Elio(int x, int y)</strong><br/>Luokan konstruktori, joka saa olion aloitussijainnin x- ja y-koordinaatit parametrina</li>
    <li><strong>public String toString()</strong><br/> Luo ja palauttaa oliosta characterStringesityksen. Eliön characterStringesityksen tulee olla seuraavanlainen <code>"x: 3; y: 6"</code>. Huomaa että koordinaatit on erotettu puolipisteellä (<code>;</code>)</li>
    <li><strong>public void siirra(int dx, int dy)</strong><br/> Siirtää oliota parametrina saatujen arvojen verran. Muuttuja <code>dx</code> sisältää muutoksen koordinaattiin <code>x</code>, muuttuja <code>dy</code> sisältää muutoksen koordinaattiin <code>y</code>. Esimerkiksi jos muuttujan <code>dx</code> arvo on 5, tulee oliomuuttujan <code>x</code> arvoa kasvattaa viidellä</li>
  </ul>

<p>Kokeile luokan <code>Elio</code> toimintaa seuraavalla esimerkkikoodilla. </p>

<pre class="sh_java">
     Elio elio = new Elio(20, 30);
     System.out.println(elio);
     elio.siirra(-10, 5);
     System.out.println(elio);
     elio.siirra(50, 20);
     System.out.println(elio);
</pre>

<pre>
x: 20; y: 30
x: 10; y: 35
x: 60; y: 55
</pre>

<h4>Lauman toteutus</h4>

<p>Luo seuraavaksi pakkaukseen <code>siirrettava</code> luokka <code>Lauma</code>, joka toteuttaa rajapinnan <code>Siirrettava</code>. Lauma koostuu useasta <code>Siirrettava</code>-rajapinnan toteutavasta oliosta, jotka tulee tallettaa esimerkiksi listarakenteeseen.</p>

<p>Luokalla <code>Lauma</code> tulee olla seuraavanlainen API.</p>

  <ul>
    <li><strong>public String toString()</strong><br/> Palauttaa characterStringesityksen lauman jäsenten sijainnista rivin vaihdolla erotettuna.</li>
    <li><strong>public void lisaaLaumaan(Siirrettava siirrettava)</strong><br/> Lisää laumaan uuden <code>Siirrettava</code>-rajapinnan toteuttavan olion</li>
    <li><strong>public void siirra(int dx, int dy)</strong><br/> Siirtää laumaa parametrina saatujen arvojen verran. Huomaa että tässä sinun tulee siirtää jokaista lauman jäsentä.</li>
  </ul>

<p>Kokeile ohjelmasi toimintaa alla olevalla esimerkkikoodilla.</p>

<pre class="sh_java">
    Lauma lauma = new Lauma();
    lauma.lisaaLaumaan(new Elio(73, 56));
    lauma.lisaaLaumaan(new Elio(57, 66));
    lauma.lisaaLaumaan(new Elio(46, 52));
    lauma.lisaaLaumaan(new Elio(19, 107));
    System.out.println(lauma);
</pre>

<pre>
x: 73; y: 56
x: 57; y: 66
x: 46; y: 52
x: 19; y: 107
</pre>
</div>

<h2>Luokan ominaisuuksien periminen</h2>

    <p>Luokat ovat ohjelmoijan tapa ratkaistavan ongelma-alueen käsitteiden selkeyttämiseen. Lisäämme jokaisella luomallamme luokalla uutta toiminnallisuutta ohjelmointikieleen. Toiminnallisuutta tarvitaan kohtaamiemme ongelmien ratkomiseen, ratkaisut syntyvät luokista luotujen olioiden välisen interaktion avulla. Olio-ohjelmoinnissa olio on itsenäinen kokonaisuus, jolla on olion tarjoamien metodien avulla muutettava tila. Olioita käytetään yhteistyössä; jokaisella oliolla on oma vastuualue. Esimerkiksi käyttöliittymäluokkamme ovat tähän mennessä hyödyntäneet <code>Scanner</code>-olioita.</p>

    <p>Jokainen Javan luokka perii luokan <code>Object</code>, eli jokainen luomamme luokka saa käyttöönsä kaikki <code>Object</code>-luokassa määritellyt metodit. Jos haluamme muuttaa <code>Object</code>-luokassa määriteltyjen metodien toiminnallisuutta tulee ne korvata (<code>Override</code>) määrittelemällä niille uusi toteutus luodussa luokassa.</p>

<p>Luokan <code>Object</code> perimisen lisäksi myös muiden luokkien periminen on mahdollista. Javan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/ArrayList.html" target="_blank">ArrayList</a></code>-luokan APIa tarkasteltaessa huomaamme että <code>ArrayList</code> perii luokan <code>AbstractList</code>. Luokka <code>AbstractList</code> perii luokan <code>AbstractCollection</code>, joka perii luokan <code>Object</code>.</p>

<pre>
<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html" target="_blank">java.lang.Object</a>
  <img src="img-ohja/perinta/perinta.gif" /><a href="http://docs.oracle.com/javase/6/docs/api/java/util/AbstractCollection.html" target="_blank">java.util.AbstractCollection</a>&lt;E&gt;
      <img src="img-ohja/perinta/perinta.gif" /><a href="http://docs.oracle.com/javase/6/docs/api/java/AbstractList.html" target="_blank">java.util.AbstractList</a>&lt;E&gt;
          <img src="img-ohja/perinta/perinta.gif" /><strong>java.util.ArrayList&lt;E&gt;</strong>
</pre>

        <p>Kukin luokka voi periä suoranaisesti yhden luokan. Välillisesti luokka kuitenkin perii kaikki perimänsä luokan ominaisuudet. Luokka <code>ArrayList</code> perii suoranaisesti luokan <code>AbstractList</code>, ja välillisesti luokat <code>AbstractCollection</code> ja <code>Object</code>. Luokalla <code>ArrayList</code> on siis käytössään luokkien <code>AbstractList</code>, <code>AbstractCollection</code> ja <code>Object</code> muuttujat, metodit <em>ja</em> rajapinnat.</p>

        <p>Luokan ominaisuudet peritään avainsanalla <code>extends</code>. Luokan perivää luokkaa kutsutaan aliluokaksi (<em>subclass</em>), perittävää luokkaa yliluokaksi (<em>superclass</em>). Tutustutaan erään autonvalmistajan järjestelmään, joka hallinnoi auton osia. Osien hallinan peruskomponentti on luokka <code>Osa</code>, joka määrittelee tunnuksen, valmistajan ja kuvauksen.</p>

<pre class="sh_java">
public class Osa {

    private String tunnus;
    private String valmistaja;
    private String kuvaus;

    public Osa(String tunnus, String valmistaja, String kuvaus) {
        this.tunnus = tunnus;
        this.valmistaja = valmistaja;
        this.kuvaus = kuvaus;
    }

    public String getTunnus() {
        return tunnus;
    }

    public String getKuvaus() {
        return kuvaus;
    }

    public String getValmistaja() {
        return valmistaja;
    }
}
</pre>

        <p>Yksi osa autoa on moottori. Kuten kaikilla osilla, myös moottorilla on valmistaja, tunnus ja kuvaus. Näiden lisäksi moottoriin liittyy moottorityyppi: esimerkiksi polttomoottori, sähkömoottori tai hybridi. Luodaan luokan <code>Osa</code> perivä luokka <code>Moottori</code>: moottori on osan erikoistapaus.</p>

<pre class="sh_java">
public class Moottori extends Osa {

    private String moottorityyppi;

    public Moottori(String moottorityyppi, String tunnus, String valmistaja, String kuvaus) {
        super(tunnus, valmistaja, kuvaus);
        this.moottorityyppi = moottorityyppi;
    }

    public String getMoottorityyppi() {
        return moottorityyppi;
    }
}
</pre>

        <p>Luokkamäärittely <code>public class Moottori extends Osa</code> kertoo että luokka <code>Moottori</code> perii luokan <code>Osa</code> toiminnallisuuden. Luokassa <code>Moottori</code> määritellään oliomuuttuja <code>moottorityyppi</code>.</p>

        <p>Moottori-luokan konstruktori on mielenkiintoinen. Konstruktorin ensimmäisellä rivillä on avainsana <code>super</code>, jolla kutsutaan yliluokan konstruktoria. Kutsu <code>super(tunnus, valmistaja, kuaus)</code> kutsuu luokassa <code>Osa</code> määriteltyä konstruktoria <code>public Osa(String tunnus, String valmistaja, String kuvaus</code>, jolloin yliluokassa määritellyt oliomuuttujat saavat arvonsa. Tämän jälkeen oliomuuttujalle <code>moottorityyppi</code> asetetaan siihen liittyvä arvo.</p>

        <p>Kun luokka <code>Moottori</code> perii luokan <code>Osa</code>, saa se käyttöönsä kaikki luokan <code>Osa</code> tarjoamat metodit. Luokasta <code>Moottori</code> voi tehdä ilmentymän aivan kuten mistä tahansa muustakin luokata.</p>

<pre class="sh_java">
        Moottori moottori = new Moottori("polttomoottori", "hz", "volkswagen", "VW GOLF 1L 86-91");
        System.out.println(moottori.getMoottorityyppi());
        System.out.println(moottori.getValmistaja());
</pre>

<pre>
polttomoottori
volkswagen
</pre>

        <p>Kuten huomaat, luokalla <code>Moottori</code> on käytössä luokassa <code>Osa</code> määritellyt metodit.</p> 

        <h3>Private, protected ja public</h3>

<p>Jos metodilla tai muuttujalla on näkyvyysmääre <code>private</code>, ei se näy aliluokille eikä aliluokalla ole mitään suoraa tapaa päästä käsiksi yliluokan siihen. Edellisessä esimerkissä Moottori ei siis pääse suoraan käsiksi yliluokassa Osa määriteltyihin ominaisuuksiinsa (tunnus, valmistaja, kuvaus). Aliluokka näkee luonnollisesti kaiken yliluokan julkisen eli <code>public</code>-määreellä varustetun kaluston. Jos halutaan määritellä yliluokkaan joitain muuttujia tai metodeja joiden näkeminen halutaan sallia aliluokille, mutta estää muilta voidaan käyttää näkyvyysmäärettä <code>protected</code>.</p>

        <h3>Yliluokka super</h3>

        <p>Yliluokan konstruktoria kutsutaan avainsanalla <code>super</code>. Kutsu <code>super</code> on käytännössä samanlainen kuin <code>this</code>-konstruktorikutsu. Kutsulle annetaan parametrina yliluokan konstruktorin vaatiman tyyppiset arvot.</p>

        <p>Konstruktoria kutsuttaessa yliluokassa määritellyt muuttujat alustetaan. Konstruktorikutsussa tapahtuu käytännössä täysin samat asiat kuin normaalissa konstruktorikutsussa. Jos yliluokassa ei ole määritelty parametritonta konstruktoria, tulee aliluokan konstruktorikutsuissa olla aina mukana yliluokan konstruktorikutsu.</p>

        <p>Huom! Kutsun <code>super</code> tulee olla aina konstruktorin ensimmäisellä rivillä!</p>

<h3>Yliluokan metodin kutsuminen</h3>

        <p>Yliluokassa määriteltyjä metodeja voi kutsua <code>super</code>-etuliitteen avulla, aivan kuten tässä luokassa määriteltyjä metodeja voi kutsua <code>this</code>-etuliitteellä. Esimerkiksi yliluokassa määriteltyä <code>toString</code>-metodia voi hyödyntää sen korvaavassa metodissa seuraavasti:</p>

<pre class="sh_java">
    @Override
    public String toString() {
        return super.toString() + "\n  Ja oma viestini vielä!";
    }
</pre>

<div class="tehtavat">
  <h3>Henkilö ja sen perilliset</h3>

  <h4 class="req">Person</h4>

  <p>Tee pakkaus <code>henkilot</code> ja sinne luokka <code>Person</code>, joka toimii seuraavan pääohjelman yhteydessä</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Person pekka = new Person("Pekka Mikkola", "Korsontie 1 03100 Vantaa");
        Person esko = new Person("Esko Ukkonen", "Mannerheimintie 15 00100 Helsinki");
        System.out.println(pekka);
        System.out.println(esko);
    }
</pre>

  <p>siten että tulostuu</p>

<pre>
Pekka Mikkola
  Korsontie 1 03100 Vantaa
Esko Ukkonen
  Mannerheimintie 15 00100 Helsinki
</pre>

<h4 class="req">Opiskelija</h4>

  <p>Tee pakkaukseen luokka <code>Opiskelija</code> joka <i>perii</i> luokan <code>Person</code>.

  <p>Opiskelijalla on aluksi 0 opintopistettä. Aina kun opiskelija opiskelee, kasvaa opintopistemäärä. Toteuta luokka siten, että seuraava pääohjelma:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Opiskelija olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
        System.out.println(olli );
        System.out.println("opintopisteitä " + olli.opintopisteita());
        olli.opiskele();
        System.out.println("opintopisteitä "+ olli.opintopisteita());
    }
</pre>

  <p>tuottaa tulostuksen:</p>

<pre>
Olli
  Ida Albergintie 1 00400 Helsinki
opintopisteitä 0
opintopisteitä 1
</pre>

<h4 class="req">Opiskelijalle toString</h4>

  <p>Edellisessä tehtävässä <code>Opiskelija</code> perii toString-metodin luokalta <code>Person</code>. Perityn metodin voi myös ylikirjoittaa, eli korvata omalla versiolla. Tee nyt <code>Opiskelija</code>:lle oma versio toString:istä joka toimii seuraavan esimerkin mukaan:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Opiskelija olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
        System.out.println( olli );
        olli.opiskele();
        System.out.println( olli );
    }
</pre>

  <p>Tulostuu:</p>

<pre>
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitä 0
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitä 1
</pre>

  <h4 class="req">Opettaja</h4>

  <p>Tee pakkaukseen luokka <code>Person</code>:n perivä luokka <code>Opettaja</code>. Opettajalla on palkka joka tulostuu opettajan characterStringesityksessä. </p>

  <p>Testaa, että seuraava pääohjelma</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Opettaja pekka = new Opettaja("Pekka Mikkola", "Korsontie 1 03100 Vantaa", 1200);
        Opettaja esko = new Opettaja("Esko Ukkonen", "Mannerheimintie 15 00100 Helsinki", 5400);
        System.out.println( pekka );
        System.out.println( esko );

        Opiskelija olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
        for ( int i=0; i &lt; 25; i++ ) {
            olli.opiskele();
        }
        System.out.println( olli );
    }
</pre>

  <p>Aikaansaa tulostuksen</p>

<pre>
Pekka Mikkola
  Korsontie 1 03100 Vantaa
  palkka 1200 euroa/kk
Esko Ukkonen
  Mannerheimintie 15 00100 Helsinki
  palkka 5400 euroa/kk
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitä 25
</pre>

<h4 class="req">Kaikki Persont listalle</h4>

  <p>Toteuta oletuspakkauksessa olevaan <code>Main</code>-luokkaan luokkametodi <code>public static void tulostaLaitoksenPersont(List&lt;Person&gt; henkilot)</code>, joka tulostaa kaikki metodille parametrina annetussa listassa olevat henkilöt. Metodin tulee toimia seuraavasti <code>main</code>-metodista kutsuttaessa.</p>

<pre class="sh_java">
    public static void tulostaLaitoksenPersont(List&lt;Person&gt; henkilot) {
       // tulostetaan kaikki listan henkilöt
    }

    public static void main(String[] args) {
        List&lt;Person&gt; henkilot = new ArrayList&lt;Person&gt;();
        henkilot.add( new Opettaja("Pekka Mikkola", "Korsontie 1 03100 Vantaa", 1200) );
        henkilot.add( new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki") );

        tulostaLaitoksenPersont(henkilot);
    }
</pre>

<pre>
Pekka Mikkola
  Korsontie 1 03100 Vantaa
  palkka 1200 euroa/kk
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitä 0
</pre>

</div>

   <h3>Olion tyyppi määrää kutsutun metodin: Polymorfismi</h3>

    <p>Olion kutsuttavissa olevat metodit määrittyvät muuttujan tyypin kautta. Esimerkiksi jos <code>Opiskelija</code>-tyyppisen olion viite on talletettu  <code>Person</code>-tyyppiseen muuttujaan, on oliosta käytössä vain <code>Person</code>-luokassa määritellyt metodit:</p> 

<pre class="sh_java">
   Person olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
   olli.opintopisteita();        // EI TOIMI!
   olli.opiskele();              // EI TOIMI!
   String.out.println( olli );   // olli.toString() TOIMII
</pre>

<p>Jos oliolla on monta eri tyyppiä, on sillä käytössä <em>jokaisen</em> tyypin määrittelemät metodit. Esimerkiksi <code>Opiskelija</code>-tyyppisellä oliolla on käytössä <code>Person</code>-luokassa määritellyt metodit sekä <code>Object</code>-luokassa määritellyt metodit.</p> 

<p>Edellisessä tehtävässä korvasimme Opiskelijan luokalta Henkilö perimän <code>toString</code> uudella versiolla. Myös luokka Henkilö oli jo korvannut Object-luokalta perimänsä toStringin. Jos käsittelemme olioa jonkin muun kuin sen todellisen tyypin omaavan muuttujan kautta, mitä versiota olion metodista kutsutaa? Esim. seuraavassa on kaksi opiskelijaa joiden viitteet on talletettu Person- ja Object-tyyppisiin muuttujiin. Molemmille kutsutaan metodia <code>toString</code>. Mikä versio metodista suoritetaan, luokassa Object, Person vai Opiskelija määritelty?</p>

<pre class="sh_java">
   Person olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
   String.out.println( olli );   

   Object liisa = new Opiskelija("Liisa", "Väinö Auerin katu 20 00500 Helsinki");
   String.out.println( liisa );
</pre>

<p>Tulostuu:</p>

<pre>
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitä 0
Liisa
  Väinö Auerin katu 20 00500 Helsinki
  opintopisteitä 0
</pre>

<p>Eli suoritettava metodi valitaan olion todellisen tyypin perusteella, ei viitteen tallettavan muuttujan tyypin perusteella!</p>

    <p>Hieman yleisemmin: <b>Suoritettava metodi valitaan aina olion todellisen tyypin perusteella riippumatta käytetyn muuttujan tyypistä. Oliot ovat monimuotoisia, eli olioita voi käyttää usean eri muuttujatyypin kautta. Suoritettava metodi liittyy aina olion todelliseen tyyppiin.</b> Tätä monimuotoisuutta kutsutaan polymorfismiksi.</p>

<h3>Toinen esimerkki: pisteitä</h3>

<p>Kaksiulotteisessa koordinaatiostossa sijaitsevaa pistettä voisi kuvata seuraavan luokan avulla:</p>

<pre class="sh_java">
public class Piste {

    private int x;
    private int y;

    public Piste(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int manhattanEtaisyysOrigosta(){
        return Math.abs(x)+Math.abs(y);
    }
    
    protected String sijainti(){
        return x+", "+y;
    }

    @Override
    public String toString() {
        return "("+this.sijainti()+") etäisyys "+this.manhattanEtaisyysOrigosta();
    }    
}
</pre>

<p>Metodi <code>sijainti</code> ei ole tarkoitettu ulkoiseen käyttöön, joten se on näkyvyysmääreeltään protected, eli aliluokat pääsevät siihen käsiksi. Esim. <a href="http://wiki.gamegardens.com/Path_Finding_Tutorial">reitinhakualgoritmien</a> hyödyntämässä <a href="http://en.wiktionary.org/wiki/Manhattan_distance">Manhattan-etäisyydellä</a> tarkoitetaan pisteiden etäisyyttä, jos niiden välin voi kulkea ainoastaan koordinaattiakselien suuntaisesti. </p> 

<p>Värillinen piste on muuten samanlainen kuin piste, mutta se sisältää characterStringna ilmaistavan värin. Luokka voidaan siis tehdä perimällä Piste:</p>

<pre class="sh_java">
public class VariPiste extends Piste {

    private String vari;

    public VariPiste(int x, int y, String vari) {
        super(x, y);
        this.vari = vari;
    }

    @Override
    public String toString() {
        return super.toString()+" väri: "+vari; 
    }
}
</pre>

<p>Luokka määrittelee oliomuuttujan värin talletusta varten. Koordinaatit talletetaan yliluokkaan. characterStringesityksestä halutaan muuten samanlainen kuin pisteellä, mutta väri tulee myös ilmaista. Ylikirjoitettu metodi <code>toString</code> kutsuukin yliluokan toStringiä ja lisää sen tulokseen pisteen värin.</p>

<p>Seuraavassa esimerkki, jossa listalle laitetaan muutama piste, osa normaaleja ja osa väripisteitä ja tulostetaan listalla olevat pisteet. Polymorfismin ansioista kaikille tulee kutsutuksi olion todellisen tyypin toString-metodi vaikka lista tuntee kaikki pisteet <code>Piste</code>-tyyppisinä:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        List<Piste> pisteet = new ArrayList<Piste>(); 
        pisteet.add(new Piste(4, 8));
        pisteet.add(new VariPiste(1, 1, "vihreä"));
        pisteet.add(new VariPiste(2, 5, "sininen"));
        pisteet.add(new Piste(0, 0));
        
        for (Piste piste : pisteet) {
            System.out.println(piste);
        }
    }
}
</pre>

<p>Tulostuu:</p>

<pre>
(4, 8) etäisyys 12
(1, 1) etäisyys 2 väri: vihreä
(2, 5) etäisyys 7 väri: sininen
(0, 0) etäisyys 0
</pre>

<p>Haluamme ohjelmaamme myös kolmeulotteisen pisteen. Koska kyseessä ei ole värillinen versio, periytetään se pisteestä:</p>

<pre class="sh_java">
public class Piste3D extends Piste {

    private int z;

    public Piste3D(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    protected String sijainti() {
        return super.sijainti()+", "+z;    // tulos characterString muotoa "x, y, z"
    }    

    @Override
    public int manhattanEtaisyysOrigosta() {
        // kysytään ensin yliluokalta x:n ja y:n perusteella laskettua etäisyyttä 
        // ja lisätään tulokseen z-koordinaatin vaikutus
        return super.manhattanEtaisyysOrigosta()+Math.abs(z);   
    }    
    
    @Override
    public String toString() {
        return "("+this.sijainti()+") etäisyys "+this.manhattanEtaisyysOrigosta();
    }    
}
</pre>

<p>Kolmiulotteinen piste siis määrittelee kolmatta koordinaattia vastaavan oliomuuttujan ja ylikirjoittaa metodit <code>sijainti</code>,
  <code>manhattanEtaisyysOrigosta</code> ja <code>toString</code> siten, että ne huomioivat kolmannen ulottuvuuden. Voimme nyt laajentaa edellistä esimerkkiä ja lisätä listalle myös kolmiulotteisia pisteitä:</p>

<pre class="sh_java">
public class Main {

    public static void main(String[] args) {
        List<Piste> pisteet = new ArrayList<Piste>(); 
        pisteet.add(new Piste(4, 8));
        pisteet.add(new VariPiste(1, 1, "vihreä"));
        pisteet.add(new VariPiste(2, 5, "sininen"));
        pisteet.add(new Piste3D(5, 2, 8));
        pisteet.add(new Piste(0, 0));
        
        for (Piste piste : pisteet) {
            System.out.println(piste);
        }
    }
}
</pre>

<p>Tulostus on odotusten mukainen</p>

<pre>
(4, 8) etäisyys 12
(1, 1) etäisyys 2 väri: vihreä
(2, 5) etäisyys 7 väri: sininen
(5, 2, 8) etäisyys 15
(0, 0) etäisyys 0
</pre>

<p>Huomamme, että kolmiulotteisen pisteen metodi <code>toString</code> on täsmälleen sama kuin pisteen toString. Voisimmeko jättää toStringin ylikirjoittamatta? Vastaus on kyllä! Kolmiulotteinen piste pelkistyy seuraavanlaiseksi:</p>

<pre class="sh_java">
public class Piste3D extends Piste {

    private int z;

    public Piste3D(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    protected String sijainti() {
        return super.sijainti()+", "+z;
    }    

    @Override
    public int manhattanEtaisyysOrigosta() {
        return super.manhattanEtaisyysOrigosta()+Math.abs(z);
    }      
}
</pre>

<p>Mitä tarkalleenottaen tapahtuu kuin kolmiulotteiselle pisteelle kutsutaan toString-metodia? Suoritus etenee seuraavasti:</p>
<ol>
<li>etsitään toString:in määrittelyä luokasta Piste3D, sitä ei löydy joten mennään yliluokkaan</li>
<li>etsitään toString:in määrittelyä yliluokasta Piste, metodi löytyy, joten suoritetaan sen koodi</li>
<ul>
<li>suoritettava koodi siis on <code>return "("+this.sijainti()+") etäisyys "+this.manhattanEtaisyysOrigosta();</code></li>
<li>esimmäisenä suoritetaan metodi sijainti</li>
<li>etsitään metodin sijainti määrittelyä luokasta Piste3D, metodi löytyy ja suoritetaan sen koodi</li>
<li>metodin sijainti laskee oman tuloksensa kutsumalla yliluokassa olevaa metodia sijainti</li>
<li>seuraavaksi etsitään metodin manhattanEtaisyysOrigosta määrittelyä luokasta Piste3D, metodi löytyy ja suoritetaan sen koodi</li>
<li>jälleen metodi laskee tuloksensa kutsuen ensin yliluokassa olevaa samannimistä metodia</li>
</ul>
</ol>

<p>Metodikutsun aikaansaama toimintoketju siis on varsin monivaiheinen. Periaate on kuitenkin selkeä: suoritettavan metodin määrittelyä etsitään ensin olion todellisen tyypin määrittelystä ja jos sitä ei löydy edetään yliluokkaan. Ja jos yliluokastakaan ei löydy metodin toteutusta siirrytään etsimään yliluokan yliluokasta jne...</p>

          <h3>Milloin perintää tulee käyttää?</h3>

          <p>Perintä on väline käsitehierarkioiden rakentamiseen ja erikoistamiseen; aliluokka on aina yliluokan erikoistapaus. Jos luotava luokka on olemassaolevan luokan erikoistapaus, voidaan uusi luokka luoda perimällä olemassaoleva luokka. Esimerkiksi auton osiin liittyvässä esimerkissä moottori <em>on</em> osa, mutta moottoriin liittyy lisätoiminnallisuutta mitä jokaisella osalla ei ole.</p>

          <p>Perittäessä aliluokka saa käyttöönsä yliluokan toiminnallisuudet. Jos aliluokka ei tarvitse tai käytä perittyä toiminnallisuutta, ei perintä ole perusteltua. Perityt luokat perivät yliluokkiensa metodit ja rajapinnat, eli aliluokkia voidaan käyttää missä tahansa missä yliluokkaa on käytetty. Perintähierarkia kannattaa mitää matalana, sillä hierarkian ylläpito ja jatkokehitys vaikeutuu perintöhierarkian kasvaessa. Yleisesti ottaen, jos perintähierarkian korkeus on yli 2 tai 3, ohjelman rakenteessa on todennäköisesti parannettavaa.</p>

          <p>Perinän käyttöä tulee miettiä. Esimerkiksi luokan <code>Auto</code> periminen luokasta <code>Osa</code> (tai <code>Moottori</code>) on väärin. Auto <em>sisältää</em> moottorin ja osia, mutta auto ei ole moottori tai osa. Voimme yleisemmin ajatella että jos olio omistaa tai koostuu toisista olioista, ei perintää tule käyttää.</p>

          <p>Perintää käytettäessä tulee varmistaa että Single Responsibility Principle pätee myös perittäessä. Jokaisella luokalla tulee olla vain yksi syy muuttua. Jos huomaat että perintä lisää luokan vastuita, tulee luokka pilkkoa useammaksi luokaksi.</p>

          <h4>Esimerkki: perinnän väärinkäyttö</h4>

          <p>Pohditaan postituspalveluun liittyviä luokkia <code>Asiakas</code>, joka sisältää asiakkaan tiedot, ja <code>Tilaus</code>, joka perii asiakkaan tiedot ja sisältää tilattavan tavaran tiedot. Luokassa <code>Tilaus</code> on myös metodi <code>postitusOsoite</code>, joka kertoo tilauksen postitusosoitteen.</p>

<pre class="sh_java">
public class Asiakas {

    private String name;
    private String osoite;

    public Asiakas(String name, String osoite) {
        this.name = nimi;
        this.osoite = osoite;
    }

    public String getName() {
        return nimi;
    }

    public String getOsoite() {
        return osoite;
    }

    public void setOsoite(String osoite) {
        this.osoite = osoite;
    }
}
</pre>

<pre class="sh_java">
public class Tilaus extends Asiakas {

    private String tuote;
    private String lukumaara;

    public Tilaus(String tuote, String lukumaara, String name, String osoite) {
        super(nimi, osoite);
        this.tuote = tuote;
        this.lukumaara = lukumaara;
    }

    public String getTuote() {
        return tuote;
    }

    public String getLukumaara() {
        return lukumaara;
    }

    public String postitusOsoite() {
        return this.getName() + "\n" + this.getOsoite();
    }
}
</pre>

  <p>Yllä perintää on käytetty väärin. Luokkaa perittäessä aliluokan tulee olla yliluokan erikoistapaus; tilaus ei ole asiakkaan erikoistapaus. Väärinkäyttö ilmenee single responsibility principlen rikkomisena: luokalla <code>Tilaus</code> on vastuu sekä asiakkaan tietojen ylläpidosta, että tilauksen tietojen ylläpidosta.</p>

  <p>Ratkaisussa piilevä ongelma tulee esiin kun mietimme mitä käy asiakkaan osoitteen muuttuessa.</p>

  <p>Osoitteen muuttuessa joudumme muuttamaan <em>jokaista</em> kyseiseen asiakkaaseen liittyvää tilausoliota, mikä kertoo huonosta tilanteesta. Parempi ratkaisu olisi kapseloida <code>Asiakas</code> <code>Tilaus</code>-luokan oliomuuttujaksi. Jos ajattelemme tarkemmin tilauksen semantiikkaa, tämä on selvää. <em>Tilauksella on asiakas</em>. Muutetaan luokkaa <code>Tilaus</code> siten, että se sisältää <code>Asiakas</code>-viitteen.</p>

<pre class="sh_java">
public class Tilaus {

    private Asiakas asiakas;
    private String tuote;
    private String lukumaara;

    public Tilaus(Asiakas asiakas, String tuote, String lukumaara) {
        this.asiakas = asiakas;
        this.tuote = tuote;
        this.lukumaara = lukumaara;
    }

    public String getTuote() {
        return tuote;
    }

    public String getLukumaara() {
        return lukumaara;
    }

    public String postitusOsoite() {
        return this.asiakas.getName() + "\n" + this.asiakas.getOsoite();
    }
}
</pre>

    <p>Yllä oleva luokka <code>Tilaus</code> on nyt parempi. Metodi <code>postitusosoite</code> käyttää <em>asiakas</em>-viitettä postitusosoitteen saamiseen sen sijaan että luokka perisi luokan <code>Asiakas</code>. Tämä helpottaa sekä ohjelman ylläpitoa, että sen konkreettista toiminnallisuutta. </p>

    <p>Nyt asiakkaan muuttaessa tarvitsee muuttaa vain asiakkaan tietoja, tilauksiin ei tarvitse tehdä muutoksia.</p>

<div class="tehtavat">

<h3>Varastointia</h3>

<p>Tehtäväpohjassa tulee mukana luokka <code>Varasto</code>, jonka tarjoamat konstruktorit ja metodit ovat seuraavat:</p>

<ul>

<li><b>public Varasto(double tilavuus)</b><br/>
     Luo tyhjän varaston, jonka vetoisuus eli tilavuus annetaan parametrina;
     sopimaton tilavuus (&lt;=0) luo käyttökelvottoman varaston,
     jonka tilavuus on 0.</li>

<li><b>public double getSaldo()</b><br/>
     Palauttaa arvonaan varaston saldon, eli varastossa olevan tilavuuden.</li>


<li><b>public double getTilavuus()</b><br/>
     Palauttaa arvonaan varaston tilavuuden (eli sen, joka annettiin konstruktorille).</li>

<li><b>public double paljonkoMahtuu()</b><br/>
     Palauttaa arvonaan tiedon, paljonko varastoon vielä mahtuu.</li>

<li><b>public void lisaaVarastoon(double maara)</b><br/>
     Lisää varastoon pyydetyn määrän; jos määrä on negatiivinen, mikään ei muutu,
     jos kaikki pyydetty ei enää mahdu, varasto laitetaan
     täydeksi ja loput määräsätä "heitetään menemään", "vuotaa yli".</li>

<li><b>public double otaVarastosta(double maara)</b><br/>
    Otetaan varastosta pyydetty määrä, metodi palauttaa paljonko <b>saadaan</b>.
    Jos pyydetty määrä on negatiivinen, mikään ei muutu ja palautetaan nolla.
    Jos pyydetään enemmän kuin varastossa on, annetaan mitä voidaan ja varasto
    tyhjenee.</li>

<li><b>public String toString()</b><br/>
    Palauttaa olion tilan characterStringesityksenä tyyliin <tt>saldo = 64.5, tilaa 123.5</tt></li>
</ul>

        <p>Tehtävässä rakennetaan <code>Varasto</code>-luokasta useampia erilaisia varastoja. Huom! Toteuta kaikki luokat pakkaukseen <code>varastot</code>.</p>

        <h4 class="req">Tuotevarasto, vaihe 1</h4>

        <p>Luokka <code>Varasto</code> hallitsee tuotteen määrään liittyvät toiminnot. Nyt tuotteelle halutaan lisäksi tuotenimi ja nimen käsittelyvälineet. <i>  <b>Ohjelmoidaan Tuotevarasto Varaston aliluokaksi!</b></i> Toteutetaan ensin pelkkä yksityinen oliomuuttuja tuotenimelle, konstruktori ja getteri nimikentälle:</p>


<ul>
<li><b>public Tuotevarasto(String tuotenimi, double tilavuus)</b><br/>
     Luo tyhjän tuotevaraston. Tuotenimi ja vetoisuus annetaan parametrina.</li>


<li><b>public String getName()</b><br/>
     Palauttaa arvonaan tuotteen nimen.</li>
</ul>


        <p><i>Muista millä tavoin konstruktori voi ensi toimenaan suorittaa yliluokan konstruktorin!</i></p>

        <p>Käyttöesimerkki:</p>

<pre class="sh_java">
        Tuotevarasto mehu = new Tuotevarasto("Juice", 1000.0);
        mehu.lisaaVarastoon(1000.0);
        mehu.otaVarastosta(11.3);
        System.out.println(mehu.getName()); // Juice
        System.out.println(mehu);           // saldo = 988.7, tilaa 11.3
</pre>

<pre>
Juice
saldo = 988.7, vielä tilaa 11.3
</pre>


<h4 class="req">Tuotevarasto, vaihe 2</h4>


<p>Kuten edellisestä esimerkistä näkee, Tuotevarasto-olion perimä <code>toString()</code> ei tiedä (tietenkään!) mitään tuotteen nimestä. <i>Asialle on tehtävä jotain!</i> Lisätään samalla myös setteri tuotenimelle:</p>

<ul>
<li><b>public void setNimi(String uusiNimi)</b> asettaa tuotteelle
       uuden nimen.</li>

<li><b>public String toString()</b> palauttaa olion tilan characterStringesityksenä
       tyyliin <tt>Juice: saldo = 64.5, tilaa 123.5</tt></li>
</ul>

        <p>Uuden <code>toString()</code>-metodin voisi toki ohjelmoida käyttäen yliluokalta perittyjä gettereitä, joilla perittyjen, mutta piilossa pidettyjen kenttien arvoja saa käyttöönsä. Koska yliluokkaan on kuitenkin jo ohjelmoitu tarvittava taito varastotilanteen merkkiesityksen tuottamiseen, miksi nähdä vaivaa sen uudelleen ohjelmointiin. Käytä siis hyväksesi perittyä <code>toString</code>iä.</p>

        <p><i>Muista miten korvattua metodia voi kutsua aliluokassa!</i></p>

        <p>Käyttöesimerkki:</p>

<pre class="sh_java">
        Tuotevarasto mehu = new Tuotevarasto("Juice", 1000.0);
        mehu.lisaaVarastoon(1000.0);
        mehu.otaVarastosta(11.3);
        System.out.println(mehu.getName()); // Juice
        mehu.lisaaVarastoon(1.0);
        System.out.println(mehu);           // Juice: saldo = 989.7, tilaa 10.299999999999955
</pre>

<pre>
Juice
Juice: saldo = 989.7, tilaa 10.299999999999955
</pre>


<h4>Muutoshistoria</h4>

        <p>Toisinaan saattaa olla kiinostavaa tietää, millä tavoin jonkin tuotteen varastotilanne muuttuu: onko varasto usein hyvin vajaa, ollaanko usein ylärajalla, onko vaihelu suurta vai pientä, jne. Varustetaan siksi <code>Tuotevarasto</code>-luokka taidolla muistaa tuotteen määrän muutoshistoriaa.</p>

        <p>Aloitetaan apuvälineen laadinnalla.</p>

        <p>Muutoshistorian muistamisen voisi toki toteuttaa suoraankin <code>ArrayList&lt;Double&gt;</code>-oliona luokassa <i>Tuotevarasto</i>, mutta nyt laaditaan kuitenkin oma <i>erikoistettu väline</i> tähän tarkoitukseen. Väline toteutetaan kapseloimalla <code>ArrayList&lt;Double&gt;</code>-olio.</p>

        <p><code>Muutoshistoria</code>-luokan julkiset konstruktorit ja metodit:</p>

<ul>
<li><b>public Muutoshistoria()</b> luo tyhjän <code>Muutoshistoria</code>-olion.</li>

<li><b>public void lisaa(double tilanne)</b> lisää muutoshistorian viimeisimmäksi muistettavaksi määräksi parametrina annetun tilanteen. </li>

<li><b>public void nollaa()</b> tyhjää muistin.</li>

<li><b>public String toString()</b> palauttaa muutoshistorian
    characterStringesityksen. <i>ArrayList-luokan antama characterStringesitys kelpaa sellaisenaan.</i> </li>

</ul>


<h4 class="req">Muutoshistoria.java, vaihe 2</h4>

<p>
Täydennä <code>Muutoshistoria</code>-luokkaa analyysimetodein:</p>

<ul>

<li><b>public double maxArvo()</b> palauttaa muutoshistorian
   suurimman arvon. Jos historia on tyhjä, metodi palauttaa nollan.</li>


<li><b>public double minArvo()</b> palauttaa muutoshistorian
   pienimmän arvon. Jos historia on tyhjä, metodi palauttaa nollan.</li>

<li><b>public double keskiarvo()</b> palauttaa muutoshistorian
    arvojen keskiarvon. Jos historia on tyhjä, metodi palauttaa nollan.</li>

</ul>

<h4>Muutoshistoria.java, vaihe 3</h4>

<p>
Täydennä <code>Muutoshistoria</code>-luokkaa analyysimetodein:</p>

<ul>
<li><b>public double suurinMuutos()</b> palauttaa muutoshistorian isoimman (huom: -5:n kokoinen muutos on isompi kuin 4:n kokoinen muutos) yksittäisen muutoksen itseisarvon. Jos historia on tyhjä tai yhden arvon mittainen, metodi palauttaa nollan. Itseisarvo on luvun etäisyys nollasta. Esimerkiksi luvun -5.5 itseisarvo on 5.5, luvun 3.2 itseisarvo on 3.2. </li>

<li><b>public double varianssi()</b> palauttaa muutoshistorian arvojen varianssin (käytetään otosvarianssin kaavaa). Jos historia on tyhjä tai yhden arvon mittainen, metodi palauttaa nollan.</li>
</ul>

<p>Ohjeen varianssin laskemiseksi voit katsoa esimerkiksi <a href="http://fi.wikipedia.org/wiki/Varianssi#Populaatio-_ja_otosvarianssi">Wikipediasta</a> kohdasta populaatio- ja otosvarianssi. Esimerkiksi lukujen 3, 2, 7, 2 keskiarvo on 3.5, joten otosvarianssi on ((3 - 3.5)² + (2 - 3.5)² + (7 - 3.5)² + (2 - 3.5)²)/(4 - 1) ˜ 5,666667.)</p>




<h4 class="req">MuistavaTuotevarasto, vaihe 1</h4>

<p>
Toteuta luokan <code>Tuotevarasto</code> aliluokkana <code>MuistavaTuotevarasto</code>.
Uusi versio tarjoaa vanhojen lisäksi varastotilanteen muutoshistoriaan liittyviä
palveluita. Historiaa hallitaan <code>Muutoshistoria</code>-oliolla.
</p>

<p>
Julkiset konstruktorit ja metodit:</p>

<ul>

<li><b>public MuistavaTuotevarasto(String tuotenimi, double tilavuus, double alkuSaldo)</b>
     luo tuotevaraston. Tuotenimi, vetoisuus ja alkusaldo annetaan parametrina.
     <i>Aseta alkusaldo sekä varaston alkusaldoksi että muutoshistorian ensimmäiseksi arvoksi.</i>

<li><b>public String historia()</b> palauttaa tuotehistorian tyyliin
       <tt>[0.0, 119.2, 21.2]</tt>.  <i>Käytä Muutoshistoria-olion merkkiesitystä sellaisenaan.</i>

</ul>
<p>
<b>Huomaa</b> että tässä esiversiossa historia ei vielä toimi kunnolla; nyt vasta vain aloitussaldo muistetaan.
</p>

<p>
Käyttöesimerkki:
</p>

<pre class="sh_java">
// tuttuun tapaan:
MuistavaTuotevarasto mehu = new MuistavaTuotevarasto("Juice", 1000.0, 1000.0);
mehu.otaVarastosta(11.3);
System.out.println(mehu.getName()); // Juice
mehu.lisaaVarastoon(1.0);
System.out.println(mehu);           // Juice: saldo = 989.7, vielä tilaa 10.3
...
<b>// mutta vielä historia() ei toimi kunnolla:</b>
System.out.println(mehu.historia()); // [1000.0]
   // saadaan siis vasta konstruktorin asettama historian alkupiste...
...
</pre>


<p>
Tulostus siis:
</p>
<pre>
Juice
Juice: saldo = 989.7, vielä tilaa 10.299999999999955
[1000.0]
</pre>

<h4 class="req">MuistavaTuotevarasto, vaihe 2</h4>

<p>
<i>On aika aloittaa historia!</i> Ensimmäinen versio ei historiasta tiennyt kuin alkupisteen. Täydennä luokkaa metodein
</p>
<ul>

<li><b>public void lisaaVarastoon(double maara)</b>

    toimii kuin <i>Varasto</i>-luokan metodi, mutta muuttunut tilanne kirjataan historiaan.
<b>Huom: </b> historiaan tulee kirjata lisäyksen jälkeinen varastosaldo, ei lisättävää määrää!
</li>



<li><b>public double otaVarastosta(double maara)</b> toimii kuin <code>Varasto</code>-luokan metodi, mutta muuttunut tilanne kirjataan historiaan. <b>Huom: </b> historiaan tulee kirjata poiston jälkeinen varastosaldo, ei poistettavaa määrää!</li>

</ul>

<p>
Käyttöesimerkki:
</p>

<pre class="sh_java">
// tuttuun tapaan:
MuistavaTuotevarasto mehu = new MuistavaTuotevarasto("Juice", 1000.0, 1000.0);
mehu.otaVarastosta(11.3);
System.out.println(mehu.getName()); // Juice
mehu.lisaaVarastoon(1.0);
System.out.println(mehu);           // Juice: saldo = 989.7, vielä tilaa 10.3
...
// mutta nyt on historiaakin:
System.out.println(mehu.historia()); // [1000.0, 988.7, 989.7]
...
</pre>
<p>
Tulostus siis:
</p>
<pre>
Juice
Juice: saldo = 989.7, vielä tilaa 10.299999999999955
[1000.0, 988.7, 989.7]
</pre>
<p>

<p>
<i>Muista miten korvaava metodi voi käyttää hyväkseen korvattua metodia!</i>
</p>


<h4 class="req">MuistavaTuotevarasto, vaihe 3</h4>
<p>
Täydennä luokkaa metodilla
</p>
<ul>

<li><b>public void tulostaAnalyysi()</b>, joka tulostaa
     tuotteeseen liittyviä historiatietoja esimerkin
     esittämään tapaan.</li>
</ul>

<p>
Käyttöesimerkki:
</p>
<pre class="sh_java">
MuistavaTuotevarasto mehu = new MuistavaTuotevarasto("Juice", 1000.0, 1000.0);
mehu.otaVarastosta(11.3);
mehu.lisaaVarastoon(1.0);
//System.out.println(mehu.historia()); // [1000.0, 988.7, 989.7]

mehu.tulostaAnalyysi();
</pre>
<p>
Metodi <i>tulostaAnalyysi</i> kirjoittaa ilmoituksen tyyliin:
</p>

<pre>
Tuote: Juice
Historia: [1000.0, 988.7, 989.7]
Suurin tuotemäärä: 1000.0
Pienin tuotemäärä: 988.7
Keskiarvo: 992.8
</pre>
<p>

<h4>MuistavaTuotevarasto, vaihe 4</h4>
<p>
Täydennä analyysin tulostus sellaiseksi, että mukana ovat myös muutoshistorian suurin muutos ja historian varianssi.
</p>

</div>


<h3>Perintä, rajapinnat, kumpikin, vai eikö kumpaakaan?</h3>

<p>Perintä ei sulje pois rajapintojen käyttöä, eikä rajapintojen käyttö sulje pois perinnän käyttöä. Rajapinnat toimivat sopimuksena luokan tarjoamasta toteutuksesta, ja mahdollistavat konkreettisen toteutuksen abstrahoinnin. Rajapinnan toteuttavan luokan vaihto on hyvin helppoa.</p>

        <p>Aivan kuten rajapintaa toteuttaessa, sitoudumme perittäessä siihen, että aliluokkamme tarjoaa kaikki yliluokan metodit. Monimuotoisuuden ja polymorfismin takia perintäkin toimii kuin rajapinnat. Voimme antaa yliluokkaa käyttävälle metodille sen aliluokan ilmentymän.</p>

        <p>Tehdään seuraavaksi maatilasimulaattori, jossa simuloidaan maatilan elämää. Huomaa että ohjelmassa ei käytetä perintää, ja rajapintojenkin käyttö on melko vähäistä. Usein ohjelmat tehdäänkin niin että ensin toteutetaan yksi versio, jota lähdetään parantamaan myöhemmin. Tyypillistä on että ensimmäistä versiota toteutettaessa ongelma-aluetta ei vielä ymmärretä kunnolla, jolloin rajapintojen ja käsitehierarkioiden suunnittelu ennalta on hyvin vaikeaa ja saattaa jopa hidastaa työskentelyä.</p>


<div class="tehtavat">
<h3>Maatilasimulaattori</h3>

<p>
Maatiloilla on lypsäviä eläimiä, jotka tuottavat maitoa.  Maatilat
eivät itse käsittele maitoa, vaan se kuljetetaan Maitoautoilla
meijereille.  Meijerit ovat yleisiä maitotuotteita tuottavia
rakennuksia.  Jokainen meijeri erikoistuu yhteen tuotetyyppiin,
esimerkiksi Juustomeijeri tuottaa Juustoa, Voimeijeri tuottaa voita ja
Maitomeijeri tuottaa maitoa.
<p>

<p>
Rakennetaan maidon elämää kuvaava simulaattori. Toteuta kaikki luokat pakkaukseen <code>maatilasimulaattori</code>.
<p>


<h4>Maitosäiliö</h4>

<p>
Jotta maito pysyisi tuoreena, täytyy se säilöä sille tarkoitettuun säiliöön.
Säiliöitä valmistetaan sekä oletustilavuudella 2000 litraa, että
asiakkaalle räätälöidyllä tilavuudella.  Toteuta luokka Maitosailio
jolla on seuraavat konstruktorit ja metodit.
</p>

  <ul>
    <li><strong>public Maitosailio()</strong></li>
    <li><strong>public Maitosailio(double tilavuus)</strong></li>
    <li><strong>public double getTilavuus()</strong></li>
    <li><strong>public double getSaldo()</strong></li>
    <li><strong>public double paljonkoTilaaJaljella()</strong></li>
    <li><strong>public void lisaaSailioon(double maara)</strong>
      lisää säiliöön vain niin paljon maitoa kuin sinne mahtuu,
      ylimääräiset jäävät lisäämättä, maitosäiliön ei siis tarvitse huolehtia tilanteesta jossa maitoa valuu yli</li>
    <li><strong>public double otaSailiosta(double maara)</strong>
      ottaa säiliöstä pyydetyn määrän, tai niin paljon kuin siellä on jäljellä
    </li>
  </ul>

<p>
Toteuta <code>Maitosailio</code>-luokalle myös <code>toString()</code>-metodi, jolla kuvaat sen tilaa.
Ilmaistessasi säiliön tilaa <code>toString()</code>-metodissa, pyöristä litramäärät
ylöspäin käyttäen <code>Math</code>-luokan tarjoamaa <code>ceil()</code>-metodia.
</p>

<p>Testaa maitosailiötä seuraavalla ohjelmapätkällä:</p>

<pre class="sh_java">
        Maitosailio sailio = new Maitosailio();
        sailio.otaSailiosta(100);
        sailio.lisaaSailioon(25);
        sailio.otaSailiosta(5);
        System.out.println(sailio);

        sailio = new Maitosailio(50);
        sailio.lisaaSailioon(100);
        System.out.println(sailio);
</pre>


<p>Ohjelman tulostuksen tulee olla seuraavankaltainen:</p>

<pre>
20.0/2000.0
50.0/50.0
</pre>

<p>
Huomaa että kutsuttaessa <code>System</code>-luokan <code>out</code>-olioon liittyvää
<code>println()</code>-metodia, joka saa parametrikseen <code>Object</code>-tyyppisen
muuttujan, tulostus käyttää <code>Maitosailio</code>-luokassa korvattua
<code>toString()</code>-metodia! Tässä on kyse polymorfismista, eli
ajonaikaisesta käytettävien metodien päättelystä.
</p>

<h4>Lehmä</h4>

<p>Saadaksemme maitoa tarvitsemme myös lehmiä. Lehmällä on nimi ja utareet. Utareiden tilavuus on satunnainen luku väliltä 15 ja 40, luokkaa <code>Random</code> voi käyttäää satunnaislukujen arpomiseen, esimerkiksi  <code>int luku = 15 + new Random().nextInt(26);</code>. Luokalla <code>Lehma</code> on seuraavat toiminnot:</p>

  <ul>
    <li><strong>public Lehma()</strong> luo uuden lehmän satunnaisesti valitulla nimellä</li>
    <li><strong>public Lehma(String name)</strong> luo uuden lehmän annetulla nimellä</li>
    <li><strong>String getName()</strong> palauttaa lehmän nimen</li>
    <li><strong>double getTilavuus()</strong> palauttaa utareiden tilavuuden</li>
    <li><strong>double getMaara()</strong> palauttaa utareissa olevan maidon määrän</li>
    <li><strong>String toString()</strong> palauttaa lehmää kuvaavan characterStringn (ks. esimerkki alla)</li>
  </ul>

<p><code>Lehma</code> toteuttaa myös rajapinnat: <code>Lypsava</code>, joka kuvaa lypsämiskäyttäytymistä, ja <code>Eleleva</code>, joka kuvaa elelemiskäyttäytymistä.</p>

<pre class="sh_java">
public interface Lypsava {
    public double lypsa();
}

public interface Eleleva {
    public void eleleTunti();
}
</pre>

<p>
Lehmää lypsettäessä sen koko maitovarasto tyhjennetään jatkokäsittelyä
varten.  Lehmän elellessä sen maitovarasto täyttyy hiljalleen.
Suomessa maidontuotannossa käytetyt lehmät tuottavat keskimäärin
noin 25-30 litraa maitoa päivässä.  Simuloidaan tätä tuotantoa
tuottamalla noin 0.7 - 2 litraa tunnissa.
</p>

<p>
Jos lehmälle ei anneta nimeä, valitse sille nimi satunnaisesti seuraavasta listasta.
</p>

<pre class="sh_java">
    private static final String[] NIMIA = new String[]{
        "Anu", "Arpa", "Essi", "Heluna", "Hely",
        "Hento", "Hilke", "Hilsu", "Hymy", "Ihq", "Ilme", "Ilo",
        "Jaana", "Jami", "Jatta", "Laku", "Liekki",
        "Mainikki", "Mella", "Mimmi", "Naatti",
        "Nina", "Nyytti", "Papu", "Pullukka", "Pulu",
        "Rima", "Soma", "Sylkki", "Valpu", "Virpi"};
</pre>

<p>Toteuta luokka Lehma ja testaa sen toimintaa seuraavan ohjelmapätkän avulla.</p>

<pre class="sh_java">
        Lehma lehma = new Lehma();
        System.out.println(lehma);


        Eleleva elelevaLehma = lehma;
        elelevaLehma.eleleTunti();
        elelevaLehma.eleleTunti();
        elelevaLehma.eleleTunti();
        elelevaLehma.eleleTunti();

        System.out.println(lehma);

        Lypsava lypsavaLehma = lehma;
        lypsavaLehma.lypsa();

        System.out.println(lehma);
        System.out.println("");

        lehma = new Lehma("Ammu");
        System.out.println(lehma);
        lehma.eleleTunti();
        lehma.eleleTunti();
        System.out.println(lehma);
        lehma.lypsa();
        System.out.println(lehma);

</pre>

<p>
Ohjelman tulostus on erimerkiksi seuraavanlainen.</p>

</p>

<pre>
Liekki 0.0/23.0
Liekki 7.0/23.0
Liekki 0.0/23.0
Ammu 0.0/35.0
Ammu 9.0/35.0
Ammu 0.0/35.0
</pre>


<h4>Lypsyrobotti</h4>
<p>
Nykyaikaisilla maatiloilla lypsyrobotit hoitavat lypsämisen.
Jotta lypsyrobotti voi lypsää lypsävää otusta, tulee lypsyrobotin
olla kiinnitetty maitosäiliöön:
</p>

  <ul>
    <li><strong>public Lypsyrobotti()</strong> luo uuden lypsyrobotin</li>
    <li><strong>Maitosailio getMaitosailio()</strong> palauttaa kiinnitetyn maitosäiliö tai <code>null</code>-viitteen, jos säiliötä ei ole vielä kiinnitetty</li>
    <li><strong>void setMaitosailio(Maitosailio maitosailio)</strong> kiinnittää annetun säiliön lypsyrobottiin</li>
    <li><strong>void lypsa(Lypsava lypsava)</strong> lypsää lehmän robottiin kiinnitettyyn maitosäiliöön, metodi heittää poikkeuksen <code>IllegalStateException</code>, jos säiliötä ei ole kiinnitetty </li>
  </ul>

<p>Toteuta luokka Lypsyrobotti ja testaa sitä seuraavien ohjelmanpätkien avulla. Varmista että lypsyrobotti voi lypsää kaikkia Lypsava-rajapinnan toteuttavia olioita!</p>

<pre class="sh_java">
        Lypsyrobotti lypsyrobotti = new Lypsyrobotti();
        Lehma lehma = new Lehma();
        lypsyrobotti.lypsa(lehma);
</pre>

<pre>
Exception in thread "main" java.lang.IllegalStateException: Maitosäiliötä ei ole asennettu
        at maatilasimulaattori.Lypsyrobotti.lypsa(Lypsyrobotti.java:17)
        at maatilasimulaattori.Main.main(Main.java:9)
Java Result: 1
</pre>

<pre class="sh_java">
        Lypsyrobotti lypsyrobotti = new Lypsyrobotti();
        Lehma lehma = new Lehma();
        System.out.println("");

        Maitosailio sailio = new Maitosailio();
        lypsyrobotti.setMaitosailio(sailio);
        System.out.println("Säiliö: " + sailio);

        for(int i = 0; i &lt; 2; i++) {
            System.out.println(lehma);
            System.out.println("Elellään..");
            for(int j = 0; j &lt; 5; j++) {
                lehma.eleleTunti();
            }
            System.out.println(lehma);

            System.out.println("Lypsetään...");
            lypsyrobotti.lypsa(lehma);
            System.out.println("Säiliö: " + sailio);
            System.out.println("");
        }
</pre>

<p>Ohjelman tulostus on esimerkiksi seuraavanlainen.</p>

<pre>
Säiliö: 0.0/2000.0
Mella 0.0/23.0
Elellään..
Mella 6.2/23.0
Lypsetään...
Säiliö: 6.2/2000.0

Mella 0.0/23.0
Elellään..
Mella 7.8/23.0
Lypsetään...
Säiliö: 14.0/2000.0
</pre>

<h4>Navetta</h4>

<p>
Lehmät hoidetaan (eli tässä tapauksessa lypsetään) navetassa.
Alkukantaisissa navetoissa on maitosäiliö ja tilaa yhdelle
lypsyrobotille. Huomaa että lypsyrobottia asennettaessa se kytketään
juuri kyseisen navetan maitosäiliöön.  Jos navetassa ei ole
lypsyrobottia, ei siellä voida myöskään hoitaa lehmiä.
Toteuta luokka <code>Navetta</code> jolla on seuraavat konstruktorit ja metodit:
</p>

  <ul>
    <li><strong>public Navetta(Maitosailio maitosailio)</strong></li>
    <li><strong>public Maitosailio getMaitosailio()</strong> palauttaa navetan maitosailion</li>
    <li><strong>public void asennaLypsyrobotti(Lypsyrobotti lypsyrobotti)</strong> asentaa lypsyrobotin ja kiinnittää sen navetan maitosäiliöön</li>
    <li><strong>public void hoida(Lehma lehma)</strong> lypsää parametrina annetun lehmän lypsyrobotin avulla, metodi heittää poikkeuksen <code>IllegalStateException</code>, jos lypsyrobottia ei ole asennettu</li>
    <li><strong>public void hoida(Collection&lt;Lehma&gt; lehmat)</strong> lypsää parametrina annetut lehmät lypsyrobotin avulla, metodi heittää poikkeuksen <code>IllegalStateException</code>, jos lypsyrobottia ei ole asennettu</li>
    <li><strong>public String toString()</strong> palauttaa navetan sisältämän maitosäiliön tilan</li>
  </ul>

<p><code>Collection</code> on Javan oma rajapinta joka kuvaa kokoelmien käyttäytymistä.  Esimerkiksi luokat <code>ArrayList</code> ja <code>LinkedList</code> toteuttavat rajapinnan <code>Collection</code>. Jokaista <code>Collection</code>-rajapinnan toteuttavaa ilmentymää voi myös iteroida for-each-tyyppisesti.</p>

<p>
Testaa luokkaa <code>Navetta</code> seuraavan ohjelmapätkän avulla.
Älä hermoile luokasta <code>LinkedList</code>, se toimii ulkoapäin katsottuna
kuin <code>ArrayList</code>, mutta sen kapseloima toteutus on hieman erilainen.
Tästä lisää tietorakenteet-kurssilla!
</p>

<pre class="sh_java">
        Navetta navetta = new Navetta(new Maitosailio());
        System.out.println("Navetta: " + navetta);

        Lypsyrobotti robo = new Lypsyrobotti();
        navetta.asennaLypsyrobotti(robo);

        Lehma ammu = new Lehma();
        ammu.eleleTunti();
        ammu.eleleTunti();

        navetta.hoida(ammu);
        System.out.println("Navetta: " + navetta);

        LinkedList&lt;Lehma&gt; lehmaLista = new LinkedList();
        lehmaLista.add(ammu);
        lehmaLista.add(new Lehma());

        for(Lehma lehma: lehmaLista) {
            lehma.eleleTunti();
            lehma.eleleTunti();
        }

        navetta.hoida(lehmaLista);
        System.out.println("Navetta: " + navetta);
</pre>

<p>
Tulostuksen tulee olla esimerkiksi seuraavanlainen:
</p>

<pre>
Navetta: 0.0/2000.0
Navetta: 2.8/2000.0
Navetta: 9.6/2000.0
</pre>

<h4>Maatila</h4>

<p>
Maatilalla on omistaja ja siihen kuuluu navetta sekä joukko lehmiä.
Maatila toteuttaa myös aiemmin nähdyn rajapinnan <code>Eleleva</code>,
jonka metodia <code>eleleTunti()</code>-kutsumalla kaikki maatilaan
liittyvät lehmät elelevät tunnin.  Toteuta luokka maatila siten,
että se toimii seuraavien esimerkkiohjelmien mukaisesti.
</p>

<pre class="sh_java">
        Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
        System.out.println(maatila);

        System.out.println(maatila.getOmistaja() + " on ahkera mies!");
</pre>

<p>
Odotettu tulostus:
</p>

<pre>
Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Ei lehmiä.
Esko on ahkera mies!
</pre>


<pre class="sh_java">
        Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        System.out.println(maatila);
</pre>


<p>
Odotettu tulostus:
</p>

<pre>
Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Lehmät:
        Naatti 0.0/19.0
        Hilke 0.0/30.0
        Sylkki 0.0/29.0
</pre>

<pre class="sh_java">
        Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));

        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());

        maatila.eleleTunti();
        maatila.eleleTunti();
</pre>

<p>
Odotettu tulostus:
</p>

<pre>
Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Lehmät:
        Heluna 2.0/17.0
        Rima 3.0/32.0
        Ilo 3.0/25.0
</pre>

<pre class="sh_java">
        Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
        Lypsyrobotti robo = new Lypsyrobotti();
        maatila.asennaNavettaanLypsyrobotti(robo);

        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());

        maatila.eleleTunti();
        maatila.eleleTunti();

        maatila.hoidaLehmat();

        System.out.println(maatila);
</pre>

<p>
Odotettu tulostus:
</p>

<pre>
Maatilan omistaja: Esko
Navetan maitosäiliö: 18.0/2000.0
Lehmät:
        Hilke 0.0/30.0
        Sylkki 0.0/35.0
        Hento 0.0/34.0
</pre>
</div>


<h3>Abstrakti luokka</h3>

        <p>Abstrakti luokka yhdistää rajapintoja ja perintää. Niistä ei voi tehdä ilmentymiä, vaan ilmentymät tehdään tehdään abstraktin luokan aliluokista.  Abstrakti luokka voi sisältää sekä normaaleja metodeja, joissa on metodirunko, että abstrakteja metodeja, jotka sisältävät ainoastaan metodimäärittelyn. Abstraktien metodien toteutus jätetään perivän luokan vastuulle. Yleisesti ajatellen abstrakteja luokkia käytetään esimerkiksi kun abstraktin luokan kuvaama käsite ei ole selkeä itsenäinen käsite. Tällöin siitä ei tule pystyä tekemään ilmentymiä. </p>

        <p>Sekä abstraktin luokan että abstraktien metodien määrittelyssä käytetään avainsanaa <code>abstract</code>. Abstrakti luokka määritellään lauseella <code>public abstract class <em>LuokanNimi</em></code>, abstrakti metodi taas lauseella <code>public abstract <em>palautustyyppi</em> <em>metodinNimi</em></code>. Pohditaan seuraavaa abstraktia luokkaa <code>Toiminto</code>, joka tarjoaa rungon toiminnoille ja niiden suorittamiselle.</p>

<pre class="sh_java">
public abstract class Toiminto {

    private String name;

    public Toiminto(String name) {
        this.name = nimi;
    }

    public String getName() {
        return this.name;
    }

    public abstract void suorita(Scanner lukija);
}
</pre>

        <p>Abstrakti luokka <code>Toiminto</code> toimii runkona erilaisten toimintojen toteuttamiseen. Esimerkiksi pluslaskun voi toteuttaa perimällä luokka <code>Toiminto</code> seuraavasti.</p>

<pre class="sh_java">
public class Pluslasku extends Toiminto {

    public Pluslasku() {
        super("Pluslasku");
    }

    @Override
    public void suorita(Scanner lukija) {
        System.out.print("Anna ensimmäinen luku: ");
        int eka = Integer.parseInt(reader.nextLine());
        System.out.print("Anna toinen luku: ");
        int toka = Integer.parseInt(reader.nextLine());

        System.out.println("Lukujen summa on " + (eka + toka));
    }
}
</pre>

        <p>Koska kaikki <code>Toiminto</code>-luokan perivät luokat ovat myös tyyppiä toiminto, voimme rakentaa käyttöliittymän <code>Toiminto</code>-tyyppisten muuttujien varaan. Seuraava luokka <code>Kayttoliittyma</code> sisaltaa listan toimintoja ja lukijan. Toimintoja voi lisätä käyttöliittymään dynaamisesti.</p>

<pre class="sh_java">
public class Kayttoliittyma {

    private Scanner lukija;
    private List&lt;Toiminto&gt; toiminnot;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
        this.toiminnot = new ArrayList&lt;Toiminto&gt;();
    }

    public void lisaaToiminto(Toiminto toiminto) {
        this.toiminnot.add(toiminto);
    }

    public void kaynnista() {
        while (true) {
            tulostaToiminnot();
            System.out.println("Valinta: ");

            String valinta = this.reader.nextLine();
            if (valinta.equals("0")) {
                break;
            }

            suoritaToiminto(valinta);
            System.out.println();
        }
    }

    private void tulostaToiminnot() {
        System.out.println("\t0: Lopeta");
        for (int i = 0; i < this.toiminnot.size(); i++) {
            String toiminnonNimi = this.toiminnot.get(i).getName();
            System.out.println("\t" + (i + 1) + ": " + toiminnonNimi);
        }
    }

    private void suoritaToiminto(String valinta) {
        int toiminto = Integer.parseInt(valinta);

        Toiminto valittu = this.toiminnot.get(toiminto - 1);
        valittu.suorita(lukija);
    }
}
</pre>

        <p>Käyttöliittymä toimii seuraavasti:</p>

<pre class="sh_java">
        Kayttoliittyma kayttolittyma = new Kayttoliittyma(new Scanner(System.in));
        kayttolittyma.lisaaToiminto(new Pluslasku());

        kayttolittyma.kaynnista();
</pre>

<pre>
Toiminnot:
        0: Lopeta
        1: Pluslasku
Valinta: <font color="red">1</font>
Anna ensimmäinen luku: <font color="red">8</font>
Anna toinen luku: <font color="red">12</font>
Lukujen summa on 20

Toiminnot:
        0: Lopeta
        1: Pluslasku
Valinta: <font color="red">0</font>
</pre>

        <p>Rajapintojen ja abstraktien luokkien ero on siinä, että abstraktit luokat tarjoavat enemmän rakennetta ohjelmaan. Koska abstrakteihin luokkiin voidaan määritellä toiminnallisuutta, voidaan niitä käyttää esimerkiksi oletustoiminnallisuuden määrittelyyn. Yllä käyttöliittymä käytti abstraktissa luokassa määriteltyä toiminnan nimen tallentamista.</p>


<div class="tehtavat">
  <h3>Erilaisia laatikoita</h3>

  <p>Tehtäväpohjan mukana tulee luokat <code>Tavara</code> ja <code>Laatikko</code>. Luokka <code>Laatikko</code> on abstrakti luokka, jossa useamman tavaran lisääminen on toteutettu siten, että kutsutaan aina <code>lisaa</code>-metodia. Yhden tavaran lisäämiseen tarkoitettu metodi <code>lisaa</code> on abstrakti, joten jokaisen <code>Laatikko</code>-luokan perivän laatikon tulee toteuttaa se. Tehtävänäsi on muokata luokkaa <code>Tavara</code> ja toteuttaa muutamia erilaisia laatikoita luokan <code>Laatikko</code> pohjalta.</p>

  <p>Lisää kaikki uudet luokat pakkaukseen <code>laatikot</code>.</p>


<pre class="sh_java">
package laatikot;

import java.util.Collection;

public abstract class Laatikko {

    public abstract void lisaa(Tavara tavara);

    public void lisaa(Collection&lt;Tavara&gt; tavarat) {
        for (Tavara tavara : tavarat) {
            lisaa(tavara);
        }
    }

    public abstract boolean onkoLaatikossa(Tavara tavara);
}
</pre>

<h4>Tavaran muokkaus</h4>

  <p>Lisää <code>Tavara</code>-luokan konstruktoriin tarkistus, jossa tarkistetaan että tavaran paino ei ole koskaan negatiivinen (paino 0 hyväksytään). Jos paino on negatiivinen, tulee konstruktorin heittää <code>IllegalArgumentException</code>-poikkeus. Toteuta <code>Tavara</code>-luokalle myös metodit <code>equals</code> ja <code>hashCode</code>, joiden avulla  pääset hyödyntämään erilaisten listojen ja kokoelmien <code>contains</code>-metodia. Toteuta metodit siten, että Tavara-luokan oliomuuttujan <code>paino</code> arvolla ei ole väliä. <em>Voit hyvin hyödyntää NetBeansin tarjoamaa toiminnallisuutta equalsin ja hashCoden toteuttamiseen.</em></p>

<h4>Maksimipainollinen laatikko</h4>

  <p>Toteuta pakkaukseen <code>laatikot</code> luokka <code>MaksimipainollinenLaatikko</code>, joka perii luokan <code>Laatikko</code>. Maksimipainollisella laatikolla on konstruktori <code>public MaksimipainollinenLaatikko(int maksimipaino)</code>, joka määrittelee laatikon maksimipainon. Maksimipainolliseen laatikkoon voi lisätä tavaraa jos ja vain jos tavaran lisääminen ei ylitä laatikon maksimipainoa.</p>

<pre class="sh_java">
        MaksimipainollinenLaatikko kahviLaatikko = new MaksimipainollinenLaatikko(10);
        kahviLaatikko.lisaa(new Tavara("Saludo", 5));
        kahviLaatikko.lisaa(new Tavara("Pirkka", 5));
        kahviLaatikko.lisaa(new Tavara("Kopi Luwak", 5));

        System.out.println(kahviLaatikko.onkoLaatikossa(new Tavara("Saludo")));
        System.out.println(kahviLaatikko.onkoLaatikossa(new Tavara("Pirkka")));
        System.out.println(kahviLaatikko.onkoLaatikossa(new Tavara("Kopi Luwak")));
</pre>

<pre>
true
true
false
</pre>

<h4>Yhden tavaran laatikko ja Hukkaava laatikko</h4>

        <p>Toteuta seuraavaksi pakkaukseen <code>laatikot</code> luokka <code>YhdenTavaranLaatikko</code>, joka perii luokan <code>Laatikko</code>. Yhden tavaran laatikolla on konstruktori <code>public YhdenTavaranLaatikko()</code>, ja siihen mahtuu tasan yksi tavara. Jos tavara on jo laatikossa sitä ei tule vaihtaa. Laatikkoon lisättävän tavaran painolla ei ole väliä.</p>

<pre class="sh_java">
        YhdenTavaranLaatikko laatikko = new YhdenTavaranLaatikko();
        laatikko.lisaa(new Tavara("Saludo", 5));
        laatikko.lisaa(new Tavara("Pirkka", 5));

        System.out.println(laatikko.onkoLaatikossa(new Tavara("Saludo")));
        System.out.println(laatikko.onkoLaatikossa(new Tavara("Pirkka")));
</pre>

<pre>
true
false
</pre>


        <p>Toteuta seuraavaksi pakkaukseen <code>laatikot</code> luokka <code>HukkaavaLaatikko</code>, joka perii luokan <code>Laatikko</code>. Hukkaavalla laatikolla on konstruktori <code>public HukkaavaLaatikko()</code>. Hukkaavaan laatikkoon voi lisätä kaikki tavarat, mutta tavaroita ei löydy niitä etsittäessä. Laatikkoon lisäämisen tulee siis aina onnistua, mutta metodin <code>onkoLaatikossa</code> kutsumisen tulee aina palauttaa false.</p>

<pre class="sh_java">
        HukkaavaLaatikko laatikko = new HukkaavaLaatikko();
        laatikko.lisaa(new Tavara("Saludo", 5));
        laatikko.lisaa(new Tavara("Pirkka", 5));

        System.out.println(laatikko.onkoLaatikossa(new Tavara("Saludo")));
        System.out.println(laatikko.onkoLaatikossa(new Tavara("Pirkka")));
</pre>

<pre>
false
false
</pre>


</div>

<h3>Huomio olioiden poistamisesta ArrayListista</h3>

<p>Seuraavassa tehtävässä saatat joutua tilanteeseen, jossa haluat poistaa ArrayListiä läpikäydessäsi osan listan olioista:</p>

<pre class="sh_java">
   // joissain määritelty seuraavasti:
   // ArrayList&ltOlio&gt lista = new ... 

   for ( Olio olio : lista ) {
      if ( tarvitseePoistaa(olio) ) {
         lista.remove(olio);
      }
   }
</pre>

<p>Ratkaisu ei toimi ja aiheuttaa poikkeuksen <code>ConcurrentModificationException</code>, sillä listaa <em>foreach</em>-tyylillä läpikäydessä listaa ei saa muokata. Palaamme aiheeseen hieman tarkemmin viikolla 6. Jos törmäät tilanteeseen, voit hoitaa sen esim. seuraavasti:</p>

<pre class="sh_java">
   // joissain määritelty seuraavasti:
   // ArrayList&ltOlio&gt lista = new ... 

   ArrayList&ltOlio&gt poistettavat = new ArrayList&ltOlio&gt();

   for ( Olio olio : lista ) {
      if ( tarvitseePoistaa(olio) ) {
         poistattavat.add(olio);
      }
   }

   lista.removeAll(poistettavat);
</pre>

<p>Eli poistettavat oliot kerätään listan läpikäyntinä erilliselle listalle ja poisto-operaatio suoritetaan vasta listan läpikäynnin jälkeen.</p>

<div class="tehtavat">

<h3>Luola</h3>


  <p><em>Tämä tehtävä on neljän tehtäväpisteen arvoinen.</em> Huom! Toteuta kaikki toiminnallisuus pakkaukseen <code>luola</code>.</p>

<p><b>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. Älä käytä luokkien nimissä skandeja. Älä myöskään käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</b></p>


<p>Tässä tehtävässä pääset toteuttamaan luolapelin. Pelissä pelaaja on luolassa hirviöitten kanssa. Pelaajan tehtävänä on ehtiä tallata kaikki hirviöt ennen kuin hänen lampustaan loppuu virta ja hirviöt pääsevät pimeän turvin syömään hänet. Pelaaja voi nähdä hirviöiden sijainnit välkäyttämällä lamppua, jonka jälkeen hänen on liikuttava sokkona ennen seuraavaa välkäytystä. Pelaaja voi kulkea monta askelta yhden siirron aikana.</p>

<p>Pelitilanne eli luola, pelaaja ja hirviöt esitetään pelaajalle tekstimuotoisesti. Tulostuksen ensimmäinen rivi kertoo jäljellä olevien siirtojen (eli lampun jäljellä olevan virran) määrän. Virran määrää seuraa pelaajan ja hirviöitten sijainnit, joiden jälkeen on pelitilanteesta piirretty kartta. Alla olevassa esimerkissä näet pelaajan (<code>@</code>) ja kolme hirviötä (<code>h</code>).  Alla olevassa esimerkissä pelaajalla on virtaa neljääntoista siirtoon.</p>

<pre>
14

@ 1 2
h 6 1
h 7 3
h 12 2

.................
......h..........
.@.........h.....
.......h.........
</pre>

<p>Yllä olevassa esimerkissä virtaa on 14 välkäytykseen. Pelaaja <code>@</code> sijatsee koordinaatissa <code>1 2</code>. Huomaa että koordinaatit lasketaan aina pelialueen vasemmasta ylälaidasta lähtien. Alla olevassa kartassa merkki <code>X</code> on koordinaatissa <code>0 0</code>, <code>Y</code> koordinaatissa <code>2 0</code> ja <code>Z</code> koordinaatissa <code>0 2</code>.</p>

<pre>
X.Y..............
.................
Z................
.................
</pre>



<p>Käyttäjä voi liikkua antamalla sarjan komentoja ja painamalla rivinvaihtoa. Komennot ovat:</p>
<ul>
  <li><code>w</code> liiku ylöspäin</li>
  <li><code>s</code> liiku alaspäin</li>
  <li><code>a</code> liiku vasemmalle</li>
  <li><code>d</code> liiku oikealle</li>
</ul>

<p>Kun käyttäjän antamat komennot on suoritettu (niitä voi olla useampi), piirretään uusi pelitilanne. Lampun virta vähenee yhdellä aina kun uusi pelitilanne piirretään. Jos virta menee nollaan, peli loppuu ja ruudulle tulostetaan teksti <code>HÄVISIT</code></p>

<p>Hirviöt liikkuvat pelissä satunnaisesti, yhden askeleen jokaista pelaajan askelta kohti. Jos pelaaja ja hirviö osuvat samaan ruutuun (vaikka vain tilapäisesti), hirviö tuhoutuu. Jos hirviö yrittää siirtyä pelilaudalta ulos tai ruutuun jossa on jo hirviö, jätetään siirto suorittamatta. Kun kaikki hirviöt on tuhottu, peli loppuu ja tulostetaan <code>VOITIT</code>.</p>

<p>Testaamisen helpottamiseksi tee peliisi luokka <code>Luola</code>, jolla on  :</p>

<p>
  <ul>
    <li>konstruktori <strong><code>public Luola(int leveys, int korkeus, int hirvioita, int siirtoja, boolean hirviotLiikkuvat)</code></strong>
      <p>values <code>leveys</code> ja <code>korkeus</code> antavat luolan koon (se on aina neliskulmainen), <code>hirvioita</code> antaa hirviöiden lukumäärän alussa (hirviöiden sijainnin voi arpoa), <code>siirtoja</code> antaa siirtojen lukumäärän alussa ja jos <code>hirviotLiikkuvat</code> on <code>false</code>, hirviöt eivät liiku.</p></li>
    <li>metodi <strong><code>public void run()</code></strong> joka käynnistää pelin</li>
  </ul>
</p>

<p><em>Huom!</em> pelaajan tulee aloittaa sijainnista 0,0!</p>
<p><em>Huom!</em> jos pelaaja tai hirviö koittaa liikkua ulos luolasta
  tai kaksi hirviötä koittaa liikkua samaan ruutuun, ei liikettä tule
  tapahtua!</p>
</ul>

  <p>Alla vielä selkeyden vuoksi vielä esimerkkipeli:</p>

<pre>
14

@ 0 0
h 1 2
h 7 8
h 7 5
h 8 0
h 2 9

@.......h.
..........
.h........
..........
..........
.......h..
..........
..........
.......h..
..h.......

<font color="red">ssd</font>
13

@ 1 2
h 8 8
h 7 4
h 8 3
h 1 8

..........
..........
.@........
........h.
.......h..
..........
..........
..........
.h......h.
..........

<font color="red">ssss</font>
12

@ 1 6
h 6 9
h 6 5
h 8 3

..........
..........
..........
........h.
..........
......h...
.@........
..........
..........
......h...

<font color="red">dd</font>
11

@ 3 6
h 5 9
h 6 7
h 8 1

..........
........h.
..........
..........
..........
..........
...@......
......h...
..........
.....h....

<font color="red">ddds</font>
10

@ 6 7
h 6 6
h 5 0

.....h....
..........
..........
..........
..........
..........
......h...
......@...
..........
..........

<font color="red">w</font>
9

@ 6 6
h 4 0

....h.....
..........
..........
..........
..........
..........
......@...
..........
..........
..........

<font color="red">www</font>
8

@ 6 3
h 4 0

....h.....
..........
..........
......@...
..........
..........
..........
..........
..........
..........

<font color="red">aa</font>
7

@ 4 3
h 4 2

..........
..........
....h.....
....@.....
..........
..........
..........
..........
..........
..........

<font color="red">w</font>
VOITIT
</pre>


</div>

<!-- BEGIN SNIP -->

<div class="tyhja"></div>

<div class="viikkoraja">Viikko 5</div>

<h2 id="tiedostostoon_kirjoitus">Tiedostoon kirjoittaminen</h3>

<p>Luvussa 15 opimme, että tekstitiedostojen lukeminen onnistuu <code>Scanner</code>- ja <code>File</code>-luokkien avulla.
Luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/java/io/FileWriter.html">FileWriter</a></code> tarjoaa toiminnallisuuden tiedostoon kirjoittamiseen. Luokan <code>FileWriter</code> konstruktorille annetaan parametrina kohdetiedoston sijaintia kuvaava characterString.</p>

<pre class="sh_java">
        FileWriter kirjoittaja = new FileWriter("tiedosto.txt");
        kirjoittaja.write("Hei tiedosto!\n"); // rivinvaihto tulee myös kirjoittaa tiedostoon!
        kirjoittaja.write("Lisää tekstiä\n");
        kirjoittaja.write("Ja vielä lisää");
        kirjoittaja.close(); // sulkemiskutsu sulkee tiedoston ja varmistaa että kirjoitettu teksti menee tiedostoon
</pre>

    <p>Esimerkissä kirjoitetaan tiedostoon "tiedosto.txt" characterString "Hei tiedosto!", jota seuraa rivinvaihto, ja vielä hieman lisää tekstiä. Huomaa että tiedostoon kirjoitettaessa metodi <code>write</code> ei lisää rivinvaihtoja, vaan ne tulee lisätä itse.</p>

    <p>Sekä <code>FileWriter</code>-luokan konstruktori että <code>write</code>-metodi heittää mahdollisesti poikkeuksen, joka tulee joko käsitellä tai siirtää kutsuvan metodin vastuulle. Metodi, jolle annetaan parametrina kirjoitettavan tiedoston nimi ja kirjoitettava sisältö voisi näyttää seuraavalta.</p>

<pre class="sh_java">
public class Tallentaja {

    public void kirjoitaTiedostoon(String tiedostonNimi, String teksti) throws Exception {
        FileWriter kirjoittaja = new FileWriter(tiedostonNimi);
        kirjoittaja.write(teksti);
        kirjoittaja.close();
    }
}
</pre>

    <p>Yllä olevassa <code>kirjoitaTiedostoon</code>-metodissa luodaan ensin <code>FileWriter</code>-olio, joka kirjoittaa parametrina annetussa sijainnissa sijaitsevaan tiedostoon <code>tiedostonNimi</code>. Tämän jälkeen kirjoitetaan tiedostoon <code>write</code>-metodilla. Konstruktorin ja <code>write</code>-metodin mahdollisesti heittämä poikkeus tulee käsitellä joko <code>try-catch</code>-lohkolla tai siirtämällä poikkeuksen käsittely vastuuta eteenpäin. Metodissa <code>kirjoitaTiedostoon</code> käsittelyvastuu on siirretty eteenpäin.</p>

    <p>Luodaan <code>main</code>-metodi jossa kutsutaan <code>Tallentaja</code>-olion <code>kirjoitaTiedostoon</code>-metodia. Poikkeusta ei ole pakko käsitellä <code>main</code>-metodissakaan, vaan se voi ilmoittaa heittävänsä mahdollisesti poikkeuksen määrittelyllä <code>throws Exception</code>.</p>

<pre class="sh_java">
    public static void main(String[] args) throws Exception {
        Tallentaja tallentaja = new Tallentaja();
        tallentaja.kirjoitaTiedostoon("paivakirja.txt", "Rakas päiväkirja, tänään oli kiva päivä.");
    }
</pre>

    <p>Yllä olevaa metodia kutsuttaessa luodaan tiedosto "paivakirja.txt" johon kirjoitetaan teksti "Rakas päiväkirja, tänään oli kiva päivä.". Jos tiedosto on jo olemassa, pyyhkiytyy vanhan tiedoston sisältö uutta kirjoittaessa. Metodilla <code>append()</code> voidaan lisätä olemassaolevan tiedoston perään tekstiä, jolloin olemassaolevaa  tekstiä ei poisteta. Lisätään <code>Tallentaja</code>-luokalle metodi <code>lisaaTiedostoon()</code>, joka lisää parametrina annetun tekstin tiedoston loppuun.</p>

<pre class="sh_java">
public class Tallentaja {
    public void kirjoitaTiedostoon(String tiedostonNimi, String teksti) throws Exception {
        FileWriter kirjoittaja = new FileWriter(tiedostonNimi);
        kirjoittaja.write(teksti);
        kirjoittaja.close();
    }

    public void lisaaTiedostoon(String tiedostonNimi, String teksti) throws Exception {
        FileWriter kirjoittaja = new FileWriter(tiedostonNimi);
        kirjoittaja.append(teksti);
        kirjoittaja.close();
    }
}
</pre>

    <p>Useimmiten tiedoston perään metodilla <code>append</code> kirjoittamisen sijasta on helpompi kirjoittaa koko tiedosto uudelleen.</p>

<div class="tehtavat">

<NEXTWEEK></NEXTWEEK>
<h3>Tiedostonkäsittelijä</h3>

<p>Saat tehtävärungon mukana luokan <code>Tiedostonkasittelija</code> joka sisältää metodirungot tiedoston lukemista ja tiedostoon kirjoittamista varten.</p>

<h4>Tiedoston lukeminen</h4>

<p>Täydennä metodi <code>public ArrayList&lt;String&gt; lue(String tiedosto)</code> sellaiseksi, että se palauttaa parametrina annetun tekstitiedoston sisältämät rivit ArrayList:ina siten, että tiedoston jokainen rivi on omana characterStringnaan listalla.
</p>

<p>Projektissa on testaamista varten kaksi tekstitiedostoa <code>src/koesyote1.txt</code> ja <code>src/koesyote2.txt</code>. Metodia on tarjoitus käyttää seuraavalla tavalla: 
</p>

<pre class="sh_java">
    public static void main(String[] args) throws FileNotFoundException, IOException {
        TiedostonKasittelija t = new TiedostonKasittelija();

        for (String rivi : t.lue("src/koesyote1.txt")) {
            System.out.println(rivi);
        }
    }
</pre>

<p>Tulostuksen pitäisi olla</p>

<pre>
eka
toka
</pre>


<h4>Rivin kirjoittaminen tiedostoon</h4>

<p>Täydennä projektipohjan mukana tuleva metodi <code>public void tallenna(String tiedosto, String teksti)</code>  sellaiseksi, että se tallentaa ensimmäisen parametrin määrittelemään tiedostoon toisena parametrina annetun characterStringn. Jos tiedosto on jo olemassa, kirjoitetaan vanhan version päälle.
</p>


<h4>Rivin kirjoittaminen tiedostoo</h4>

<p>Täydennä projektipohjan mukana tuleva metodi <code>public void tallenna(String tiedosto, ArrayList<String> tekstit)</code> sellaiseksi, että se tallentaa ensimmäisen parametrin määrittelemään tiedostoon toisena parametrina annetun listan siten, että jokainen characterString tulee omalle rivilleen.  Jos tiedosto on jo olemassa, kirjoitetaan vanhan version päälle.
</p>

    <h3>Muistava kahteen suuntaan kääntävä sanakirja</h3>

    <p>Tässä tehtävässä laajennetaan aiemmin toteutettua sanakirjaa siten, että sanat voidaan lukea tiedostosta ja kirjoittaa tiedostoon. Sanakirjan tulee myös osata kääntää molempiin suuntiin, suomesta vieraaseen kieleen sekä toiseen suuntaan (tehtävässä oletetaan hieman epärealistisesti, että suomen kielessä ja vieraassa kielessä ei ole yhtään samalla tavalla kirjoitettavaa sanaa). Tehtävänäsi on luoda sanakirja luokkaan <code>MuistavaSanakirja</code> Toteuta luokka pakkaukseen <code>sanakirja</code>.</p>

<h4>Muistiton perustoiminnallisuus</h4>

<p>Tee sanakirjalle parametriton konstruktori sekä metodit:</p>

 <ul>
        <li><code>public void lisaa(String sana, String kaannos)</code></li>lisää sanan sanakirjaan. Jokaisella sanalla on vain yksi käännös, jos sama sana lisätään uudelleen, ei tapahdu mitään.<br/>
        <li><code>public String kaanna(String sana)</code></li> palauttaa käännöksen annetulle sanalle, jos sanaa ei tunneta, palautetaan null<br/>
 </ul>

<p>Sanakirjan tulee tässä vaiheessa toimia seuraavasti:</p>

<pre class="sh_java">
MuistavaSanakirja sanakirja = new MuistavaSanakirja();
sanakirja.lisaa("apina", "monkey");
sanakirja.lisaa("banaani", "banana");
sanakirja.lisaa("apina", "apfe");

System.out.println( sanakirja.kaanna("apina") );
System.out.println( sanakirja.kaanna("monkey") );
System.out.println( sanakirja.kaanna("ohjelmointi") );
System.out.println( sanakirja.kaanna("banana") );
</pre>

<p>Tulostuu</p>

<pre>
monkey
apina
null
banana
</pre>

<p>Kuten tulostuksesta ilmenee, käännöksen lisäämisen jälkeen sanakirja osaa tehdä käännöksen molempiin suuntiin.</p>

<h4>Sanojen poistaminen</h4>

<p>Lisää sanakirjalle metodi <code>public void poista(String sana)</code></li> joka poistaa annetun sanan ja sen käännöksen sanakirjasta.</p>

<p>Sanakirjan tulee tässä vaiheessa toimia seuraavasti:</p>

<pre class="sh_java">
MuistavaSanakirja sanakirja = new MuistavaSanakirja();
sanakirja.lisaa("apina", "monkey");
sanakirja.lisaa("banaani", "banana");
sanakirja.lisaa("ohjelmointi", "programming");
sanakirja.poista("apina");
sanakirja.poista("banana");

System.out.println( sanakirja.kaanna("apina") );
System.out.println( sanakirja.kaanna("monkey") );
System.out.println( sanakirja.kaanna("banana") );
System.out.println( sanakirja.kaanna("banaani") );
System.out.println( sanakirja.kaanna("ohjelmointi") );
</pre>

<p>Tulostuu</p>

<pre>
null
null
null
null
programming
</pre>

<p>Poisto siis toimii myös molemmin puolin, alkuperäisen sanan tai sen käännöksen poistamalla, poistuu sanakirjasta tieto molempien suuntien käännöksestä. </p>



<h4>Lataaminen tiedostosta</h4>

<p>Tee sanakirjalle konstruktori <code>public Sanakirja(String tiedosto)</code>  ja metodi <code>public boolean lataa()</code>, joka lataa sanakirjan konstruktorin parametrina annetun nimisestä tiedostosta. Jos tiedoston avaaminen tai lukeminen ei onnistu, palauttaa metodi false ja muuten true.</p>

<p>Sanakirjatiedostossa yksi rivi sisältää sanan ja sen käännöksen merkillä ":" erotettuna. Tehtäväpohjan mukana tuleva testaamiseen tarkoitettu sanakirjatiedosto <code>src/sanat.txt</code> on sisällöltään seuraava: </p>

<pre>
apina:monkey
alla oleva:below
olut:beer
</pre>

<p>Lue sanakirjatiedosto rivi riviltä lukijan metodilla <code>nextLine</code>. Voit pilkkoa rivin String metodilla <code>split</code> seuraavasti:

<pre class="sh_java">
Scanner tiedostonLukija = new ...
while ( tiedostonreader.hasNextLine() ){
    String rivi = tiedostonreader.nextLine();
    String[] osat = rivi.split(":");   // pilkotaan rivi :-merkkien kohdalta
    
    System.out.println( osat[0] );     // ennen :-merkkiä ollut osa rivistä
    System.out.println( osat[1] );     // :-merkin jälkeen ollut osa rivistä
}
</pre>

<p>Sanakirjaa käytetään seuraavasti:</p>

<pre class="sh_java">
MuistavaSanakirja sanakirja = new MuistavaSanakirja("src/sanat.txt");
sanakirja.lataa();

System.out.println( sanakirja.kaanna("apina") );
System.out.println( sanakirja.kaanna("ohjelmointi") );
System.out.println( sanakirja.kaanna("alla oleva") );
</pre>

<p>Tulostuu</p>

<pre>
monkey
null
below
</pre>


<h4>Tallennus tiedostoon</h4>

    <p>Tee sanakirjalle metodi <code>public boolean talleta()</code>, jota kutsuttaessa sanakirjan sisältö kirjoitetaan konstruktorin parametrina annetun nimiseen tiedostoon. Jos tallennus ei onnistu, palauttaa metodi false ja muuten true. Sanakirjatiedostot tulee tallentaa ylläesitellyssä muodossa, eli ohjelman on osattava lukea itse kirjottamiaan tiedostoja.</p>

<p><strong>Huom:</strong> vaikka sanakirja osaa käännökset molempiin suuntiin, ei sanakirjatiedostoon tule kirjoittaa kuin toinen suunta. Eli jos sanakirja tietää esim. käännöksen <em>tietokone = computer</em>, tulee rivi:</p>

<pre>
tietokone:computer
</pre>

<p>tai rivi</p>

<pre>
computer:tietokone
</pre>

<p>mutta ei molempia!</p>

    <p>Talletus kannattanee hoitaa siten, että koko käännöslista kirjoitetaan uudelleen vanhan tiedoston päälle, eli materiaalissa esiteltyä <code>append</code>-komentoa ei kannata käyttää.</p>

<p>Sanakirjan lopullista versiota on tarkoitus käyttää  seuraavasti:</p>

<pre class="sh_java">
MuistavaSanakirja sanakirja = new MuistavaSanakirja("src/sanat.txt");
sanakirja.lataa();

// käytä sanakirjaa

sanakirja.tallenna();
</pre>

<p>Eli käytön aluksi ladataan sanakirja tiedostosta ja lopussa tallennetaan se takaisin tiedostoon jotta sanakirjaan tehdyt muutokset pysyvät voimassa seuraavallekin käynnistyskerralle.</p>
</div>



<h2 id="kalit">Käyttöliittymät</h2>

<p><hr/></p>
<p><big><strong><strong>Huom!</strong> Osa käyttöliittymätehtävien testeistä avaa käyttöliittymän ja käyttää hiirtäsi käyttöliittymäkomponenttien klikkailuun. Kun suoritat käyttöliittymätehtävien testejä, älä käytä hiirtäsi!</strong></big></p>
<p><hr/></p>

<p>Ohjelmamme ovat tähän mennessä koostuneet lähinnä sovelluslogiikasta ja sovelluslogiikkaa käyttävästä tekstikäyttöliittymästä. Muutamissa tehtävissä on ollut myös graafinen käyttöliittymä, mutta ne on yleensä luotu puolestamme. Tutustutaan seuraavaksi graafisten käyttöliittymien luomiseen Javalla.</p>

<p>Käyttöliittymät ovat ikkunoita, jotka sisältävät erilaisia osia kuten nappeja, tekstikenttiä ja valikkoja. Käyttöliittymien ohjelmoinnissa käytetään Javan <a href="http://docs.oracle.com/javase/tutorial/ui/features/components.html" target="_blank">Swing</a>-komponenttikirjastoa, joka tarjoaa luokkia käyttöliittymäkomponenttien luomiseen ja käsittelyyn.</p>

<p>Käyttöliittymien peruselementti on luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JFrame.html" target="_blank">JFrame</a></code>, jonka sisältämään komponenttiosioon käyttöliittymäkomponentit luodaan. Oikeaoppisesti luodut käyttöliittymät toteuttavat rajapinnan <code>Runnable</code>, ja ne käynnistetään pääohjelmasta. Käytämme kurssilla seuraavanlaista käyttöliittymärunkoa:</p>

<pre class="sh_java">
import java.awt.Container;
import java.awt.Dimension;
import javax.swing.JFrame;
import javax.swing.WindowConstants;

public class Kayttoliittyma implements Runnable {

    private JFrame frame;

    public Kayttoliittyma() {
    }

    @Override
    public void run() {
        frame = new JFrame("Otsikko");
        frame.setPreferredSize(new Dimension(200, 100));

        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        luoKomponentit(frame.getContentPane());

        frame.pack();
        frame.setVisible(true);
    }

    private void luoKomponentit(Container container) {
    }

    public JFrame getFrame() {
        return frame;
    }
}
</pre>

<p>Tarkastellaan ylläolevan käyttöliittymäluokan koodia hieman tarkemmin.</p>

<pre class="sh_java">
public class Kayttoliittyma implements Runnable {
</pre>

<p>Luokka <code>Kayttoliittyma</code> toteuttaa Javan rajapinnan <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Runnable.html" target="_blank">Runnable</a>, joka tarjoaa mahdollisuuden säikeistettyyn ohjelman suorittamiseen. Säikeistetyllä suorittamisella voidaan suorittaa useita ohjelman osia rinnakkain. Emme tutustu säikeisiin tarkemmin, lisää tietoa säikeistä tulee muunmuassa toisen vuoden kurssilla <em>Käyttöjärjestelmät</em>.</p>

<pre class="sh_java">
    private JFrame frame;
</pre>

<p>Käyttöliittymä sisältää oliomuuttujana <code>JFrame</code>-olion, joka on näkyvän käyttöliittymän pohjaelementti. Kaikki käyttöliittymäkomponentit lisätään <code>JFrame</code>-olion sisältämään komponenttialueeseen. Huomaa että <strong>oliomuuttujia ei saa alustaa metodien ulkopuolella</strong>. Esimerkiksi oliomuuttujan <code>JFrame</code> alustus luokkamäärittelyssä <code>"private JFrame frame = new JFrame()"</code> kiertää käyttöliittymäsäikeiden suoritusjärjestyksen, ja voi johtaa ydintuhoon. Tai ohjelmasi kaatumiseen.</p>

<pre class="sh_java">
    @Override
    public void run() {
        frame = new JFrame("Otsikko");
        frame.setPreferredSize(new Dimension(200, 100));

        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        luoKomponentit(frame.getContentPane());

        frame.pack();
        frame.setVisible(true);
    }
</pre>

<p>Rajapinta <code>Runnable</code> määrittelee metodin <code>public void run()</code>, joka jokaisen <code>Runnable</code>-rajapinnan toteuttajan tulee toteuttaa. Metodissa <code>public void run()</code> luodaan ensin uusi JFrame-ikkuna, jonka otsikoksi asetetaan <code>"Otsikko"</code>. Tämän jälkeen asetetaan ikkunan toivotuksi kooksi 200, 100 eli ikkunan leveydeksi tulee 200 pikseliä, korkeudeksi 100 pikseliä. Komento <code>frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</code> kertoo JFrame-oliolle, että käyttöliittymä tulee sulkea kun käyttäjä painaa käyttöliittymässä olevaa ruksia.</p>

<p>Tämän jälkeen kutsutaan luokassa myöhemmin määriteltyä metodia <code>luoKomponentit</code>. Metodille annetaan parametrina <code>JFrame</code>-olion <em><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Container.html" target="_blank">Container</a></em>-olio, johon voi lisätä käyttöliittymäkomponentteja.</em>

<p>Lopuksi kutsutaan metodia <code>frame.pack()</code>, joka asettaa JFrame-olion aiemmin määritellyn kokoiseksi ja järjestää JFrame-olion sisältämän Container-olion sisällä olevat käyttöliittymäkomponentit. Lopuksi kutsutaan metodia <code>frame.setVisible(true)</code>, joka näyttää käyttöliittymän käyttäjälle.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
    }
</pre>

<p>Metodissa <code>luoKomponentit</code> lisätään <code>JFrame</code>-olion sisältämään komponenttialueeseen käyttöliittymäkomponentteja. Esimerkissämme ei ole yhtäkään käyttöliittymäkomponenttia JFrame-ikkunan lisäksi. Luokalla <code>Kayttoliittyma</code> on myös sen käyttöä helpottava metodi <code>getFrame</code>, jolla päästään käsiksi luokan kapseloimaan JFrame-olioon.</em>

<p>Swing-käyttöliittymät käynnistetään <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/SwingUtilities.html" target="_blank">SwingUtilities</a></code>-luokan tarjoaman <code>invokeLater</code>-metodin avulla. Metodi <code>invokeLater</code> saa parametrinaan <code>Runnable</code>-rajapinnan toteuttavan olion. Metodi asettaa <code>Runnable</code>-olion suoritusjonoon, ja kutsuu sitä kun ehtii. Luokan <code>SwingUtilities</code> avulla voimme käynnistää uusia säikeitä tarvittaessa.</p>

<pre class="sh_java">
import javax.swing.SwingUtilities;

public class Main {

    public static void main(String[] args) {
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma();
        SwingUtilities.invokeLater(kayttoliittyma);
    }
}
</pre>


<p>Kun ylläoleva pääohjelmametodi suoritetaan, näemme luokassa <code>Kayttoliittyma</code> määrittellyn käyttöliittymän.</p>

    <p><img src="img-ohja/kali/eka-kali.png"/></p>


<h3>Käyttöliittymäkomponentit</h3>


<p>Käyttöliittymä koostuu taustaikkunan (JFrame) sisältämästä komponenttipohjasta (Container), ja siihen asetetuista käyttöliittymäkomponenteista. Käyttöliittymäkomponentteja ovat erilaiset painikkeet, tekstit ym. Jokaiselle komponentille on oma luokka. Kannattaa tutustua Oraclen visuaalinen kuvasarjaan erilaisista komponenteista osoitteessa <a href="http://docs.oracle.com/javase/tutorial/ui/features/components.html" target="_blank">http://docs.oracle.com/javase/tutorial/ui/features/components.html</a>.</p>

<h4>Teksti</h4>

<p>Tekstin näyttäminen tapahtuu <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JLabel.html" target="_blank">JLabel</a></code>-luokan avulla. Luokka <code>JLabel</code> tarjoaa käyttöliittymäkomponentin, jolle voi asettaa tekstiä ja jonka sisältämää tekstiä voi muokata. Teksti asetetaan joko konstruktorissa tai erillisellä <code>setText</code>-metodilla.</p>

<p>Muokataan käyttöliittymäpohjaamme siten, että siinä näkyy tekstiä. Luodaan uusi JLabel-tekstikomponentti metodissa <code>luoKomponentit</code>. Tämän jälkeen lisätään se <code>JFrame</code>-oliolta saatuun <code>Container</code>-olioon <code>Container</code>-olion <code>add</code>-metodia käyttäen.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        JLabel teksti = new JLabel("Tekstikenttä!");
        container.add(teksti);
    }
</pre>

<p>Kuten yllä olevasta lähdekoodista näemme, JLabel-käyttöliittymäkomponentti tulee näyttämään tekstin <code>"Tekstikenttä!"</code>. Kun suoritamme käyttöliittymän, näemme seuraavanlaisen ikkunan.</p>

    <p><img src="img-ohja/kali/kali-tekstikentta.png"/></p>


<div class="tehtavat">

<h3>Tervehtijä</h3>

<p>Toteuta käyttöliittymä, joka näyttää tekstin "Moi!". Käyttöliittymän (eli JFrame-olion) leveyden tulee olla vähintään 400 ja korkeuden 100 ja otsikkona teksti "Swing on". Tehtävä tulee toteuttaa tehtäväpohjassa tulevaan käyttöliittymärunkoon.  JFrame-olion luominen ja näkyväksi asettamisen tulee tapahtua metodissa <code>run()</code>, tekstikomponentti lisätään käyttöliittymälle metodissa <code>luoKomponentit(Container container)</code>.</p>

<p><strong>HUOM: Käyttöliittymien oliomuuttujia saa alustaa vain metodeissa tai konstruktorissa! Älä alusta oliomuuttujia suoraan määrittelyn yhteydessä.</strong></p>
</div>

<h4>Painikkeet</h4>

<p>Käyttöliittymään saa painikkeita <code>JButton</code>-luokan avulla. JButton-olion lisääminen käyttöliittymään tapahtuu aivan kuin JLabel-olion lisääminen.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        JButton nappi = new JButton("Click!");
        container.add(nappi);
    }
</pre>

    <p><img src="img-ohja/kali/kali-nappi.png"/></p>

<p>Yritetään seuraavaksi lisätä käyttöliittymään sekä tekstiä, että nappi.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        JButton nappi = new JButton("Click!");
        container.add(nappi);
        JLabel teksti = new JLabel("Tekstiä.");
        container.add(teksti);
    }
</pre>

<p>Ohjelmaa suorittaessa näemme seuraavanlaisen käyttöliittymän.</p>

    <p><img src="img-ohja/kali/kali-tarve-asettelulle.png"/></p>

<p>Vain viimeiseksi lisätty käyttöliittymäkomponentti on näkyvillä, eikä ohjelma toimi toivotusti. Mistä tässä oikein on kyse?</p>

<h3>Käyttöliittymäkomponenttien asettelu</h3>

<p>Jokaisella käyttöliittymäkomponentilla on oma sijainti käyttöliittymässä. Komponentin sijainnin määrää käytössä oleva käyttöliittymän asettelija (<em>Layout Manager</em>). Yrittäessämme aiemmin lisätä useampia käyttöliittymäkomponentteja <code>Container</code>-olioon käyttöliittymässä oli vain yksi komponentti näkyvillä. Jokaisessa <code>Container</code>-oliossa on oletuksena käyttöliittymäasettelija <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/BorderLayout.html" target="_blank">BorderLayout</a></code>.</p>

<p>BorderLayout asettelee käyttöliittymäkomponentit viiteen alueeseen: käyttöliittymän keskikohdan lisäksi käytössä on ilmansuunnat. Voimme antaa Container-olion <code>add</code>-metodille ylimääräisenä parametrina lisätoiveen kohdasta, johon haluamme asettaa käyttöliittymäkomponentin. BorderLayout-luokassa on käytössä luokkamuuttujat <code>BorderLayout.NORTH</code>, <code>BorderLayout.EAST</code>, <code>BorderLayout.SOUTH</code>, <code>BorderLayout.WEST</code>, ja <code>BorderLayout.CENTER</code>.</p>

<p>Käytettävä käyttöliittymäasettelija asetetaan <code>Container</code>-oliolle metodin <code>setLayout</code>-parametrina. Metodille <code>add</code> voidaan antaa käyttöliittymäkomponentin lisäksi paikka, johon komponentti lisätään. Alla on esimerkki, jossa jokaiseen BorderLayoutin tarjoamaan paikkaan asetetaan käyttöliittymäkomponentti.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        // seuraava rivi siis ei tässä tilanteessa pakollinen, sillä BorderLayout on JFramessa jokatapauksessa oletuksena
        container.setLayout(new BorderLayout());

        container.add(new JButton("Pohjoinen (North)"), BorderLayout.NORTH);
        container.add(new JButton("Itä (East)"), BorderLayout.EAST);
        container.add(new JButton("Etelä (South)"), BorderLayout.SOUTH);
        container.add(new JButton("Länsi (West)"), BorderLayout.WEST);
        container.add(new JButton("Keski (Center)"), BorderLayout.CENTER);

        container.add(new JButton("Oletuspaikka (Center)"));
    }
</pre>

<p>Huomaa, että nappi <code>"Keski (Center)"</code> ei tule näkymään käyttöliittymässä sillä nappi <code>"Oletuspaikka (Center)"</code> asetetaan oletuksena sen paikalle. Käyttöliittymässäpohjassa yllä oleva koodi näyttää seuraavalta.</p>

    <p><img src="img-ohja/kali/layout-borderlayout.png"/></p>

<p>Kuten käyttöliittymäkomponentteja, myös käyttöliittymän asettelijoita on useita. Oraclella on käyttöliittymäasettelijoihin visuaalinen opas osoitteessa <a href="http://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html" target="_blank">http://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html</a>. Tutustutaan seuraavaksi käyttöliittymäasettelijaan <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/BoxLayout.html" target="_blank">BoxLayout</a></code>.</a>

<h4>BoxLayout</h4>

<p>BoxLayoutia käytettäessä käyttöliittymäkomponentit asetetaan käyttöliittymään joko vaakasuunnassa tai pystysuunnassa. BoxLayoutin konstruktorille annetaan parametrina Container-olio, johon käyttöliittymäkomponentteja ollaan asettamassa, ja käyttöliittymäkomponenttien asettelusuunta. Asettelusuunta on joko <code>BoxLayout.X_AXIS</code>, eli komponentit vaakasuunnassa, tai <code>BoxLayout.Y_AXIS</code>, eli komponentit pystysuunnassa. Toisin kuin BorderLayout-asettelijaa käytettäessä, BoxLayoutilla ei ole rajattua määrää paikkoja. Container-olioon voi siis lisätä niin monta käyttöliittymäkomponenttia kuin haluaa.</p>

<p>Käyttöliittymän asettelu <code>BoxLayout</code>-asettelijaa käyttäen toimii kuten <code>BorderLayout</code>-asettelijan käyttö. Luomme ensin asettelijan, jonka asetamme <code>Container</code>-oliolle sen metodilla <code>setLayout</code>. Tämän jälkeen voimme lisätä käyttöliittymäkomponentteja <code>Container</code>-olion <code>add</code>-metodilla. Emme tarvitse erillistä sijaintia ilmaisevaa parametria. Alla esimerkki vaakasuunnassa asetetuista käyttöliittymäkomponenteista.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.X_AXIS);
        container.setLayout(layout);

        container.add(new JLabel("Eka!"));
        container.add(new JLabel("Toka!"));
        container.add(new JLabel("Kolmas!"));
    }
</pre>

<p><img src="img-ohja/kali/boxlayout-x_axis.png"/></p>

<p>Käyttöliittymäkomponenttien asettelu pystysuunnassa ei vaadi suurta muutosta. Vaihdamme <code>BoxLayout</code>-olion konstruktorille annettavaksi suuntaparametriksi <code>BoxLayout.Y_AXIS</code>.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.Y_AXIS);
        container.setLayout(layout);

        container.add(new JLabel("Eka!"));
        container.add(new JLabel("Toka!"));
        container.add(new JLabel("Kolmas!"));
    }
</pre>

    <p><img src="img-ohja/kali/boxlayout-y_axis.png"/></p>

<p>Käyttöliittymäasettelijoita käyttämällä voimme luoda käyttöliittymiä, joissa käyttöliittymäkomponentit ovat aseteltu sopivasti. Alla on esimerkkikäyttöliittymä, jossa komponentit asetetaan pystysuuntaan. Ensin teksti, ja sitten vaihtoehtoinen valinta. Vaihtoehtoisen valinnan, eli valinnan jossa vain yksi vaihtoehto on aina voimassa, voi tehdä käyttämällä <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/ButtonGroup.html" target="_blank">ButtonGroup</a></code>-ryhmittelijää ja <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JRadioButton.html" target="_blank">JRadioButton</a></code>-painikkeita.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.Y_AXIS);
        container.setLayout(layout);

        container.add(new JLabel("Valitse ruokavalio:"));

        JRadioButton liha = new JRadioButton("Liha");
        JRadioButton kala = new JRadioButton("Kala");

        ButtonGroup buttonGroup = new ButtonGroup();
        buttonGroup.add(liha);
        buttonGroup.add(kala);

        container.add(liha);
        container.add(kala);
    }
</pre>


    <p><img src="img-ohja/kali/buttongroup-ruokavalio.png"/></p>

<div class="tehtavat">

<h3>Kysely</h3>

<p>Toteuta tehtäväpohjaan käyttöliittymä, joka näyttää seuraavalta:</p>

<p><img src="img-ohja/kali/157-kysely.png"/></p>

<p>Käytä käyttöliittymän asettelijana luokkaa <code>BoxLayout</code>, komponentteina luokkia <code>JLabel</code>, <code>JRadioButton</code>, <code>JCheckBox</code> ja <code>JButton</code>.</p>

<p>Käytä <code>ButtonGroup</code>-luokkaa varmistamaan että vaihtoehdot "Siksi" ja "Koska se on kivaa" eivät voi olla valittuina samaan aikaan.</p>

<p>Varmista että käyttöliittymä on niin iso, että käyttäjä voi klikata nappeja muuttamatta sen kokoa. Voit käyttää esimerkiksi leveytenä 200 pikseliä, korkeutena 300 pikseliä.</p>
</div>


<h3>Tapahtumien käsittely</h3>

<p>Tähänastiset graafiset käyttöliittymämme ovatvaikkakin hienoja hieman tylsiä: ne eivät reagoi millään tavalla käyttöliittymässä tehtyihin tapahtumiin. Reagoimattomuus ei johdu käyttöliittymäkomponenteista, vaan siitä että emme ole lisänneet käyttöliittymäkomponentteihin tapahtumia käsitteleviä kuuntelijoita.</p>

<p>Tapahtumankuuntelijat <em>kuuntelevat</em> käyttöliittymäkomponentteja joihin ne on liitetty. Aina kun käyttöliittymäkomponentille tehdään joku toiminto, esimerkiksi napille napin painaminen, käyttöliittymäkomponentti kutsuu jokaisen siihen liitetyn tapahtumakuuntelijan tiettyä metodia. Käytännössä tapahtumankuuntelijat ovat tietyn rajapinnan toteuttavia luokkia, joiden ilmentymiä käyttöliittymäkomponentille voi lisätä. Tapahtuman tapahtuessa käyttöliittymäkomponentti käy jokaisen siihen liitetyn tapahtumankuuntelijan läpi, ja kutsuu rajapinnassa määriteltyä metodia.</p>

<p>Swing-käyttöliittymissä eniten käytetty tapahtumankuuntelurajapinta on <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/ActionListener.html">ActionListener</a></code>. Rajapinta <code>ActionListener</code> määrittelee metodin <code>void actionPerformed(ActionEvent e)</code>, joka saa parametrinaan tapahtumasta kertovan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/ActionEvent.html" target="_blank">ActionEvent</a></code>-olion.</p>

<p>Toteutetaan ensimmäinen oma tapahtumankuuntelija, jonka tarkoituksena on vain tulostaa viesti standarditulostusvirtaan nappia painettaessa. Luokka <code>ViestiKuuntelija</code> toteuttaa rajapinnan <code>ActionListener</code> ja tulostaa viestin <code>"Viesti vastaanotettu!"</code> kun metodia <code>actionPerformed</code> kutsutaan.</p>

<pre class="sh_java">
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class ViestiKuuntelija implements ActionListener {

    @Override
    public void actionPerformed(ActionEvent ae) {
        System.out.println("Viesti vastaanotettu!");
    }
}
</pre>

<p>Luodaan seuraavaksi käyttöliittymään <code>JButton</code>-tyyppinen nappi, ja lisätään siihen <code>ViestiKuuntelija</code>-luokan ilmentymä. Luokalle <code>JButton</code> voi lisätä tapahtumankuuntelijan käyttämällä sen yläluokassa <code>AbstractButton</code> määriteltyä metodia <code>public void addActionListener(ActionListener actionListener)</code>.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        JButton nappi = new JButton("Viestitä!");
        nappi.addActionListener(new ViestiKuuntelija());

        container.add(nappi);
    }
</pre>

<p><img src="img-ohja/kali/kali-actionlistener-viestita.png"/></p>

<p>Käyttöliittymässä olevaa nappia painettaessa näemme standarditulostusvirrassa seuraavan viestin.</p>

<pre>
Viesti vastaanotettu!
</pre>

<h4>Olioiden käsittely tapahtumankuuntelijoissa</h4>

<p>Haluamme usein että tapahtumankuuntelija muokkaa jonkun olion tilaa. Päästäksemme olioon käsiksi tapahtumankuuntelijassa, tulee meidän antaa viite käsiteltävään olioon tapahtumankuuntelijalle sen konstruktorissa. Tapahtumankuuntelijat ovat täysin samanlaisia luokkia kuin muutkin Javan luokat, eli pääsemme ohjelmoimaan kaiken haluamamme toiminnallisuuden.</p>

<p>Pohditaan seuraavaa käyttöliittymää jossa on kaksi <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JTextArea.html" target="_blank">JTextArea</a></code>-tyyppistä tekstikenttää, eli tekstikenttää johon käyttäjä voi syöttää tekstiä, ja <code>JButton</code>-tyyppinen nappi. Käyttöliittymä käyttää <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/GridLayout.html" target="_blank">GridLayout</a></code>-asettelijaa, jonka avulla käyttöliittymän voi rakentaa taulukkomaiseksi. GridLayout-luokan konstruktorille määriteltiin yksi rivi ja kolme saraketta.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(1, 3);
        container.setLayout(layout);

        JTextArea textAreaVasen = new JTextArea("Le Kopioija");
        JTextArea textAreaOikea = new JTextArea();
        JButton kopioiNappi = new JButton("Kopioi!");

        container.add(textAreaVasen);
        container.add(kopioiNappi);
        container.add(textAreaOikea);
    }
</pre>

    <p><img src="img-ohja/kali/kopioija-alku.png"/></p>

<p>Haluamme lisätä käyttöliittymään toiminnallisuuden, jossa <code>JButton</code>-nappia painettaessa vasemman tekstikentän sisältö kopioituu oikeaan tekstikenttään. Tämä onnistuu toteuttamalla tapahtumankuuntelija. Luodaan rajapinnan <code>ActionListener</code> toteuttava luokka <code>KenttienKopioija</code>, joka kopioi JTextArea kentästä toiseen. </p>


<pre class="sh_java">
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JTextArea;

public class KenttienKopioija implements ActionListener {

    private JTextArea lahde;
    private JTextArea kohde;

    public KenttienKopioija(JTextArea lahde, JTextArea kohde) {
        this.lahde = lahde;
        this.kohde = kohde;
    }

    @Override
    public void actionPerformed(ActionEvent ae) {
        this.kohde.setText(this.lahde.getText());
    }
}
</pre>

<p>Tapahtumankuuntelijan rekisteröinti <code>JButton</code>-oliolle onnistuu metodilla <code>addActionListener</code>.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(1, 3);
        container.setLayout(layout);

        JTextArea textAreaVasen = new JTextArea("Le Kopioija");
        JTextArea textAreaOikea = new JTextArea();
        JButton kopioiNappi = new JButton("Kopioi!");

        KenttienKopioija kopioija = new KenttienKopioija(textAreaVasen, textAreaOikea);
        kopioiNappi.addActionListener(kopioija);

        container.add(textAreaVasen);
        container.add(kopioiNappi);
        container.add(textAreaOikea);
    }
</pre>


<p>Nappia painettaessa vasemman tekstikentän sisältö kopioituu oikealla olevaan tekstikenttään.</p>

    <p><img src="img-ohja/kali/kopioija-valmis.png"/></p>



<div class="tehtavat">

<h3>Ilmoitin</h3>

<p>Toteuta tehtäväpohjaan käyttöliittymä, joka näyttää seuraavalta.</p>

    <p><img src="img-ohja/kali/158-ilmoitin.png"/></p>

<p>Ohjelman tulee koostua seuraavista pakkauksessa <code>ilmoitin</code> olevista luokista. Luokka <code>Ilmoitin</code> on käyttöliittymäluokka, joka käynnistetään <code>Main</code>-luokasta. Ilmoittimessa on käyttöliittymäkomponentteina <code>JTextField</code>, <code>JButton</code>, ja <code>JLabel</code>. Voit asetella käyttöliittymäkomponentit <code>GridLayout</code>-asettelijan avulla: kutsu <code>new GridLayout(3, 1)</code> luo uuden asettelijan, joka asettelee kolme käyttöliittymäelementtiä pystysuunnassa.</p>

<p>Sovelluksessa tulee olla lisäksi luokka <code>TapahtumanKuuntelija</code>, joka toteuttaa rajapinnan <code>ActionListener</code>. Tapahtumankuuntelija liitetään nappiin ja sen tulee kopioida käyttöliittymässä olevan JTextField-kentän sisältö JLabel-kenttään napin painalluksen yhteydessä ja samalla tyhentää JTextField asettamalla sen sisällöksi "".</p>

<p>Varmista että käyttöliittymä käynnistyy niin isona että jokaista nappulaa voi klikata.</p>
</div>

<h3>Sovelluslogiikan ja käyttöliittymälogiikan eriyttäminen</h3>

<p>Sovelluslogiikan (esimerkiksi tallennus- tai lukutoiminnallisuuden) ja käyttöliittymän sekoittaminen samoihin luokkiin on yleisesti ottaen huono asia. Se vaikeuttaa ohjelman testaamista ja muokkaamista huomattavasti, ja tekee koodista myös paljon vaikeammin luettavaa. Single responsibility principlen sanoin "Jokaisella luokalla pitäisi olla vain yksi selkeä vastuu". Sovelluslogiikan erottaminen käyttöliittymälogiikasta onnistuu sopivan rajapintasuunnittelun kautta.  Oletetaan, että käytössämme on rajapinta <code>PersonVarasto</code>, ja haluamme toteuttaa käyttöliittymän henkilöiden tallentamiseen.</p>

<pre class="sh_java">
public interface PersonVarasto {
    void talleta(Person henkilo);
    Person hae(String henkilotunnus);

    void poista(Person henkilo);
    void poista(String henkilotunnus);
    void poistaKaikki();

    Collection&lt;Person&gt; haeKaikki();
}
</pre>

<h4>Käyttöliittymän toteutus</h4>

<p>Käyttöliittymää toteutettaessa hyvä aloitustapa on sopivien käyttöliittymäkomponenttien lisääminen käyttöliittymään. Henkilöiden tallennuksessa tarvitsemme kentät nimelle ja henkilötunnukselle, sekä napin jolla henkilö voidaan lisätä. Käytetään Javan <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JTextField.html" target="_blank">JTextField</a></code>-luokkaa tekstin syöttämiseen, ja <code>JButton</code>-luokkaa napin toteuttamiseen. Luodaan käyttöliittymään lisäksi selventävät <code>JLabel</code>-tyyppiset selitystekstit.</p>

<p>Käytetään käyttöliittymän asetteluun <code>GridLayout</code>-asettelijaa. Rivejä käyttöliittymässä on 3, sarakkeita 2. Lisätään tapahtumankuuntelija myöhemmin. Käyttoliittymäluokan metodi <code>luoKomponentit</code> näyttää nyt seuraavalta.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(3, 2);
        container.setLayout(layout);

        JLabel nimiTeksti = new JLabel("Nimi: ");
        JTextField nimiKentta = new JTextField();
        JLabel hetuTeksti = new JLabel("Hetu: ");
        JTextField hetuKentta = new JTextField();

        JButton lisaaNappi = new JButton("Lisää henkilö!");
        // tapahtumankuuntelija

        container.add(nimiTeksti);
        container.add(nimiKentta);
        container.add(hetuTeksti);
        container.add(hetuKentta);
        container.add(new JLabel(""));
        container.add(lisaaNappi);
    }
</pre>

<p>Käyttöliittymä näyttää seuraavalta kun siihen on lisätty tietoa.</p>

    <p><img src="img-ohja/kali/kali-henkilon-lisays.png"/></p>

<p>Tapahtumankuuntelijan tulee tietää tallennustoiminnallisuudesta eli <code>PersonVarasto</code>-rajapinnasta sekä kentistä, joita se käyttää. Luodaan <code>ActionListener</code>-rajapinnan toteuttava luokka <code>PersonnLisaysKuuntelija</code>. Luokka saa konstruktorissaan parametrina <code>PersonVarasto</code>-rajapinnan toteuttavan olion sekä kaksi <code>JTextField</code>-oliota, jotka ovat kentät nimelle ja henkilötunnukselle. Metodissa <code>actionPerformed</code> luodaan uusi <code>Person</code>-olio ja tallennetaan se <code>PersonVarasto</code>-olion tarjoamalla <code>talleta</code>-metodilla.</p>

<pre class="sh_java">
public class PersonnLisaysKuuntelija implements ActionListener {

    private PersonVarasto henkiloVarasto;
    private JTextField nimiKentta;
    private JTextField hetuKentta;

    public PersonnLisaysKuuntelija(PersonVarasto henkiloVarasto, JTextField nimiKentta, JTextField hetuKentta) {
        this.henkiloVarasto = henkiloVarasto;
        this.nameKentta = nimiKentta;
        this.hetuKentta = hetuKentta;
    }

    @Override
    public void actionPerformed(ActionEvent ae) {
        Person henkilo = new Person(nimiKentta.getText(), hetuKentta.getText());
        this.henkiloVarasto.talleta(henkilo);
    }
}
</pre>

<p>Jotta saamme <code>PersonVarasto</code>-viitteen <code>PersonnLisaysKuuntelija</code>-oliolle, tulee sen olla käyttöliittymän tiedossa. Lisätään käyttöliittymälle oliomuuttuja <code>private PersonVarasto henkiloVarasto</code>, joka asetetaan konstruktorissa. Luokan <code>Kayttoliittyma</code> konstruktoria muokataan siten, että sille annetaan <code>PersonVarasto</code>-rajapinnan toteuttama luokka.</p>

<pre class="sh_java">
public class Kayttoliittyma implements Runnable {

    private JFrame frame;
    private PersonVarasto henkiloVarasto;

    public Kayttoliittyma(PersonVarasto henkiloVarasto) {
        this.henkiloVarasto = henkiloVarasto;
    }
    // ...


</pre>

<p>Voimme nyt luoda tapahtumankuuntelijan <code>PersonnLisaysKuuntelija</code>, jolle annetaan sekä <code>PersonVarasto</code>-viite, että kentät.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(3, 2);
        container.setLayout(layout);

        JLabel nimiTeksti = new JLabel("Nimi: ");
        JTextField nimiKentta = new JTextField();
        JLabel hetuTeksti = new JLabel("Hetu: ");
        JTextField hetuKentta = new JTextField();

        JButton lisaaNappi = new JButton("Lisää henkilö!");
        PersonnLisaysKuuntelija kuuntelija = new PersonnLisaysKuuntelija(henkiloVarasto, nimiKentta, hetuKentta);
        lisaaNappi.addActionListener(kuuntelija);

        container.add(nimiTeksti);
        container.add(nimiKentta);
        container.add(hetuTeksti);
        container.add(hetuKentta);
        container.add(new JLabel(""));
        container.add(lisaaNappi);
    }
</pre>

<div class="tehtavat">
<h3>Axe Click Effect</h3>

<p>Tässä tehtävässä toteutetaan laskuri klikkausten laskemiseen. Tehtävässä sovelluslogiikka, eli laskeminen ja käyttöliittymälogiikka on erotettu toisistaan. Lopullisen sovelluksen tulee näyttää kutakuinkin seuraavalta. </p>

    <p><img src="img-ohja/kali/159-clickeffect.png"/></p>

<h4>OmaLaskuri</h4>

<p>Toteuta pakkaukseen <code>clicker.sovelluslogiikka</code> rajapinnan <code>Laskuri</code> toteuttava luokka <code>OmaLaskuri</code>. Luokan <code>OmaLaskuri</code> metodin <code>annaArvo</code> palauttama luku on aluksi 0. Kun metodia <code>kasvata</code> kutsutaan, kasvaa arvo aina yhdellä.</p>

<p>Voit halutessasi testata luokan toimintaa seuraavan ohjelman avulla.</p>

<pre class="sh_java">
        Laskuri laskuri = new OmaLaskuri();
        System.out.println("Arvo: " + laskuri.annaArvo());
        laskuri.kasvata();
        System.out.println("Arvo: " + laskuri.annaArvo());
        laskuri.kasvata();
        System.out.println("Arvo: " + laskuri.annaArvo());
</pre>

<pre>
Arvo: 0
Arvo: 1
Arvo: 2
</pre>

<h4>KlikkaustenKuuntelija</h4>

<p>Toteuta pakkaukseen <code>clicker.kayttoliittyma</code> rajapinnan <code>ActionListener</code> toteuttava luokka <code>KlikkaustenKuuntelija</code>. Luokka <code>KlikkaustenKuuntelija</code> saa konstruktorin parametrina <code>Laskuri</code>-rajapinnan toteuttavan olion ja <code>JLabel</code>-olion.</p>

<p>Toteuta <code>actionPerformed</code>-metodi siten, että <code>Laskuri</code>-oliota kasvatetaan aluksi yhdellä, jonka jälkeen laskurin arvo asetetaan <code>JLabel</code>-olion tekstiksi. <code>JLabel</code>-olion tekstiä voidaan muuttaa metodilla <code>setText</code>.</p>

<h4>Käyttöliittymä</h4>

<p>Muokkaa luokkaa <code>Kayttoliittyma</code> siten, että käyttöliittymä saa konstruktorin parametrina <code>Laskuri</code>-olion, tarvitset uuden konstruktorin. Lisää käyttöliittymään tarvittavat käyttöliittymäkomponentit. Rekisteröi napille myös edellisessä osassa toteutettu tapahtumankuuntelija.</p>

<p>Käytä käyttöliittymäkomponenttien asetteluun <code>BorderLayout</code>-luokan tarjoamia toiminnallisuuksia. Muuta myös <code>Main</code>-luokkaa siten, että käyttöliittymälle annetaan <code>OmaLaskuri</code>-olio. Kun käyttöliittymässä olevaa <code>"Click!"</code>nappia on painettu kahdesti, sovellus näyttää kutakuinkin seuraavalta.</p>

    <p><img src="img-ohja/kali/159-clickeffect-klikattu.png"/></p>

</div>


<h3>Sisäkkäiset Container-oliot</h3>

<p>Törmäämme silloin tällöin tilanteeseen, jossa <code>JFrame</code>-luokan tarjoama <code>Container</code>-olio ei riitä käyttöliittymän asetteluun. Saatamme tarvita erilaisia käyttöliittymänäkymiä tai mahdollisuutta käyttöliittymäkomponenttien ryhmittelyyn niiden käyttötarkoituksen mukaan. Esimerkiksi alla olevan käyttöliittymän rakentaminen ei olisi kovin helppoa vain <code>JFrame</code>-luokan tarjoamalla <code>Container</code>-oliolla.</p>

   <p><img src="img-ohja/kali/jpanel-container.png"/></p>

<p>Voimme asettaa Container-tyyppisiä olioita toistensa sisään. Luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JPanel.html" target="_blank">JPanel</a></code> (katso myös <a href="http://docs.oracle.com/javase/tutorial/uiswing/components/panel.html" target="_blank">How to Use Panels</a>) mahdollistaa sisäkkäiset <code>Container</code>-oliot. JPanel-luokan ilmentymään voi lisätä käyttöliittymäkomponentteja samalla tavalla kuin <code>JFrame</code>-luokasta saatuun <code>Container</code>-ilmentymään. Tämän lisäksi <code>JPanel</code>-luokan ilmentymän voi lisätä <code>Container</code>-olioon. Tämä mahdollistaa useamman <code>Container</code>-olion käyttämisen käyttöliittymän suunnittelussa.</p>

<p>Yllä olevan käyttöliittymän luominen on helpompaa <code>JPanel</code>-luokan avulla.. Luodaan käyttöliittymä, jossa on kolme nappia "Suorita", "Testaa", ja "Lähetä", sekä tekstialue joka sisältää tekstiä. Napit ovat oma joukkonsa, joten tehdään niille erillinen <code>JPanel</code>-olio joka asetetaan <code>JFrame</code>-luokasta saadun <code>Container</code>-olion eteläosaan. Tekstialue tulee keskelle.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        container.add(new JTextArea());
        container.add(luoValikko(), BorderLayout.SOUTH);
    }

    private JPanel luoValikko() {
        JPanel panel = new JPanel(new GridLayout(1, 3));
        panel.add(new JButton("Suorita"));
        panel.add(new JButton("Testaa"));
        panel.add(new JButton("Lähetä"));
        return panel;
    }
</pre>

<p>JPanel-luokalle annetaan konstruktorin parametrina käytettävä asettelutyyli. Jos asettelutyyli tarvitsee konstruktorissaan viitteen käytettyyn <code>Container</code>-olioon, on <code>JPanel</code>-luokalla myös metodi <code>setLayout</code>.</p>

<p>Jos käyttöliittymässämme on selkeät erilliset kokonaisuudet, voimme myös periä <code>JPanel</code> luokan. Esimerkiksi ylläolevan valikon voisi toteuttaa myös seuraavasti.</p>

<pre class="sh_java">
import java.awt.GridLayout;
import javax.swing.JButton;
import javax.swing.JPanel;

public class ValikkoPanel extends JPanel {

    public ValikkoPanel() {
        super(new GridLayout(1, 3));
        luoKomponentit();
    }

    private void luoKomponentit() {
        add(new JButton("Suorita"));
        add(new JButton("Testaa"));
        add(new JButton("Lähetä"));
    }
}
</pre>

<p>Nyt käyttöliittymäluokassa voidaan luoda <code>ValikkoPanel</code>-luokan ilmentymä.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        container.add(new JTextArea());
        container.add(new ValikkoPanel(), BorderLayout.SOUTH);
    }
</pre>

<p>Huomaa että tapahtumankäsittelyä tarvittaessa luokalle <code>ValikkoPanel</code> tulee antaa parametrina kaikki tarvittavat oliot.</p>

<div class="tehtavat">
<h3>Laskin</h3>

<p>Tehtävässä on tarkoitus toteuttaa yksinkertainen laskin. Laskimen käyttöliittymän tulee olla seuraavanlainen:</p>

   <p><img src="img-ohja/laskin.png"/></p>

<p>Tehtäväpohjan mukana tulee käynistyksen suorittava pääohjelma sekä graafisen käyttöliittymän sisältävä luokka <code>GraafinenLaskin</code>. Käyttöliittymän on oltava täsmälleen seuraavassa osassa kuvaillulla tavalla tehty, muuten saat vapaasti suunnitella ohjelman rakenteen.</p> 

<h4>Layout kuntoon</h4>

<p>Käyttöliittymän pohjana olevassa  <code>JFrame</code>:ssa tulee käyttää asettelijana <code>GridLayout</code>ia jossa on kolme riviä ja yksi sarake. Ylimpänä on tuloskenttävä toimiva  <code>JTextField</code>, jonka täytyy asettaa metodikutsulla <code>setEnabled(false)</code> "poissa päältä". Toisena on syötekenttänä toimiva  <code>JTextField</code>. Tuloskentässä on aluksi teksti 0 ja syötekenttä on tyhjä.</p>

<p>Alimpana komponenttina sijaitsee <code>JPanel</code> jolla asettelijana <code>GridLayout</code>ia jossa on yksi rivi ja kolme saraketta. Panelissa on kolme <code>JButton</code>ia, joissa tekstit "+", "+" ja "Z".</p>

<h4>Perustoiminnallisuus</h4>

<p>Laskimen toimintalogiikka on seuraava. Käyttäjän kirjottaessa syötekenttään luvun n ja painaessa <strong>+</strong>, lisätään tuloskentässä olevaan arvoon n ja päivitetään tuloskenttä uuteen arvoon. Vastaavasti käyttäjän kirjottaessa syötekenttään luvun n ja painaessa <strong>-</strong>, vähennetään tuloskentässä olevasta arvosta n ja päivitetään tuloskenttä uuteen arvoon. Jos käyttäjä painaa <strong>Z</strong>, nollautuu tuloskenttä.</p>

<h4>Hienosäätö</h4>

<p>Laajennetaan vielä ohjelmaa seuraavilla ominaisuuksissa:</p>
<ul>
<li>Jos tuloskentässä on 0, ei <strong>Z</strong>-nappia voi painaa, eli se tulee olla asetettu metodikutsulla <code>setEnabled(false)</code> "poissa päältä". Muissa tilanteissa napin tulee olla päällä.</li>
<li>Kun käyttäjä painaa jotain napeista<strong>+, -, Z</strong> syötekenttä tyhjenee.</li>
<li>Jos syötekenttässä oleva syöte ei ole kokonaisluku ja käyttäjjä painaa jotain napeista<strong>+, -, Z</strong> syötekenttä tyhjenee ja tuloskentän tila ei muutu (paitsi napin ollessa <strong></strong>).</li>
</ul>
</div>

<h2>Piirtäminen</h2>

<p>Luokkaa <code>JPanel</code> käytetään <code>Container</code>-toiminnallisuuden lisäksi usein piirtoalustana siten, että käyttäjä perii luokan <code>JPanel</code> ja korvaa metodin <code>protected void paintComponent(Graphics graphics)</code>. Käyttöliittymä kutsuu metodia <code>paintComponent</code> aina kun käyttöliittymäkomponentin sisältö halutaan piirtää ruudulle. Metodi <code>paintComponent</code> saa käyttöliittymältä parametrina abstraktin luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html" target="_blank">Graphics</a></code> toteuttavan olion. Luodaan luokan <code>JPanel</code> perivä luokka <code>Piirtoalusta</code>, joka korvaa <code>paintComponent</code>-metodin.</p>

<pre class="sh_java">
public class Piirtoalusta extends JPanel {

    public Piirtoalusta() {
        super.setBackground(Color.WHITE);
    }

    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);
    }
}
</pre>

<p>Yllä oleva piirtoalusta ei sisällä konkreettista piirtämistoiminnallisuutta. Asetamme konstruktorissa piirtoalustan taustan valkoiseksi kutsumalla yläluokan metodia <code>setBackground</code>. Metodin <code>setBackGround</code> saa parametrina <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Color.html" target="_blank">Color</a></code>-luokan ilmentymän. Luokka <code>Color</code> sisältää yleisimmät värit luokkamuuttujina, esimerkiksi väri valkoinen löytyy luokkamuuttujasta <code>Color.WHITE</code>.</p>

<p>Korvattu <code>paintComponent</code> metodi kutsuu yläluokan <code>paintComponent</code>-metodia eikä tee muuta. Lisätään piirtoalusta seuraavaksi käyttöliittymäluokan <code>luoKomponentit</code>-metodiin. Käytämme kappaleen <a href="#58">58. Käyttöliittymät</a> alussa määriteltyä käyttöliittymäpohjaa.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        container.add(new Piirtoalusta());
    }
</pre>

<p>Käynnistäessämme käyttöliittymän näemme tyhjän ruudun, jonka taustaväri on valkoinen. Alla olevan käyttöliittymän toivotuksi kooksi on asetettu <code>setPreferredSize</code>-metodilla 300, 300, ja sen otsikko on <code>"Piirtoalusta"</code>.</p>

    <p><img src="img-ohja/kali/piirtoalusta.png"/></p>

<p>Piirtoalustalle piirtäminen tapahtuu <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html" target="_blank">Graphics</a></code>-olion tarjoamien metodien avulla. Muokataan <code>Piirtoalusta</code>-luokan metodia <code>paintComponent</code> siten, että siinä piirretään kaksi suorakulmiota <code>Graphics</code>-olion tarjoaman metodin <code>fillRect</code> avulla.</p>

<pre class="sh_java">
    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);

        graphics.fillRect(50, 80, 100, 50);
        graphics.fillRect(200, 20, 50, 200);
    }
</pre>

<p>Metodi <code>fillRect</code> saa parametrina suorakulmion <code>x</code>, ja <code>y</code> -koordinaatit, sekä suorakulmion leveyden ja korkeuden tässä järjestyksessä. Yllä siis piirretään ensin koordinaatista <code>(50, 80)</code> alkava 100 pikseliä leveä ja 50 pikseliä korkea suorakulmio. Tämän jälkeen piirretään koordinaatista <code>(200, 20)</code> alkava 50 pikseliä leveä ja 100 pikseliä korkea suorakulmio.</p>

<p>Kuten piirtotuloksesta huomaat, koordinaatisto ei toimi aivan kuten olemme tottuneet.</p>

    <p><img src="img-ohja/kali/piirtoalusta-suorakulmiot.png"/></p>

<p>Javan <code>Graphics</code>-olio (ja useiden muiden ohjelmointikielten käyttöliittymäkirjastot) olettaa että y-akselin arvo kasvaa alaspäin mennessä. Koordinaatiston origo, eli piste <code>(0, 0)</code> on piirrettävän alueen vasemmassa yläkulmassa: Graphics-olio tietää aina käyttöliittymäkomponentin, johon piirretään, ja osaa sen perusteella päätellä piirtotapahtuman sijainnin. Käyttöliittymän origon sijainti selkeytyy seuraavalla ohjelmalla. Piirretään ensin pisteestä (0, 0) lähtevä 10 pikseliä leveä ja 200 pikseliä korkea vihreä suorakulmio. Tämän jälkeen piirretään pisteestä (0, 0) lähtevä 200 pikseliä leveä ja 10 pikseliä korkea musta. Seuraavana piirrettävän kuvion väri määritellään <code>Graphics</code>-oliolle metodilla <code>setColor</code>.</p>


<pre class="sh_java">
    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);

        graphics.setColor(Color.GREEN);
        graphics.fillRect(0, 0, 10, 200);
        graphics.setColor(Color.BLACK);
        graphics.fillRect(0, 0, 200, 10);
    }
</pre>

    <p><img src="img-ohja/kali/piirtoalusta-koordinaatisto.png"/></p>

<p>Tämä koordinaatiston käänteisyys johtuu siitä, miten käyttöliittymien kokoa muokataan. Käyttöliittymän kokoa muutettaessa sitä pienennetään tai suurennetaan "oikeasta alakulmasta vetäen", jolloin ruudulla näkyvä piirros siirtyy kokoa muuttaessa. Kun koordinaatisto alkaa vasemmasta yläkulmasta, on piirroksen sijainti aina sama, mutta näkyvä osa muuttuu.</p>

<div class="tehtavat">

<h3>Piirtoalusta ja Piirtäminen</h3>

<p>Tehtäväpohjassa on valmiina käyttöliittymä, johon on kytketty <code>JPanel</code>-luokan perivä luokka <code>Piirtoalusta</code>. Muuta luokan <code>Piirtoalusta</code> metodin <code>paintComponent</code> toteutusta siten, että se piirtää seuraavanlaisen kuvion. Saat käyttää tehtävässä vain <code>graphics</code>-olion <code>fillRect</code>-metodia.</p>

<p><img src="img-ohja/smiley.gif"/></p>

<p>Huom! Älä käytä enempää kuin viittä <code>fillRect</code>-kutsua. Kuvion ei tarvitse olla täsmälleen samanlainen kuin ylläoleva, testit kertovat kun piirtämäsi kuva on tarpeeksi lähellä haluttua kuvaa.</p>

</div>

<p>Laajennetaan edellistä esimerkkiä siten, että piirrämme käyttöliittymässä erillisen hahmo-olion. Luodaan hahmon edustamiseen luokka <code>Hahmo</code>. Hahmolla on koordinaatteina ilmaistu sijainti, ja se piirretään ympyränä jonka halkaisija on 10 pikseliä. Hahmon sijaintia voi muuttaa kutsumalla sen <code>siirry</code>-metodia.</p>

<pre class="sh_java">
import java.awt.Graphics;

public class Hahmo {

    private int x;
    private int y;

    public Hahmo(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public void siirry(int xmuutos, int ymuutos) {
        this.x += xmuutos;
        this.y += ymuutos;
    }

    public void piirra(Graphics graphics) {
        graphics.fillOval(x, y, 10, 10);
    }
}
</pre>

<p>Muutetaan piirtoalustaa siten, että sille annetaan <code>Hahmo</code>-luokan ilmentymä konstruktorin parametrina. Luokan <code>Piirtoalusta</code> metodi <code>paintComponent</code> ei itse piirrä hahmoa, vaan delegoi piirtovastuun <code>Hahmo</code>-luokan ilmentymälle.</p>

<pre class="sh_java">
import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JPanel;

public class Piirtoalusta extends JPanel {

    private Hahmo hahmo;

    public Piirtoalusta(Hahmo hahmo) {
        super.setBackground(Color.WHITE);
        this.hahmo = hahmo;
    }

    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);
        hahmo.piirra(graphics);
    }
}
</pre>

<p>Annetaan hahmo myös käyttöliittymälle parametrina. Hahmo on siis käyttöliittymästä erillinen olio, joka vain halutaan piirtää käyttöliittymässä. Oleelliset muutokset käyttöliittymäluokassa ovat siis konstruktorin muuttaminen siten, että se saa parametrina <code>Hahmo</code>-olion. Tämän lisäksi metodissa <code>luoKomponentit</code> annetaan <code>Hahmo</code>-luokan ilmentymä parametrina luotavalle <code>Piirtoalusta</code>-oliolle.</p>

<pre class="sh_java">
public class Kayttoliittyma implements Runnable {

    private JFrame frame;
    private Hahmo hahmo;

    public Kayttoliittyma(Hahmo hahmo) {
        this.hahmo = hahmo;
    }

// ...

    private void luoKomponentit(Container container) {
        Piirtoalusta piirtoalusta = new Piirtoalusta(hahmo);
        container.add(piirtoalusta);
    }
// ...
</pre>

<p>Käyttöliittymän voi nyt käynnistää antamalla sen konstruktorille <code>Hahmo</code>-olion parametrina.</p>

<pre class="sh_java">
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Hahmo(30, 30));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

    <p><img src="img-ohja/kali/piirtoalusta-hahmon-piirtaminen.png"/></p>

<p>Yllä olevassa käyttöliittymässä näkyy huikea, pallonmuotoinen hahmo.</p>

<p>Lisätään seuraavaksi ohjelmaan hahmon siirtämistoiminnallisuus. Haluamme liikuttaa hahmoa näppäimistöllä. Kun käyttäjä painaa nuolta vasemmalle, hahmon pitäisi siirtyä vasemmalle. Oikealle osoittavaa nuolta painettaessa hahmon pitäisi siirtyä oikealle. Tarvitsemme siis tapahtumankuuntelijan, joka kuuntelee näppäimistöä. Rajapinta <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/KeyListener.html" target="_blank">KeyListener</a></code> määrittelee näppäimistönkuuntelijalta vaaditut toiminnallisuudet.</p>

<p>Rajapinta <code>KeyListener</code> vaatii metodien <code>keyPressed</code>, <code>keyReleased</code>, ja <code>keyTyped</code> toteuttamista. Olemme kiinnostuneita vain tapahtumasta, jossa näppäintä painetaan, joten jätämme metodit <code>keyReleased</code> ja <code>keyTyped</code> tyhjiksi. Luodaan luokka <code>NappaimistonKuuntelija</code>, joka toteuttaa rajapinnan <code>KeyListener</code>. Luokka saa parametrina <code>Hahmo</code>-olion, jota tapahtumankäsittelijän tulee liikuttaa.</p>

<pre class="sh_java">
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class NappaimistonKuuntelija implements KeyListener {

    private Hahmo hahmo;

    public NappaimistonKuuntelija(Hahmo hahmo) {
        this.hahmo = hahmo;
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            hahmo.siirry(-5, 0);
        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
            hahmo.siirry(5, 0);
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }

    @Override
    public void keyTyped(KeyEvent ke) {
    }
}
</pre>

<p>Metodi <code>keyPressed</code> saa käyttöliittymältä parametrina <code>KeyEvent</code>-luokan ilmentymän. KeyEvent-oliolta saa tietoon painettuun nappiin liittyvän numeron sen <code>getKeyCode()</code>-metodilla. Eri näppäimille on luokkamuuttujat <code>KeyEvent</code>-luokassa, esimerkiksi nuoli vasemmalle on <code>KeyEvent.VK_LEFT</code>.</p>

<p>Haluamme kuunnella käyttöliittymään kohdistuvia näppäimen painalluksia (emme esimerkiksi ole kirjoittamassa tekstikenttään), joten lisätään näppäimistönkuuntelija <code>JFrame</code>-luokan ilmentymälle. Muokataan käyttöliittymäämme siten, että näppäimistönkuuntelija lisätään JFrame-oliolle.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        Piirtoalusta piirtoalusta = new Piirtoalusta(hahmo);
        container.add(piirtoalusta);

        frame.addKeyListener(new NappaimistonKuuntelija(hahmo));
    }
</pre>

<p>Nyt sovelluksemme kuuntelee näppäimistöltä tulleita painalluksia, ja ohjaa ne luokan <code>NappaimistonKuuntelija</code> ilmentymälle.</p>

<p>Kokeillessamme käyttöliittymää se ei kuitenkaan toimi: hahmo ei siirry ruudulla. Mistä tässä oikein on kyse? Voimme tarkastaa että näppäimistön painallukset ohjautuvat <code>NappaimistonKuuntelija</code>-oliolle lisäämällä <code>keyPressed</code>-metodin alkuun testitulostuksen.</p>

<pre class="sh_java">
    @Override
    public void keyPressed(KeyEvent e) {
        System.out.println("Nappia " + e.getKeyCode() +  " painettu.");

        // ...
</pre>

<p>Käynnistäessämme ohjelman ja painaessamme näppäimiä näemme konsolissa tulostuksen.</p>

<pre>
Nappia 39 painettu.
Nappia 37 painettu.
Nappia 40 painettu.
Nappia 38 painettu.
</pre>

<p>Huomaamme että näppäimistön kuuntelija toimii, mutta piirtoalusta ei päivity.</p>

<h3>Piirtoalustan uudelleenpiirtäminen</h3>

<p>Käyttöliittymäkomponentit sisältävät yleensä toiminnallisuuden komponentin ulkoasun uudelleenpiirtämiseen tarvittaessa. Esimerkiksi nappia painettaessa <code>JButton</code>-luokan ilmentymä osaa piirtää napin "painettuna", jonka jälkeen nappi piirretään taas normaalina. Toteuttamassamme piirtoalustassa ei ole valmista päivitystoiminnallisuutta, vaan meidän tulee pyytää sitä piirtämään itsensä uudelleen tarvittaessa.</p>

<p>Jokaisella <code>Component</code>-luokan aliluokalla on metodi <code>public void repaint()</code>, jonka kutsuminen pakottaa komponentin uudelleenpiirtämisen. Haluamme että <code>Piirtoalusta</code>-olio piirretään uudestaan aina kun hahmoa siirretään. Hahmon siirtäminen tapahtuu luokassa <code>NappaimistonKuuntelija</code>, joten on loogista että uudelleenpiirtokutsu tapahtuu myös näppäimistönkuuntelijassa.</p>

<p>Uudelleenpiirtokutsua varten näppäimistönkuuntelija tarvitsee viitteen piirtoalustaan. Muutetaan luokkaa <code>NappaimistonKuuntelija</code> siten, että se saa parametrinaan <code>Hahmo</code>-olion lisäksi uudelleenpiirrettävän <code>Component</code>-olion. Kutsutaan <code>Component</code>-olion <code>repaint</code>-metodia jokaisen <code>keyPressed</code> tapahtuman lopussa.</p>

<pre class="sh_java">
import java.awt.Component;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class NappaimistonKuuntelija implements KeyListener {

    private Component component;
    private Hahmo hahmo;

    public NappaimistonKuuntelija(Hahmo hahmo, Component component) {
        this.hahmo = hahmo;
        this.component = component;
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            hahmo.siirry(-5, 0);
        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
            hahmo.siirry(5, 0);
        }

        component.repaint();
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }

    @Override
    public void keyTyped(KeyEvent ke) {
    }
}
</pre>

<p>Muutetaan myös <code>Kayttoliittyma</code>-luokan <code>luoKomponentit</code>-metodia siten, että <code>Piirtoalusta</code>-luokan ilmentymä annetaan parametrina näppäimistönkuuntelijalle.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        Piirtoalusta piirtoalusta = new Piirtoalusta(hahmo);
        container.add(piirtoalusta);

        frame.addKeyListener(new NappaimistonKuuntelija(hahmo, piirtoalusta));
    }
</pre>

<p>Nyt hahmon liikuttaminen myös näkyy käyttöliittymässä. Aina kun käyttäjä painaa näppäimistöä, käyttöliittymään liitetty näppäimistönkuuntelija käsittelee kutsun. Jokaisen kutsun lopuksi kutsutaan piirtoalustan <code>repaint</code>-metodia, joka aiheuttaa piirtoalustan uudelleenpiirtämisen.</p>

    <p><img src="img-ohja/kali/piirtoalusta-hahmo-liikkuu.png"/></p>

<div class="tehtavat">
<h3>Liikkuva kuvio</h3>

<p>Teemme ohjelman, jossa käyttäjä voi liikutella näppäimistön avulla ruudulle piirrettyjä kuvioita. Ohjelmassa tulee mukana käyttöliittymärunko, jota pääset muokkaamaan ohjelman edetessä.</p>

<p>Aluksi tehdään muutama luokka, joilla kuvioita hallitaan. Pääsemme myöhemmin piirtämään kuvioita ruudulle. Tee kaikki ohjelman luokat pakkaukseen <code>liikkuvakuvio</code>.</p>

<p>Tehtävässä käytetään perintää ja abstrakteja luokkia. Kertaa siis tarvittaessa values 18.1, 18.2 ja 18.5</p></p>

<h4 class="req">Abstrakti luokka Kuvio</h4>

<p>Tee abstrakti luokka <code>Kuvio</code>. Kuviolla on oliomuuttujat <code>x</code> ja <code>y</code>, jotka kertovat kuvion sijainnin ruudulla sekä metodi <code>public void siirra(int dx, int dy)</code>, jonka avulla kuvion sijainti siirtyy parametrina olevien koordinaattisiirtymien verran. Esim. jos sijainti aluksi on (100,100), niin kutsun <code>siirra(10,-50)</code> jälkeen sijainti on (110, 50). Luokan konstruktorin <code>public Kuvio(int x, int y)</code> tulee asettaa kuviolle alkusijainti. Lisää luokalle myös metodit <code>public int getX()</code> ja <code>public int getY()</code>.</p>

<p>Luokalla tulee olla myös abstrakti metodi <code>public abstract void piirra(Graphics graphics)</code>, jolla kuvio piirretään piirtoalustalle. Kuvion piirtämismetodi toteutetaan luokan <code>Kuvio</code> perivissä metodeissa.</p>

<h4 class="req">Ympyra</h4>

<p>Tee luokka <code>Ympyra</code> joka perii Kuvion. Ympyrällä on <code>halkaisija</code> jonka arvon konstruktori <code>public Ympyra(int x, int y, int halkaisija)</code>. Sijainti tallennetaan yläluokassa määriteltyihin oliomuuttujiin. 
</p>

<p>
Ympyra määrittelee metodin <code>piirra</code> siten, että oikean kokoinen ympyrä piirretään koordinaattien osoittamaan paikkaan
parametrina olevan <code>Graphics</code>-olion <code>fillOval</code>-metodia käyttäen, ympyrän sijaintia tulee käyttää metodin kahtena ensimmäisenä parametrina. Ota mallia Hahmo-esimerkin vastaavasta metodista.
Graphics-olion metodien toimintaa kannattaa tutkia <a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html">Java API:sta.</a> 
</p>

<h4 class="req">Piirtoalusta</h4>

<p>Luo luokka <code>Piirtoalusta</code> joka perii luokan <code>JPanel</code>, mallia voit ottaa esimerkiksi edellisen tehtävän mukana tulleesta piirtoalustasta. Piirtoalusta saa konstruktorin parametrina <code>Kuvio</code>-tyyppisen olion. Korvaa luokan <code>JPanel</code> metodi <code>protected void paintComponent(Graphics g)</code> siten, että siinä kutsutaan ensin yläluokan <code>paintComponent</code>-metodia ja sitten piirtoalustalle asetetun kuvion <code>piirra</code>-metodia.</p>

<p>Muokkaa luokkaa <code>Kayttoliittyma</code> siten, että se saa konstruktorin parametrina <code>Kuvio</code>-tyyppisen olion. Lisää käyttöliittymään Piirtoalusta <code>luoKomponentit(Container container)</code>-metodissa, anna piirtoalustalle konstruktorin parametrina käyttöliittymälle annettu kuvio.</p>

<p>Testaa lopuksi että seuraavalla esimerkkikoodilla ruudulle piirtyy ympyrä.</p>

<pre class="sh_java">
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Ympyra(50, 50, 250));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

<p><img src="img-ohja/kali/liikkuvakuvio-ympyra.png"/></p>



        <h4 class="req">Näppäimistöohjaus</h4>

<p>Laajennetaan piirtoalustaa siten, että kuviota voi liikutella nuolinäppäinten avulla. Luo rajapinnan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/KeyListener.html" target="_blank">KeyListener</a></code> toteuttava luokka <code>NappaimistonKuuntelija</code>. Luokan <code>NappaimistonKuuntelija</code> konstruktorin parametrit ovat luokan <code>Component</code> ilmentymä ja luokan <code>Kuvio</code> ilmentymä.</p>

<p>Luokan Component ilmentymä annetaan näppäimistönkuuntelijalle, jotta voimme päivittää halutun komponentin jokaisen näppäimenpainalluksen jälkeen uudestaan. Komponentin päivittäminen tapahtuu kutsumalla <code>Component</code> luokasta perityvää metodia <code>repaint</code>. Luokka Piirtoalusta on tyyppiä <code>Component</code> koska <code>Component</code> on luokan <code>JPanel</code> perivän luokan yläluokka.</p>

<p>Toteuta rajapinnan <code>KeyListener</code> määrittelemä metodi <code>keyPressed(KeyEvent e)</code> siten, että käyttäjän painaessa nuolta vasemmalle kuvio siirtyy yhden pykälän vasemmalle. Oikealle painettaessa yksi oikealle. Ylös painettaessa yksi ylös, ja alas painettaessa yksi alas. Huomaa että y-akseli kasvaa ikkunan yläosasta alaspäin. Näppäinkoodit nuolinäppäimille ovat <code>KeyEvent.VK_LEFT</code>, <code>KeyEvent.VK_RIGHT</code>, <code>KeyEvent.VK_UP</code>, ja <code>KeyEvent.VK_DOWN</code>. Jätä muut rajapinnan <code>KeyListener</code> vaatimat metodit tyhjiksi.</p>

<p>Kutsu aina Component-luokan <code>repaint</code>-metodia näppäimistönkuuntelutapahtuman lopussa.</p>

<p>Lisää näppäimistönkuuntelija Kayttoliittyma-luokan <code>lisaaKuuntelijat</code>-metodissa. Näppäimistönkuuntelija tulee liittää <code>JFrame</code>-olioon.</p>


        <h4 class="req">Nelio ja Laatikko</h4>


<p>Peri luokasta <code>Kuvio</code> luokat <code>Nelio</code> ja <code>Laatikko</code>. Neliöllä on konstruktori <code>public Nelio(int x, int y, int sivunPituus)</code>, laatikon konstruktori on muotoa <code>public Laatikko(int x, int y, int leveys, int korkeus)</code>. Käytä piirtämisessä graphics-olion <code>fillRect</code>-metodia.</p>

<p>Varmista, että neliöt ja laatikot piirtyvät ja liikkuvat oikein Piirtoalustalla.</p>

<pre class="sh_java">
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Nelio(50, 50, 250));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

<p><img src="img-ohja/kali/liikkuvakuvio-nelio.png"/></p>


<pre class="sh_java">
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Laatikko(50, 50, 100, 300));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

<p><img src="img-ohja/kali/liikkuvakuvio-laatikko.png"/></p>

        <h4 class="req">Koostekuvio</h4>

        <p>Peri luokasta <code>Kuvio</code> luokka <code>Koostekuvio</code>. Koostekuvio sisältää joukon muita kuvioita jotka se tallettaa ArrayList:iin. Koostekuviolla on metodi <code>public void liita(Kuvio k)</code> jonka avulla koostekuvioon voi liittää kuvio-olion. Koostekuviolla ei ole omaa sijaintia ja ei ole merkitystä mitä koostekuvio asettaa perimiensä x- ja y-koordinaatin arvoiksi. Koostekuvio piirtää itsensä pyytämällä osiaan piirtämään itsensä, koostekuvion siirtyminen tapahtuu samoin. Kuviolta peritty metodi <code>siirra</code> on siis ylikirjoitettava!</p>

        <p>Testaa että koostekuviosi piirtyy ja siirtyy oikein, esim. seuraavan koostekuvion avulla:</p>

<pre class="sh_java">
        Koostekuvio rekka = new Koostekuvio();

        rekka.liita(new Laatikko(220, 110, 75, 100));
        rekka.liita(new Laatikko(80, 120, 200, 100));
        rekka.liita(new Ympyra(100, 200, 50));
        rekka.liita(new Ympyra(220, 200, 50));

        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(rekka);
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

<p><img src="img-ohja/kali/liikkuvakuvio-rekka.png"/></p>



        <p>Huomaa miten <b>olioiden vastuut</b> jakautuvat tehtävässä. Jokainen Kuvio on vastuussa itsensä piirtämisestä ja siirtämisestä. Yksinkertaiset kuviot siirtyvät kaikki samalla tavalla. Jokaisen yksinkertaisen kuvion on itse hoidettava piirtymisestään. Koostekuvio siirtää itsensä pyytämällä osiaan siirtymään, samoin hoituu koostekuvion piirtyminen. Piirtoalusta tuntee Kuvio-olion joka siis voi olla mikä tahansa yksinkertainen kuvio tai koostekuvio, kaikki piirretään ja siirretään samalla tavalla. Piirtoalusta siis toimii samalla tavalla kuvion oikeasta tyypistä huolimatta, piirtoalustan ei tarvitse tietää kuvion yksityiskohdista mitään. Kun piirtoalusta kutsuu kuvion metodia <code>piirra</code> tai <code>siirra</code> <b>polymorfismin</b> ansiosta kutsutuksi tulee kuvion todellista tyyppiä vastaava metodi.</p>

        <p>Huomionarvoista tehtävässä on se, että Koostekuvio voi sisältää mitä tahansa Kuvio-olioita, siis myös koostekuvioita! Luokkarakenne mahdollistaakin mielivaltaisen monimutkaisen kuvion muodostamisen ja kuvion siirtely ja piirtäminen tapahtuu aina täsmälleen samalla tavalla.</p>

        <p>Luokkarakennetta on myös helppo laajentaa, esim. perimällä Kuvio-luokasta uusia kuviotyyppejä: kolmio, piste, viiva, ym... Koostekuvio toimii ilman muutoksia myös uusien kuviotyyppien kanssa, samoin piirtoalusta ja käyttöliittymä.</p>

</div>


<h3>Valmiit sovelluskehykset</h3>

<p>Sovelluskehys on ohjelma, joka tarjoaa lähtökohdan ja joukon palveluita jonkin erityisen sovelluksen toteuttamiseen. Yksi tapa laatia sovelluskehys on laatia valmiita palveluita tarjoava luokka, jonka päälle luokan perivät luokat rakentavat erityisen sovelluksen. Sovelluskehykset ovat yleensä hyvin laajoja, ja tarkoitettu johonkin tiettyyn tarkoitukseen, esimerkiksi pelien ohjelmointiin tai web-sovelluskehitykseen. Tutustutaan seuraavasti pikaisesti valmiin sovelluskirjaston käyttöön luomalla sovelluslogiikka Game of Life -pelille.</p>

<div class="tehtavat">
<h3>Game of Life</h3>

<p>Tässä tehtäväsarjassa toteutetaan sovelluslogiikka Game of Life-pelille perimällä valmis sovellusrunko. Sovellusrunko on projektiin erikseen lisätyssä kirjastossa, joten sen lähdekoodit eivät ole nähtävissä.</p>

<p><b>HUOM:</b> tehtävä ei ole erityisen vaikea, mutta tehtävänanto saattaa aluksi vaikuttaa sekavalta. Lue ohje tarkasti uudelleen tai kysy apua jos et pääse alkuun. Tehtävä kannattaa ehdottomasti tehdä, sillä lopputulos on hieno!</p>

<p>Game of Life on matemaatikko John Conway'n kehittelemä yksinkertainen "populaatiosimulaattori", kts. <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life</a>.</p>

<p>Game of Lifen säännöt ovat seuraavat:</p>
<ul>
<li>Jokainen elossa oleva solu, jolla on alle kaksi elossa olevaa naapuria kuolee.</li>
<li>Jokainen elossa oleva solu, jolla on kaksi tai kolme elossa olevaa naapuria elää seuraavaan iteraatioon eli kierrokseen.</li>
<li>Jokainen elossa oleva solu, jolla on yli kolme naapuria kuolee.</li>
<li>Jokainen kuollut solu, jolla on tasan kolme elossa olevaa naapuria muuttuu eläväksi.</li>
</ul>

<p>Abstrakti luokka <code>GameOfLifeAlusta</code> tarjoaa seuraavat toiminnot</p>
<ul>
  <li><b>public GameOfLifeAlusta(int leveys, int korkeus)</b> luo määritellyn kokoisen pelialustan</li>
  <li><b>public boolean[][] getAlusta()</b> tarjoaa pääsyn pelialustaan, joka on totuusarvoista koostuva kaksiulotteinen taulukko &ndash; kuten metodin paluuarvosta voi havaita! Palaamme kaksiulotteiseen taulukkoon tarkemmin sitä tarvitessamme.</li>
  <li><b>public int getLeveys()</b> palauttaa alustan leveyden</li>
  <li><b>public int getKorkeus()</b> palauttaa alustan korkeuden</li>
  <li><b>public void pelaaKierros()</b> simuloi pelikierroksen</li>
</ul>

<p>Luokassa <code>GameOfLifeAlusta</code> on lisäksi määritelty seuraavat abstraktit metodit, <b>jotka sinun tulee toteuttaa</b>.<p>

<ul>
  <li><b>public abstract void muutaElavaksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) eläväksi eli asettaa sille arvon <i>true</i>. Jos koordinaatit ovat alustan ulkopuolella ei tapahdu mitään.</li>
  <li><b>public abstract void muutaKuolleeksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) kuolleeksi eli asettaa sille arvon <i>false</i>. Jos koordinaatit ovat alustan ulkopuolella ei tapahdu mitään.</li>
  <li><b>public abstract boolean onElossa(int x, int y)</b> kertoo onko koordinaatissa (x, y) oleva alkio elossa. Jos koordinaatit ovat alustan ulkopuolella, palautetaan <i>false.</i></li>
  <li><b>public abstract void alustaSatunnaisetPisteet(double todennakoisyysPisteelle)</b> alustaa kaikki alustan alkiot siten, että kukin alkio on elävä todennäköisyydellä <i>todennakoisyysPisteelle.</i> Todennäköisyys annetaan double-arvona suljetulla välillä [0, 1]. Jos metodia kutsutaan arvolla 1, tulee jokaisen alkion olla elävä. Jos taas todennäköisyys on 0, tulee jokaisen alkion olla kuollut.</li>
  <li><b>public abstract int getElossaOlevienNaapurienLukumaara(int x, int y)</b> kertoo elossa olevien naapureiden lukumäärän solulle pisteessä (x, y).</li>
  <li><b>public abstract void hoidaSolu(int x, int y, int elossaOleviaNaapureita)</b> hoitaa solun (x, y) Game of Life -sääntöjen mukaan.</li>
</ul>


<h4>GameOfLife-toteutus, vaihe 1</h4>

<p>Luo pakkaukseen <code>game</code> luokka <code>OmaAlusta</code>, joka perii pakkauksessa <code>gameoflife</code> olevan luokan <code>GameOfLifeAlusta</code>. Huomaa että pakkausta <code>gameoflife</code> ei ole näkyvillä omassa projektissasi, vaan se tulee mukana luokkakirjastona. Toteuta luokalle <code>OmaAlusta</code> konstruktori <code>public OmaAlusta(int leveys, int korkeus)</code>, joka kutsuu yläluokan konstruktoria annetuilla parametreilla:</p>

<pre class="sh_java">
import gameoflife.GameOfLifeAlusta;

public class OmaAlusta extends GameOfLifeAlusta {

    public OmaAlusta(int leveys, int korkeus) {
        super(leveys, korkeus);
    }

    // ..
</pre>

<p>Voit ensin korvata kaikki abstraktit metodit ei-abstrakteilla metodeilla, jotka eivät kuitenkaan vielä tee mitään järkevää. Mutta koska ne eivät ole abstrakteja, tästä luokasta voi luoda ilmentymiä, toisin kuin abstraktista luokasta GameOfLifeAlusta.</p>

<p>Toteuta seuraavat metodit</p>
<ul>
  <li><b>public void muutaElavaksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) eläväksi eli asettaa sille arvon <i>true</i></li>
  <li><b>public void muutaKuolleeksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) kuolleeksi eli asettaa sille arvon <i>false</i></li>
  <li><b>public boolean onElossa(int x, int y)</b> kertoo onko koordinaatissa (x, y) oleva alkio elossa. Jos koordinaatit ovat alustan ulkopuolella, palautetaan <i>false.</i></li>
</ul>

<p><b>Vihje:</b> Pääset yläluokassa olevaan kaksiulotteiseen taulukkoon käsiksi yläluokan tarjoaman metodin <code>getAlusta()</code> avulla. Kaksiulotteisia taulukoita käytetään kuten yksiulotteisia taulukoita, mutta taulukoille annetaan kaksi indeksiä. Ensimmäinen indeksi kertoo leveyskohdan, toinen indeksi korkeuskohdan. Esimerkiksi seuraava ohjelmapätkä luo ensin 10 x 10 -kokoisen taulukon, ja tulostaa sitten taulukon indeksissä 3, 1 olevan arvon.</p>

<pre class="sh_java">
boolean[][] arvot = new boolean[10][10];
System.out.println(arvot[3][1]);
</pre>

<p>Vastaavasti OmaAlusta-luokassa voidaan tulostaa yläluokasta saadun taulukon arvo indeksissä x, y seuraavasti:</p>

<pre class="sh_java">
boolean[][] alusta = getAlusta();
System.out.println(alusta[x][y]);
</pre>

<p>Ja indeksiin x,y voidaan asettaa esim. arvo true seuraavasti:</p>

<pre class="sh_java">
boolean[][] alusta = getAlusta();
alusta[x][y] = true;
</pre>

<p>Tai suoraan käyttämättä apumuuttujaa:</p>

<pre class="sh_java">
getAlusta()[x][y] = true;    
</pre>


<p>Testaa toteutustasi seuraavalla testiohjelmalla.</p>
<pre class="sh_java">
package game;

import gameoflife.komentorivi.KomentoriviGameOfLife;

public class Main {
    public static void main(String[] args) {
        OmaAlusta alusta = new OmaAlusta(7, 5);

        alusta.muutaElavaksi(2, 0);
        alusta.muutaElavaksi(4, 0);

        alusta.muutaElavaksi(3, 3);
        alusta.muutaKuolleeksi(3, 3);

        alusta.muutaElavaksi(0, 2);
        alusta.muutaElavaksi(1, 3);
        alusta.muutaElavaksi(2, 3);
        alusta.muutaElavaksi(3, 3);
        alusta.muutaElavaksi(4, 3);
        alusta.muutaElavaksi(5, 3);
        alusta.muutaElavaksi(6, 2);

        KomentoriviGameOfLife gom = new KomentoriviGameOfLife(alusta);
        gom.pelaa();
    }
}
</pre>
<p>

Tulostuksen pitäisi olla seuraavanlainen:

<pre>
Paina enter jatkaaksesi, muut lopettaa: &lt;enter&gt;

  X X

X     X
 XXXXX

Paina enter jatkaaksesi, muut lopettaa: <font color="red">stop</font>
Kiitos!
</pre>
<p>

<h4>GameOfLife-toteutus, vaihe 2</h4>

<p>Toteuta metodi <b>alustaSatunnaisetPisteet(double todennakoisyysPisteelle)</b>, joka alustaa kaikki alkiot siten, että kukin alkio on elävä todennäköisyydellä <i>todennakoisyysPisteelle</i>. Todennäköisyys annetaan metodille suljetulla välillä [0, 1] olevana double-tyyppisenä parametrina.</p>

<p>Testaa metodia. Arvolla 0.0 ei pitäisi olla yhtään elossa olevaa solua, arvolla 1.0 kaikkien solujen tulisi olla elossa (eli näkyä X-merkkisinä). Arvolla 0.5 noin puolet soluista on eläviä.</p>

<pre class="sh_java">
        OmaAlusta alusta = new OmaAlusta(3, 3);
        alusta.alustaSatunnaisetPisteet(1.0);

        KomentoriviGameOfLife gom = new KomentoriviGameOfLife(alusta);
        gom.pelaa();
</pre>

<pre>
Paina enter jatkaaksesi, muut lopettaa: &lt;enter&gt;

XXX
XXX
XXX
Paina enter jatkaaksesi, muut lopettaa: <font color="red">stop</font>
Kiitos!
</pre>


<h4>GameOfLife-toteutus, vaihe 3</h4>

<p>Toteuta metodi <b>getElossaOlevienNaapurienLukumaara(int x, int y),</b> joka laskee elossa olevien naapurien lukumäärän. Keskellä
taulukkoa olevalla solulla on yhteensä kahdeksan naapuria, reunassa olevalla solulla 5, kulmassa olevalla 3. </p>

<p>Testaa metodia seuraavilla lauseilla (voit keksiä myös muita testitapauksia!):</p>

<pre class="sh_java">
OmaAlusta alusta = new OmaAlusta(7, 5);

alusta.muutaElavaksi(0, 1);
alusta.muutaElavaksi(1, 0);
alusta.muutaElavaksi(1, 2);
alusta.muutaElavaksi(2, 2);
alusta.muutaElavaksi(2, 1);

System.out.println("Elossa naapureita (0,0): " + alusta.getElossaOlevienNaapurienLukumaara(0, 0));
System.out.println("Elossa naapureita (1,1): " + alusta.getElossaOlevienNaapurienLukumaara(1, 1));
</pre>
<p>

Tulostuksen pitäisi olla seuraavanlainen:
<pre>
Elossa naapureita (0,0): 2
Elossa naapureita (1,1): 5
</pre>


<h4>GameOfLife-toteutus, vaihe 4</h4>

<p>Jäljellä on vielä metodin <b>hoidaSolu(int x, int y, int elossaOleviaNaapureita)</b> toteuttaminen. GameOfLife-pelin säännöthän olivat seuraavat:</p>

<ul>
  <li>Jokainen elossa oleva solu, jolla on alle kaksi elossa olevaa naapuria kuolee.</li>
  <li>Jokainen elossa oleva solu, jolla on kaksi tai kolme elossa olevaa naapuria elää seuraavaan iteraatioon eli kierrokseen.</li>
  <li>Jokainen elossa oleva solu, jolla on yli kolme naapuria kuolee.</li>
  <li>Jokainen kuollut solu, jolla on tasan kolme elossa olevaa naapuria muuttuu eläväksi.</li>
</ul>

<p>Toteuta metodi <code>hoidaSolu(int x, int y, int elossaOleviaNaapureita)</code> ylläolevien sääntöjen mukaan. Kannattaa ohjelmoida ja testata yksi sääntö kerrallaan!</p>

<p>Kun olet saanut kaikki valmiiksi, voit testata ohjelman toimintaa seuraavalla graafisella simulaattorilla.</p>

<pre class="sh_java">
package game;

import gameoflife.Simulaattori;

public class Main {

    public static void main(String[] args) {
        OmaAlusta alusta = new OmaAlusta(100, 100);
        alusta.alustaSatunnaisetPisteet(0.7);

        Simulaattori simulaattori = new Simulaattori(alusta);
        simulaattori.simuloi();
    }
}
</pre>

</div>

<div class="tyhja"></div>

<div class="viikkoraja">Viikko 6</div>

<h2>Muutamia hyödyllisiä tekniikoita</h2>

<p>Kurssin lähestyessä loppua katsomme vielä muutamaa hyödyllistä Javan ominaisuutta.</p>

<h3>Säännölliset lausekkeet</h3>

<p>Säännöllinen lauseke määrittelee tiiviissä muodossa joukon characterStringja. Säännöllisiä lausekkeita käytetään muunmuassa characterStringjen oikeellisuuden tarkistamiseen. Tarkastellaan tehtävää, jossa täytyy tarkistaa, onko käyttäjän antama opiskelijanumero oikeanmuotoinen. Opiskelijanumero alkaa characterStringlla "01", jota seuraa 7 numeroa väliltä 0&ndash;9.</p>

<p>Opiskelijanumeron oikeellisuuden voisi tarkistaa esimerkiksi käymällä opiskelijanumeroa esittävän characterStringn läpi merkki merkiltä <code>charAt</code>-metodin avulla. Toinen tapa olisi tarkistaa että ensimmäinen merkki on "0", ja käyttää <code>Integer.parseInt</code> metodikutsua characterStringn muuntamiseen numeroksi. Tämän jälkeen voisi tarkistaa että <code>Integer.parseInt</code>-metodin palauttama luku on pienempi kuin 20000000.</p>

<p>Oikeellisuuden tarkistus säännöllisten lausekkeiden avulla vaatii ensin sopivan säännöllisen lausekkeen määrittelyn. Tämän jälkeen voimme käyttää <code>String</code>-luokan metodia <code>matches</code>, joka tarkistaa vastaako characterString parametrina annettua säännöllistä lauseketta. Opiskelijanumeron tapauksessa sopiva säännöllinen lauseke on <code>"01[0-9]{7}"</code>, ja käyttäjän syöttämän opiskelijanumeron tarkistaminen käy seuraavasti:</p>

<pre class="sh_java">
System.out.print("Anna opiskelijanumero: ");
String numero = reader.nextLine();

if (numero.matches("01[0-9]{7}")) {
    System.out.println("Muoto on oikea.");
} else {
    System.out.println("Muoto ei ole oikea.");
}
</pre>

<p>Käydään seuraavaksi läpi eniten käytettyjä säännöllisten lausekkeiden merkintöjä.</p>

<h4>Pystyviiva eli vaihtoehtoisuus</h4>

<p>Pystyviiva tarkoittaa, että säännöllisen lausekkeen osat ovat vaihtoehtoisia. Esimerkiksi lauseke <code>00|111|0000</code> määrittelee characterStringt <code>00</code>, <code>111</code> ja <code>0000</code>. Metodi <code>matches</code> palauttaa arvon <code>true</code> jos characterString vastaa jotain määritellyistä vaihtoehdoista.</p>

<pre class="sh_java">
    String characterString = "00";
    
    if(characterString.matches("00|111|0000")) {
        System.out.println("characterStringsta löytyi joku kolmesta vaihtoehdosta");
    } else {
        System.out.println("characterStringsta ei löytynyt yhtäkään vaihtoehdoista");
    }
</pre>

<pre>
characterStringsta löytyi joku kolmesta vaihtoehdosta
</pre>

<p>Säännöllinen lauseke <code>00|111|0000</code> vaatii että characterString on täsmälleen määritellyn muotoinen: se ei määrittele <em>"contains"</em>-toiminnallisuutta.</p>

<pre class="sh_java">
    String characterString = "1111";
    
    if(characterString.matches("00|111|0000")) {
        System.out.println("characterStringsta löytyi joku kolmesta vaihtoehdosta");
    } else {
        System.out.println("characterStringsta ei löytynyt yhtäkään vaihtoehdoista");
    }
</pre>

<pre>
characterStringsta ei löytynyt yhtäkään vaihtoehdoista
</pre>

<h4>Sulut, eli characterStringn osaan rajattu vaikutusalue</h4>

<p>Sulkujen avulla voi määrittää, mihin säännöllisen lausekkeen osaan sulkujen sisällä olevat merkinnät vaikuttavat. Jos haluamme sallia characterStringt <code>00000</code> ja <code>00001</code>, voimme määritellä ne pystyviivan avulla muodossa <code>00000|00001</code>. Sulkujen avulla voimme rajoittaa vaihtoehtoisuuden vain osaan characterStringa. Lauseke <code>0000(0|1)</code> määrittelee characterStringt <code>00000</code> ja <code>00001</code>.</p>

<p>Vastaavasti säännöllinen lauseke <code>auto(|n|a)</code> määrittelee sanan auto yksikön nominatiivin (auto), genetiivin (auton), partitiivin (autoa) ja akkusatiivin (auto tai auton).</p>


<pre class="sh_java">
System.out.print("Kirjoita joku sanan auto yksikön taivutusmuoto: ");
String sana = reader.nextLine();

if (sana.matches("auto(|n|a|ssa|sta|on|lla|lta|lle|na|ksi|tta)")) {
    System.out.println("Oikein meni!");
} else {
    System.out.println("Taivutusmuoto ei ole oikea.");
}
</pre>

<h4>Toistomerkinnät</h4>

<p>Usein halutaan, että characterStringssa toistuu jokin tietty alicharacterString. Säännöllisissä lausekkeissa on käytössä seuraavat toistomerkinnät:</p>

<ul>
<li>Merkintä <strong><code>*</code></strong> toisto 0... kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "trolololololo";
    
    if(characterString.matches("trolo(lo)*")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>
</li>

<li>Merkintä <strong><code>+</code></strong> toisto 1... kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "trolololololo";
    
    if(characterString.matches("tro(lo)+")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>

<pre class="sh_java">
    String characterString = "nänänänänänänänä Bätmään!";
    
    if(characterString.matches("(nä)+ Bätmään!")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>
</li>

<li>Merkintä <strong><code>?</code></strong> toisto 0 tai 1 kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "You have to accidentally the whole meme";
    
    if(characterString.matches("You have to accidentally (delete )?the whole meme")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>
</li>

<li>Merkintä <strong><code>{a}</code></strong> toisto <code>a</code> kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "1010";
    
    if(characterString.matches("(10){2}")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>
</li>

<li>Merkintä <strong><code>{a,b}</code></strong> toisto <code>a</code> ... <code>b</code> kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "1";
    
    if(characterString.matches("1{2,4}")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto ei ole oikea.
</pre>
</li>

<li>Merkintä <strong><code>{a,}</code></strong> toisto <code>a</code> ... kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "11111";
    
    if(characterString.matches("1{2,}")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>
</li>
</ul>

<p>Samassa säännöllisessä lausekkeessa voi käyttää myös useampia toistomerkintöjä. Esimerkiksi säännöllinen lauseke <code>5{3}(1|0)*5{3}</code> määrittelee characterStringt, jotka alkavat ja loppuvat kolmella vitosella. Välissä saa tulla rajaton määrä ykkösiä ja nollia.</p>

<h4>Hakasulut, eli merkkiryhmät</h4>

<p>Merkkiryhmän avulla voi määritellä lyhyesti joukon merkkejä. Merkit kirjoitetaan hakasulkujen sisään, ja merkkivälin voi määrittää viivan avulla. Esimerkiksi merkintä <code>[145]</code> tarkoittaa samaa kuin <code>(1|4|5)</code> ja merkintä <code>[2-36-9]</code> tarkoittaa samaa kuin <code>(2|3|6|7|8|9)</code>. Vastaavasti merkintä <code>[a-c]*</code> määrittelee säännöllisen lausekkeen, joka vaatii että characterString sisältää vain merkkejä <code>a</code>, <code>b</code> ja <code>c</code>.</p>

<div class="tehtavat">

<NEXTWEEK></NEXTWEEK>

<h3>Säännölliset lausekkeet</h3>

<p>Harjoitellaan hieman säännöllisten lausekkeiden käyttöä. Tehtävät tehdään oletuspakkauksessa olevaan luokkaan <code>Paaohjelma</code>.</h3>

<h4 class="req">Viikonpäivä</h4>

<p>Tee säännöllisen lausekkeen avulla luokalle <code>Paaohjelma</code> metodi <code>public static boolean onViikonpaiva(String characterString)</code>, joka palauttaa <code>true</code> jos sen parametrina saama characterString viikonpäivän lyhenne (ma, ti, ke, to, pe, la tai su).</p>

<p>Esimerkkitulostuksia metodia käyttävästä ohjelmasta:</p>

<pre>
Anna characterString: <font color="red">ti</font>
Muoto on oikea.
</pre>

<pre>
Anna characterString: <font color="red">abc</font>
Muoto ei ole oikea.
</pre>

<h4 class="req">Vokaalitarkistus</h4>

<p>Tee luokalle <code>Paaohjelma</code> metodi <code>public static boolean kaikkiVokaaleja(String characterString)</code> joka tarkistaa säännöllisen lausekkeen avulla ovatko parametrina olevan characterStringn kaikki merkit vokaaleja. </p>

<p>Esimerkkitulostuksia metodia käyttävästä ohjelmasta:</p>

<pre>
Anna characterString: <font color="red">aie</font>
Muoto on oikea.
</pre>

<pre>
Anna characterString: <font color="red">ane</font>
Muoto ei ole oikea.
</pre>

<h4 class="req">Kellonaika</h4>

<p>Säännölliset lausekkeet sopivat tietynlaisiin tilanteisiin. Joissain tapaukseesa lausekkeista tulee liian monimutkaisia, ja characterStringn "sopivuus" kannattaa tarkastaa muulla tyylillä tai voi olla tarkoituksenmukaista käyttää säännöllisiä lausekkeita vain osaan tarkastuksesta.</p>

<p>Tee luokalle <code>Paaohjelma</code> metodi <code>public static boolean kellonaika(String characterString)</code>  ohjelma, joka tarkistaa säännöllisen lausekkeen avulla onko parametrina oleva characterString muotoa <code>tt:mm:ss</code> oleva kellonaika (tunnit, minuutit ja sekunnit kaksinumeroisina). Tässä metodissa saat käyttää säännöllisten lausekkeiden lisäksi mitä tahansa muutakin tekniikkaa.</p>

<p>Esimerkkitulostuksia metodia käyttävästä ohjelmasta:</p>

<pre>
Anna characterString: <font color="red">17:23:05</font>
Muoto on oikea.
</pre>

<pre>
Anna characterString: <font color="red">abc</font>
Muoto ei ole oikea.
</pre>

<pre>
Anna characterString: <font color="red">33:33:33</font>
Muoto ei ole oikea.
</pre>

</div>


<h3>Enum eli lueteltu tyyppi</h3>

<p>Toteutimme aiemmin pelikorttia mallintavan luokan <code>Kortti</code> suunilleen seuraavasti:</p>

<pre class="sh_java">
public class Kortti {

    public static final int RUUTU = 0;
    public static final int PATA = 1;
    public static final int RISTI = 2;
    public static final int HERTTA = 3;

    private int arvo;
    private int maa;

    public Kortti(int arvo, int maa) {
        this.arvo = arvo;
        this.maa = maa;
    }

    @Override
    public String toString() {
        return maanNimi() + " "+arvo;
    }

    private String maanNimi() {
        if (maa == 0) {
            return "RUUTU";
        } else if (maa == 1) {
            return  "PATA";
        } else if (maa == 2) {
            return "RISTI";
        }
        return "HERTTA";
    }

    public int getMaa() {
        return maa;
    }
}
</pre>

<p>Kortin maa tallennetaan kortissa olevaan oliomuuttujaan kokonaislukuna. Maan ilmaisemiseen on määritelty luettavuutta helpottavat vakiot. Kortteja ja maita ilmaisevia vakioita käytetään seuraavasti:</p>

<pre class="sh_java">
public static void main(String[] args) {
        Kortti kortti = new Kortti(10, Kortti.HERTTA);

        System.out.println(kortti);

        if (kortti.getMaa() == Kortti.PATA) {
            System.out.println("on pata");
        } else {
            System.out.println("ei ole pata");
        }

}
</pre>

<p>Maan esittäminen numerona on huono ratkaisu, sillä esimerkiksi seuraavat järjenvastaiset tavat käyttää korttia ovat mahdollisia:</p>

<pre class="sh_java">
        Kortti jarjetonKortti = new Kortti(10, 55);

        System.out.println(jarjetonKortti);

        if (jarjetonKortti.getMaa() == 34) {
            System.out.println("kortin maa on 34");
        } else {
            System.out.println("kortin maa on jotain muuta kun 34");
        }

        int maaPotenssiinKaksi = jarjetonKortti.getMaa() * jarjetonKortti.getMaa();

        System.out.println("kortin maa potenssiin kaksi on " + maaPotenssiinKaksi);
</pre>

<p>Jos tiedämme muuttujien mahdolliset arvot ennalta, voimme käyttää niiden esittämiseen <code>enum</code>-tyyppistä luokkaa eli <em>lueteltua tyyppiä</em>. Luetellut tyypit ovat oma luokkatyyppinsä rajapinnan ja normaalin luokan lisäksi. Lueteltu tyyppi määritellään avainsanalla <code>enum</code>. Esimerkiksi seuraava <code>Maa</code>-enumluokka määrittelee neljä vakioarvoa: <code>RUUTU</code>, <code>PATA</code>, <code>RISTI</code> ja <code>HERTTA</code>.</p>

<pre class="sh_java">
public enum Maa {
    RUUTU, PATA, RISTI, HERTTA
}
</pre>

<p>Yksinkertaisimmassa muodossaan <code>enum</code> luettelee pilkulla erotettuina määrittelemänsä vakioarvot. Enumien vakiot on yleensä tapana kirjoittaa kokonaan isoin kirjaimin.</p>

<p>Enum luodaan (yleensä) omaan tiedostoon, samaan tapaan kuin luokka tai rajapinta. NetBeansissa Enumin saa luotua valitsemalla projektin kohdalla <em>new/other/java/java enum</em>. </p>

<p>Seuraavassa luokka <code>Kortti</code> jossa maa esitetään enumin avulla:</p>

<pre class="sh_java">
public class Kortti {

    private int arvo;
    private Maa maa;

    public Kortti(int arvo, Maa maa) {
        this.arvo = arvo;
        this.maa = maa;
    }

    @Override
    public String toString() {
        return maa + " "+arvo;
    }

    public Maa getMaa() {
        return maa;
    }

    public int getArvo() {
        return arvo;
    }
}
</pre>

<p>Kortin uutta versiota käytetään seuraavasti:</p>

<pre class="sh_java">
public class Paaohjelma {

    public static void main(String[] args) {
        Kortti eka = new Kortti(10, Maa.HERTTA);

        System.out.println(eka);

        if (eka.getMaa() == Maa.PATA) {
            System.out.println("on pata");
        } else {
            System.out.println("ei ole pata");
        }

    }
}
</pre>

<p>Tulostuu:</p>

<pre>
HERTTA 10
ei ole pata
</pre>

<p>Huomaamme, että enumin tunnukset tulostuvat mukavasti! Koska kortin maat ovat nyt tyyppiä <code>Maa</code> ei ylemmän esimerkin "järjenvastaiset" kummallisuudet, esim. "maan korottaminen toiseen potenssiin" onnistu. Oraclella on <code>enum</code>-tyyppiin liittyvä sivusto osoitteessa <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html" target="_blank">http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html</a>.</p>

<h3>Iteraattori</h3>

<p>Tarkastellaan seuraavaa luokkaa <code>Kasi</code>, joka mallintaa tietyssä korttipelissä pelaajan kädessä olevien korttien joukkoa:</p>

<pre class="sh_java">
public class Kasi {
    private ArrayList&lt;Kortti&gt; kortit;

    public Kasi() {
        kortit = new ArrayList&lt;Kortti&gt;();
    }

    public void lisaa(Kortti kortti){
        kortit.add(kortti);
    }

    public void tulosta(){
        for (Kortti kortti : kortit) {
            System.out.println( kortti );
        }
    }
}
</pre>

<p>Luokan metodi <code>tulosta</code> tulostaa jokaisen kädessä olevan kortin tutuksi tullutta "for each"-lausetta käyttämällä. ArrayList ja muut <em>Collection</em>-rajapinnan toteuttavat "oliosäiliöt" toteuttavat rajapinnan <em>Iterable</em>. Rajapinnan <em>Iterable</em> toteuttavat oliot on mahdollista käydä läpi eli "iteroida" esimerkiksi. for each -tyyppisellä komennolla.</p>

<p>Oliosäiliö voidaan käydä läpi myös käyttäen ns. <em>iteraattoria</em>, eli olioa, joka on varta vasten tarkoitettu tietyn oliokokoelman läpikäyntiin. Seuraavassa on iteraattoria käyttävä versio korttien tulostamisesta:</p>

<pre class="sh_java">
public void tulosta() {
    Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

    while ( iteraattori.hasNext() ){
        System.out.println( iteraattori.next() );
    }
}
</pre>

<p>Iteraattori pyydetään kortteja sisältävältä arraylistiltä <code>kortit</code>. Iteraattori on ikäänkuin "sormi", joka osoittaa aina tiettyä listan sisällä olevaa olioa, ensin ensimmäistä ja sitten seuraavaa jne... kunnes "sormen" avulla on käyty jokainen olio läpi.</p>

<p>Iteraattori tarjoaa muutaman metodin. Metodilla <code>hasNext()</code> kysytään onko läpikäytäviä olioita vielä jäljellä. Jos on, voidaan iteraattorilta pyytää seuraavana vuorossa oleva olio metodilla <code>next()</code>. Metodi siis palauttaa seuraavana läpikäyntivuorossa olevan olion ja laittaa iteraattorin eli "sormen" osoittamaan seuraavana vuorossa olevaa läpikäytävää olioa.</p>

<p>Iteraattorin next-metodin palauttama olioviite voidaan ottaa toki talteen myös muuttujaan, eli metodi <code>tulosta</code> voitaisiin muotoilla myös seuraavasti:</p>

<pre class="sh_java">
public void tulosta(){
    Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

    while ( iteraattori.hasNext() ){
        Kortti seuraavanaVuorossa = iteraattori.next();
        System.out.println( seuraavanaVuorossa );
    }
}
</pre>

<p>Teemme metodin jonka avulla kädestä voi poistaa tiettyä arvoa pienemmät kortit:</p>

<pre class="sh_java">
public class Kasi {
    // ...

    public void poistaHuonommat(int arvo) {
        for (Kortti kortti : kortit) {
            if ( kortti.getArvo() &lt; arvo ) {
                kortit.remove(kortti);
            }
        }
    }
}
</pre>

<p>Huomaamme että metodin suoritus aiheuttaa kummallisen virheen:</p>

<pre>
Exception in thread "main" java.util.ConcurrentModificationException
        at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)
        at java.util.AbstractList$Itr.next(AbstractList.java:343)
        at Kasi.poistaHuonommat(Kasi.java:26)
        at Paaohjelma.main(Paaohjelma.java:20)
Java Result: 1
</pre>

<p>Virheen syynä on se, että for-each:illa listaa läpikäydessä ei ole sallittua poistaa listalta olioita: komento for-each menee tästä "sekaisin".</p>

<p>Jos listalta halutaan poistaa osa olioista läpikäynnin aikana osa, tulee tämä tehdä iteraattoria käyttäen. Iteraattori-olion metodia <code>remove</code> kutsuttaessa listalta poistetaan siististi se alkio jonka iteraattori palautti edellisellä metodin <code>next</code> kutsulla. Toimiva versio metodista seuraavassa:</p>

<pre class="sh_java">
public class Kasi {
    // ...

    public void poistaHuonommat(int arvo) {
        Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

        while (iteraattori.hasNext()) {
            if (iteraattori.next().getArvo() &lt; arvo) {
                // poistetaan listalta olio jonka edellinen next-metodin kutsu palautti
                iteraattori.remove();   
            }
        }
    }
}
</pre>


<div class="tehtavat">

<h3>Enum ja Iteraattori</h3>

<p>Tehdään ohjelma pienen yrityksen henkilöstön hallintaan.</p>

<h4>Koulutus</h4>

<p>Tee pakkaukseen <code>henkilosto</code> lueteltu tyyppi eli enum <code>Koulutus</code> jolla on tunnukset <code>FT</code> (tohtori), <code>FM</code> (maisteri), <code>LuK</code> (kandidaatti), <code>FilYO</code> (ylioppilas).</p>

<h4>Person</h4>

<p>Tee pakkaukseen <code>henkilosto</code> luokka Luokka <code>Person</code>. Henkilölle annetaan konstruktorin parametrina annettava nimi ja koulutus. Henkilöllä on myös koulutuksen kertova metodi <code>public Koulutus getKoulutus()</code> sekä alla olevan esimerkin mukaista jälkeä tekevä <code>toString</code>-metodi.</p>

<pre class="sh_java">
    Person arto = new Person("Arto", Koulutus.FT);
    System.out.println(arto);
</pre>

<pre>
Arto, FT
</pre>


<h4>Tyontekijat</h4>

<p>Tee pakkaukseen <code>henkilosto</code> luokka Luokka <code>Tyontekijat</code>. Työntekijät-olio sisältää listan Person-olioita. Luokalla on parametriton konstruktori ja seuraavat metodit:</p>

<ul>
  <li><code>public void lisaa(Person lisattava)</code> lisää parametrina olevan henkilön työntekijäksi</li>
  <li><code>public void lisaa(List&lt;Person&gt; lisattavat)</code> lisää parametrina olevan listan henkilöitä työntekijöiksi</li>
  <li><code>public void tulosta()</code> tulostaa kaikki työntekijät</li>
  <li><code>public void tulosta(Koulutus koulutus)</code> tulostaa työntekijät joiden koulutus on sama kuin parametrissa määritelty koulutus</li>
</ul>

<p><strong>HUOM:</strong> Luokan <code>Tyontekijat</code> <code>tulosta</code>-metodit on toteutettava iteraattoria käyttäen!</p>

<h4>Irtisanominen</h4>

<p>Tee luokalle  <code>Tyontekijat</code> metodi <code>public void irtisano(Koulutus koulutus)</code> joka poistaa Työntekijöiden joukosta kaikki henkilöt joiden koulutus on sama kuin metodin parametrina annettu.</p>

<p><strong>HUOM:</strong> toteuta metodi iteraattoria käyttäen!</p>

<p>Seuraavassa esimerkki luokan käytöstä:</p>

<pre class="sh_java">
Public class Paaohjelma {

    public static void main(String[] args) {
        Tyontekijat yliopisto = new Tyontekijat();
        yliopisto.lisaa(new Person("Matti", Koulutus.FT));
        yliopisto.lisaa(new Person("Pekka", Koulutus.FilYO));
        yliopisto.lisaa(new Person("Arto", Koulutus.FT));

        yliopisto.tulosta();

        yliopisto.irtisano(Koulutus.FilYO);

        System.out.println("==");

        yliopisto.tulosta();
}
</pre>

<p>Tulostuu:</p>

<pre>
Matti, FT
Pekka, FilYO
Arto, FT
==
Matti, FT
Arto, FT
</pre>

</div>

<h3>Toistolauseet ja continue</h3>

<p>Toistolauseissa on komennon <code>break</code> lisäksi käytössä komento <code>continue</code>, joka mahdollistaa seuraavaan toistokierrokseen hyppäämisen.</p>

<pre class="sh_java">
    List&lt;String&gt; nimet = Arrays.asList("Matti", "Pekka", "Arto");
    
    for(String name: nimet) {
        if (nimi.equals("Arto")) {
            continue;
        }

        System.out.println(nimi);
    }
</pre>

<pre>
Matti
Pekka
</pre>

<p>Komentoa <code>continue</code> käytetään esimerkiksi silloin, kun tiedetään että toistolauseessa iteroitavilla muuttujilla on arvoja, joita ei haluta käsitellä lainkaan. Klassinen lähestymistapa olisi if-lauseen käyttö, mutta komento <code>continue</code> mahdollistaa sisennyksiä välttävän, ja samalla ehkä luettavamman lähestymistavan käsiteltävien arvojen välttämiseen. Alla on kaksi esimerkkiä, jossa käydään listalla olevia lukuja läpi. Jos luku on alle 5, se on jaollinen sadalla, tai se on jaollinen neljälläkymmenellä, niin sitä ei tulosteta, muulloin se tulostetaan. </p>

<pre class="sh_java">
    List&lt;Integer&gt; values = Arrays.asList(1, 3, 11, 6, 120);
    
    for(int luku: values) {
        if (luku > 4 && luku % 100 != 0 && luku % 40 != 0) {
            System.out.println(luku);
        }
    }

    for(int luku: values) {
        if (luku &lt; 5) {
            continue;
        }

        if (luku % 100 == 0) {
            continue;
        }

        if (luku % 40 == 0) {
            continue;
        }
        
        System.out.println(luku);
    }
</pre>

<pre>
11
6
11
6
</pre>

<h3>Lisää enumeista</h3>

<p>Luodaan seuraavaksi lueteltuja tyyppejä jotka sisältävät oliomuuttujia ja toteuttavat rajapinnan.</p>

<h4>Luetellun tyypin konstruktorin parametrit</h4>

<p>Luetellut tyypit voivat sisältää oliomuuttujia. Oliomuuttujien arvot tulee asettaa luetellun tyypin määrittelevän luokan sisäisessä konstruktorissa. Enum-tyyppisillä luokilla ei saa olla <code>public</code>-konstruktoria.</p>

<pre class="sh_java">
public enum Vari {
    PUNAINEN("punainen"), // konstruktorin parametrit määritellään vakioarvoja lueteltaessa
    VIHREA("vihreä"),
    SININEN("sininen");

    private String name; // oliomuuttuja

    private Vari(String name) { // konstruktori
        this.name = nimi;
    }

    public String getName() {
        return this.name;
    }
}  
</pre>

<p>Lueteltua tyyppiä <code>Vari</code> voidaan käyttää esimerkiksi seuraavasti:</p>
<pre class="sh_java">
    System.out.println(Vari.VIHREA.getName());
</pre>

<pre>
vihreä
</pre>


<div class="tehtavat">

<h3>Elokuvien suosittelija</h3>

<p>Hiljattain Suomeen rantautunut <a href="https://signup.netflix.com/" target="_blank">Netflix</a> lupasi lokakuussa 2006 miljoona dollaria henkilölle tai ryhmälle, joka kehittäisi ohjelman, joka on 10% parempi elokuvien suosittelussa kuin heidän oma ohjelmansa. Kilpailu ratkesi syyskuussa 2009 (<a href="http://www.netflixprize.com/" target="_blank">http://www.netflixprize.com/</a>).</p>

<p>Rakennetaan tässä tehtävässä ohjelma elokuvien suositteluun. Alla on sen toimintaesimerkki:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");
    Person thomas = new Person("Thomas");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.HUONO);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);
    

    Suosittelija suosittelija = new Suosittelija(arviot);
    System.out.println(thomas + " suositus: " + 
            suosittelija.suositteleElokuva(thomas));
    System.out.println(mikke + " suositus: " + 
            suosittelija.suositteleElokuva(mikke));
</pre>

<pre>
Thomas suositus: Hiljaiset sillat
Mikke suositus: Tuulen viemää
</pre>

<p>Ohjelma osaa suositella elokuvia niiden yleisen arvion perusteella, sekä henkilökohtaisten henkilön antaminen arvioiden perusteella. Lähdetään rakentamaan ohjelmaa.</p>

<h4>Person ja Elokuva</h4>

<p>Luo pakkaus <code>suosittelija.domain</code> ja lisää sinne luokat <code>Person</code> ja <code>Elokuva</code>. Kummallakin luokalla on julkinen konstruktori <code>public <em>Luokka</em>(String name)</code>, sekä metodi <code>public String getName()</code>, joka palauttaa konstruktorissa saadun nimen.</p>

<pre class="sh_java">
    Person henkilo = new Person("Pekka");
    Elokuva elokuva = new Elokuva("Eraserhead");

    System.out.println(henkilo.getName() + " ja " + elokuva.getName());
</pre>

<pre>
Pekka ja Eraserhead
</pre>

<p>Lisää luokille myös <code>public String toString()</code>-metodi, joka palauttaa konstruktorissa parametrina annetun nimen, sekä korvaa metodit <code>equals</code> ja <code>hashCode</code>.</p>

<p>
Korvaa <code>equals</code> siten että samuusvertailu tapahtuu oliomuuttujan <code>nimi</code> perusteella. Katso mallia luvusta 45.1. Luvussa 45.2. on ohje metodin <code>hashCode</code> korvaamiselle. Ainakin HashCode kannattaa generoida automaattisesti luvun lopussa olevan ohjeen mukaan:</p> 

<p>
<em>
NetBeans tarjoaa metodien equals ja hashCode automaattisen luonnin. Voit valita valikosta Source -> Insert Code, ja valita aukeavasta listasta equals() and hashCode(). Tämän jälkeen NetBeans kysyy oliomuuttujat joita metodeissa käytetään.</em>
</p>

<p><strong>Huom:</strong> virheiden etsimisen helpottamiseksi kannattaa ehkä toteuttaa henkilölle ja elokuvalle toString-metodit. Testit eivät niitä vaadi.</p>

<h4>Arvio</h4>

<p>Luo pakkaukseen <code>suosittelija.domain</code> lueteltu tyyppi <code>Arvio</code>. Enum-luokalla <code>Arvio</code> on julkinen metodi <code>public int getArvo()</code>, joka palauttaa arvioon liittyvän arvon. Arviotunnusten ja niihin liittyvien arvosanojen tulee olla seuraavat:</p>

<p>
<table style="padding-left:2em">
  <tr><th>Tunnus</th><th>Arvo</th></tr>
  <tr><td>HUONO</td><td>-5</td></tr>
  <tr><td>VALTTAVA</td><td>-3</td></tr>
  <tr><td>EI_NAHNYT</td><td>0</td></tr>
  <tr><td>NEUTRAALI</td><td>1</td></tr>
  <tr><td>OK</td><td>3</td></tr>
  <tr><td>HYVA</td><td>5</td></tr>
</table>
</p>

<p>Luokkaa voi käyttää seuraavasti:</p>
<pre class="sh_java">
    Arvio annettu = Arvio.HYVA;
    System.out.println("Arvio " + annettu + ", arvo " + annettu.getArvo());
    annettu = Arvio.NEUTRAALI;
    System.out.println("Arvio " + annettu + ", arvo " + annettu.getArvo());
</pre>

<pre>
Arvio HYVA, arvo 5
Arvio NEUTRAALI, arvo 1
</pre>

<h4>ArvioRekisteri, osa 1</h4>

<p>Aloitetaan arvioiden varastointiin liittyvän palvelun toteutus.</p>

<p>Luo pakkaukseen <code>suosittelija</code> luokka <code>ArvioRekisteri</code>, jolla on konstruktori <code>public ArvioRekisteri()</code> sekä seuraavat metodit:</p>

<ul>
  <li><code>public void lisaaArvio(Elokuva elokuva, Arvio arvio)</code> lisää arviorekisteriin parametrina annetulle elokuvalle uuden arvion. Samalla elokuvalla voi olla useita samanlaisiakin arvioita.</li>
  <li><code>public List&lt;Arvio&gt; annaArviot(Elokuva elokuva)</code> palauttaa elokuvalle lisätyt arviot listana.</li>
  <li><code>public Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot()</code> palauttaa mapin, joka sisältää arvioidut elokuvat avaimina. Jokaiseen elokuvaan liittyy lista, joka sisältää elokuvaan lisatyt arviot.</li>
</ul>

<p>Testaa metodien toimintaa seuraavalla lähdekoodilla:</p>

<pre class="sh_java">
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    ArvioRekisteri rekisteri = new ArvioRekisteri();
    rekisteri.lisaaArvio(eraserhead, Arvio.HUONO);
    rekisteri.lisaaArvio(eraserhead, Arvio.HUONO);
    rekisteri.lisaaArvio(eraserhead, Arvio.HYVA);

    rekisteri.lisaaArvio(hiljaisetSillat, Arvio.HYVA);
    rekisteri.lisaaArvio(hiljaisetSillat, Arvio.OK);

    System.out.println("Kaikki arviot: " + rekisteri.elokuvienArviot());
    System.out.println("Arviot Eraserheadille: " + rekisteri.annaArviot(eraserhead));
</pre>

<pre>
Kaikki arviot: {Hiljaiset sillat=[HYVA, OK], Eraserhead=[HUONO, HUONO, HYVA]}
Arviot Eraserheadille: [HUONO, HUONO, HYVA]
</pre>


<h4>ArvioRekisteri, osa 2</h4>

<p>Lisätään seuraavaksi mahdollisuus henkilökohtaisten arvioiden lisääiseen.</p>

<p>Lisää luokkaan <code>ArvioRekisteri</code> seuraavat metodit:</p>

<ul>
  <li><code>public void lisaaArvio(Person henkilo, Elokuva elokuva, Arvio arvio)</code> lisää parametrina annetulle elokuvalle tietyn henkilön tekemän arvion. Sama henkilö voi arvioida tietyn elokuvan vain kertaalleen. Henkilön tekemä arvio tulee myös lisätä kaikkiin elokuviin liittyviin arvioihin.</li>
  <li><code>public Arvio haeArvio(Person henkilo, Elokuva elokuva)</code> palauttaa parametrina annetun henkilön tekemän arvion parametrina annetulle elokuvalle. Jos henkilö ei ole arvioinut kyseistä elokuvaa, palauta arvio <code>Arvio.EI_NAHNYT</code>.</li>
 <li><code>public Map&lt;Elokuva, Arvio&gt; annaPersonnArviot(Person henkilo)</code> palauttaa hajautustaulun, joka sisältää henkilön tekemät arviot. Hajautustaulun avaimena on arvioidut elokuvat, arvoina arvioituihin elokuviin liittyvät arviot.</li> 
 <li><code>public List&lt;Person&gt; arvioijat()</code> palauttaa listan henkilöistä jotka ovat arvioineet elokuvia.</li></ul>

<p>Henkilöiden tekemät arviot kannattanee tallentaa hajautustauluun, jossa avaimena on henkilö. Arvona hajautustaulussa on toinen hajautustaulu, jossa avaimena on elokuva ja arvona arvio.</p>

<p>Testaa paranneltua <code>ArvioRekisteri</code>-luokkaa seuraavalla lähdekoodipätkällä:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.OK);

    System.out.println("Arviot Eraserheadille: " + arviot.annaArviot(eraserhead));
    System.out.println("Matin arviot: " + arviot.annaPersonnArviot(matti));
    System.out.println("Arvioijat: " + arviot.arvioijat());
</pre>

<pre>
Arviot Eraserheadille: [OK, OK]
Matin arviot: {Tuulen viemää=HUONO, Eraserhead=OK}
Arvioijat: [Pekka, Matti]
</pre>

<p>Luodaan seuraavaksi muutama apuluokka arviointien helpottamiseksi.</p>

<h4>PersonComparator</h4>

<p>Luo pakkaukseen <code>suosittelija.comparator</code> luokka <code>PersonComparator</code>. Luokan <code>PersonComparator</code> tulee toteuttaa rajapinta <code>Comparator&lt;Person&gt;</code>, ja sillä pitää olla konstruktori <code>public PersonComparator(Map&lt;Person, Integer&gt; henkiloidenSamuudet)</code>. Luokkaa <code>PersonComparator</code> käytetään myöhemmin henkilöiden järjestämiseen henkilöön liittyvän luvun perusteella.</p>

<p>PersonComparator-luokan tulee mahdollistaa henkilöiden järjestäminen henkilöön liittyvän luvun perusteella.</p>

<p>Testaa luokan toimintaa seuraavalla lähdekoodilla:</p>

<pre class="sh_java">
    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");
    Person thomas = new Person("Thomas");

    Map&lt;Person, Integer&gt; henkiloidenSamuudet = new HashMap&lt;Person, Integer&gt;();
    henkiloidenSamuudet.put(matti, 42);
    henkiloidenSamuudet.put(pekka, 134);
    henkiloidenSamuudet.put(mikke, 8);
    henkiloidenSamuudet.put(thomas, 82);
    
    List&lt;Person&gt; henkilot = Arrays.asList(matti, pekka, mikke, thomas);
    System.out.println("Henkilöt ennen järjestämistä: " + henkilot);

    Collections.sort(henkilot, new PersonComparator(henkiloidenSamuudet));
    System.out.println("Henkilöt järjestämisen jälkeen: " + henkilot);
</pre>

<pre>
Henkilöt ennen järjestämistä: [Matti, Pekka, Mikke, Thomas]
Henkilöt järjestämisen jälkeen: [Pekka, Thomas, Matti, Mikke]
</pre>

<h4>ElokuvaComparator</h4>


<p>Luo pakkaukseen <code>suosittelija.comparator</code> luokka <code>ElokuvaComparator</code>. Luokan <code>ElokuvaComparator</code> tulee toteuttaa rajapinta <code>Comparator&lt;Elokuva&gt;</code>, ja sillä pitää olla konstruktori <code>public ElokuvaComparator(Map&lt;Elokuva, List&lt;Arvio&gt;&gt; arviot)</code>. Luokkaa <code>ElokuvaComparator</code> käytetään myöhemmin elokuvien järjestämiseen niiden arvioiden perusteella.</p>

<p>ElokuvaComparator-luokan tulee tarjota mahdollisuus elokuvien järjestäminen niiden saamien arvosanojen keskiarvon perusteella. Korkeimman keskiarvon saanut elokuva tulee ensimmäisenä, matalimman keskiarvon saanut viimeisenä.</p>

<p>Testaa luokan toimintaa seuraavalla lähdekoodilla:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.HUONO);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);

    Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot = arviot.elokuvienArviot();

    List&lt;Elokuva&gt; elokuvat = Arrays.asList(tuulenViemaa, hiljaisetSillat, eraserhead);
    System.out.println("Elokuvat ennen järjestämistä: " + elokuvat);

    Collections.sort(elokuvat, new ElokuvaComparator(elokuvienArviot));
    System.out.println("Elokuvat järjestämisen jälkeen: " + elokuvat);
</pre>

<pre>
Elokuvat ennen järjestämistä: [Tuulen viemää, Hiljaiset sillat, Eraserhead]
Elokuvat järjestämisen jälkeen: [Hiljaiset sillat, Tuulen viemää, Eraserhead]
</pre>


<h4>Suosittelija, osa 1</h4>

<p>Toteuta pakkaukseen <code>suosittelija</code> luokka <code>Suosittelija</code>. Luokan <code>Suosittelija</code> konstruktori saa parametrinaan <code>ArvioRekisteri</code>-tyyppisen olion. Suosittelija käyttää arviorekisterissä olevia arvioita suositusten tekemiseen.</p>

<p>Toteuta luokalle metodi <code>public Elokuva suositteleElokuva(Person henkilo)</code>, joka suosittelee henkilölle elokuvia.

Toteuta metodi ensin siten, että se suosittelee aina elokuvaa, jonka arvioiden arvosanojen keskiarvo on suurin. Vinkki: Tarvitset parhaan elokuvan selvittämiseen ainakin aiemmin luotua <code>ElokuvaComparator</code>-luokkaa, luokan <code>ArvioRekisteri</code> metodia <code>public Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot()</code>, sekä listaa olemassaolevista elokuvista.</p>

<p>Testaa ohjelman toimimista seuraavalla lähdekoodilla:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikael");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.VALTTAVA);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    Suosittelija suosittelija = new Suosittelija(arviot);
    Elokuva suositeltu = suosittelija.suositteleElokuva(mikke);
    System.out.println("Mikaelille suositeltu elokuva oli: " + suositeltu); 
</pre>

<pre>
Mikaelille suositeltu elokuva oli: Hiljaiset sillat
</pre>

<p>Nyt tekemämme ensimmäinen vaihe toimii oikein ainoastaan henkilöille, jotka eivät ole vielä arvostelleet yhtään elokuvaa. Heidän elokuvamaustaanhan on mahdoton sanoa mitään ja paras arvaus on suositella heille keskimäärin parhaan arvosanan saanutta elokuvaa. </p>

<h4>Suosittelija, osa 2</h4>

<p><em>Huom! Tehtävä on haastava. Kannattaa tehdä ensin muut tehtävät ja palata tähän myöhemmin. Voit palauttaa tehtäväsarjan TMC:hen vaikket saakaan tätä tehtävää tehdyksi, aivan kuten muidenkin tehtävien kohdalla.</em></p>

<p>Valitettavasti tämän osan virhediagnostiikkakaan ei ole samaa luokkaa kuin edellisissä kohdissa.</p>

<p>Jos henkilöt ovat lisänneet omia suosituksia suosituspalveluun, tiedämme jotain heidän elokuvamaustaan. Laajennetaan suosittelijan toiminnallisuutta siten, että se luo henkilökohtaisen suosituksen jos henkilö on jo arvioinut elokuvia. Edellisessä osassa toteutettu toiminnallisuus tulee säilyttää: Jos henkilö ei ole arvioinut yhtäkään elokuvaa, hänelle suositellaan elokuva arvosanojen perusteella.</p>

<p>Henkilökohtaiset suositukset perustuvat henkilön tekemien arvioiden samuuteen muiden henkilöiden tekemien arvioiden kanssa. Pohditaan seuraavaa taulukkoa, missä ylärivillä on elokuvat, ja vasemmalla on arvioita tehneet henkilöt. Taulukon solut kuvaavat annettuja arvioita.</p>

<p>
    <table style="padding-left:2em">
      <tr><th>Person \ Elokuva</th><td>Tuulen viemää</td><td>Hiljaiset sillat</td><td>Eraserhead</td><td>Blues Brothers</td></tr>
      <tr><td>Matti</td><td>HUONO (-5)</td><td>HYVA (5)</td><td>OK (3)</td><td>-</td></tr>
      <tr><td>Pekka</td><td>OK (3)</td><td>-</td><td>HUONO (-5)</td><td>VALTTAVA (-3)</td></tr>
      <tr><td>Mikael</td><td>-</td><td>-</td><td>HUONO (-5)</td><td>-</td></tr>
      <tr><td>Thomas</td><td>-</td><td>HYVA (5)</td><td>-</td><td>HYVA (5)</td></tr>
    </table>
</p>

<p>Kun haluamme hakea Mikaelille sopivaa elokuvaa, tutkimme Mikaelin samuutta kaikkien muiden arvioijien kesken. Samuus lasketaan arvioiden perusteella: samuus on kummankin katsomien elokuvien arvioiden tulojen summa. Esimerkiksi Mikaelin ja Thomasin samuus on 0, koska Mikael ja Thomas eivät ole katsoneet yhtäkään samaa elokuvaa.</p>

<p>Mikaelin ja Pekan samuutta laskettaessa yhteisten elokuvien tulojen summa olisi 25. Mikael ja Pekka ovat katsoneet vain yhden yhteisen elokuvan, ja kumpikin antaneet sille arvosanan huono (-5).</p>

<pre>
-5 * -5 = 25
</pre>

<p>Mikaelin ja Matin samuus on -15. Mikael ja Matti ovat myös katsoneet vain yhden yhteisen elokuvan. Mikael antoi elokuvalle arvosanan huono (-5), Matti antoi sille arvosanan ok (3).</p>

<pre>
-5 * 3 = -15
</pre>

<p>Näiden perusteella Mikaelille suositellaan elokuvia Pekan elokuvamaun mukaan: suosituksena on elokuva Tuulen viemää.</p>


<p>Kun taas haluamme hakea Matille sopivaa elokuvaa, tutkimme Matin samuutta kaikkien muiden arvioijien kesken. Matti ja Pekka ovat katsoneet kaksi yhteistä elokuvaa. Matti antoi Tuulen viemälle arvosanan huono (-5), Pekka arvosanan OK (3). Elokuvalle Eraserhead Matti antoi arvosanan OK (3), Pekka arvosanan huono (-5). Matin ja Pekan samuus on siis -30.</p>

<pre>
-5 * 3 + 3 * -5 = -30
</pre>

<p>Matin ja Mikaelin samuus on edellisestä laskusta tiedetty -15. Samuudet ovat symmetrisia.</p>

<p>Matti ja Thomas ovat katsoneet Tuulen viemää, ja kumpikin antoi sille arvosanan hyvä (5). Matin ja Thomaksen samuus on siis 25.</p>

<pre>
5 * 5 = 25
</pre>

<p>Matille tulee siis suositella elokuvia Thomaksen elokuvamaun mukaan: suosituksena olisi Blues Brothers.</p>

<p>Toteuta yllä kuvattu suosittelumekanismi. Jos henkilölle ei löydy yhtään suositeltavaa elokuvaa, tai henkilö, kenen elokuvamaun mukaan elokuvia suositellaan on arvioinut elokuvat joita henkilö ei ole vielä katsonut huonoiksi, välttäviksi tai neutraaleiksi, palauta metodista <code>suositteleElokuva</code> arvo <code>null</code>. Edellisessä tehtävässä määritellyn lähestymistavan tulee toimia jos henkilö ei ole lisännyt yhtäkään arviota.</p>

<p>Älä suosittele elokuvia, jonka henkilö on jo nähnyt.</p>

<p>Voit testata ohjelmasi toimintaa seuraavalla lähdekoodilla:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");
    Elokuva bluesBrothers = new Elokuva("Blues Brothers");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikael");
    Person thomas = new Person("Thomas");
    Person arto = new Person("Arto");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.HUONO);
    arviot.lisaaArvio(pekka, bluesBrothers, Arvio.VALTTAVA);
    
    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);
    
    arviot.lisaaArvio(thomas, bluesBrothers, Arvio.HYVA);
    arviot.lisaaArvio(thomas, hiljaisetSillat, Arvio.HYVA);

    Suosittelija suosittelija = new Suosittelija(arviot);
    System.out.println(thomas + " suositus: " + suosittelija.suositteleElokuva(thomas));
    System.out.println(mikke + " suositus: " + suosittelija.suositteleElokuva(mikke));
    System.out.println(matti + " suositus: " + suosittelija.suositteleElokuva(matti));
    System.out.println(arto + " suositus: " + suosittelija.suositteleElokuva(arto));
</pre>

<pre>
Thomas suositus: Eraserhead
Mikael suositus: Tuulen viemää
Matti suositus: Blues Brothers
Arto suositus: Hiljaiset sillat
</pre>

<p>Miljoona käsissä? Ei ehkä vielä. Kursseilla Johdatus tekoälyyn ja Johdatus koneoppimiseen opitaan lisää tekniikoita oppivien järjestelmien rakentamiseen.</p>

</div>

<h3>Vaihteleva määrä parametreja metodille</h3>

<p>Olemme tähän mennessä luoneet metodimme siten, että niiden parametrien määrät ovat olleet selkeästi määritelty. Java tarjoaa tavan antaa metodille rajoittamattoman määrän määrätyntyyppisiä parametreja asettamalla metodimäärittelyssä parametrin tyypille kolme pistettä perään. Esimerkiksi metodille <code>public int sum(int... values)</code> voi antaa summattavaksi niin monta <code>int</code>-tyyppistä kokonaislukua kuin käyttäjä haluaa. Metodin sisällä parametrin arvoja voi käsitellä taulukkona.</p>

<pre class="sh_java">
    public int sum(int... values) {
        int sum = 0;
        for (int i = 0; i < values.length; i++) {
            summa += values[i];
        }
        return summa;
    }
</pre>

<pre class="sh_java">
    System.out.println(summa(3, 5, 7, 9));  // values = {3, 5, 7, 9}
    System.out.println(summa(1, 2));        // values = {1, 2}
</pre>

<pre>
24
3
</pre>

<p>Huomaa yllä miten parametrimäärittely <code>int... values</code> johtaa siihen, että metodin sisällä näkyy taulukkotyyppinen muuttuja <code>values</code>.</p>

<p>Metodille voi määritellä vain yhden parametrin joka saa rajattoman määrän arvoja, ja sen tulee olla metodimäärittelyn viimeinen parametri. Esimerkiksi:</p>

<pre class="sh_java">
    public void tulosta(String... characterStringt, int times) // ei sallittu!
    public void tulosta(int times, String... characterStringt) // sallittu!
</pre>

<p>Ennalta määrittelemätöntä parametrien arvojen määrää käytetään esimerkiksi silloin, kun halutaan tarjota rajapinta, joka ei rajoita sen käyttäjää tiettyyn parametrien määrään. Vaihtoehtoinen lähestymistapa on metodimäärittely, jolla on parametrina tietyn tyyppinen lista. Tällöin oliot voidaan asettaa listaan ennen metodikutsua, ja kutsua metodia antamalla lista sille parametrina.</p>

<div class="tehtavat">

<h3>JoustavatHakuehdot</h3>

<p>Muutamassa tehtävässä (mm. ohpen kirjasto ja ohjan sanatutkimus) törmäsimme tilanteeseen jossa houduimme filtteröimään listasta olioita jotain hakuehtoa vastaavat oliot, esim. sanatutkimuksessa metodit <code>zSisaltava, lLoppuiset, palindromit, kaikkiVoksSis</code> tekivät oleellisesti saman asian: kävivät läpi tiedoston sisällön sana kerrallaan ja tarkastivat jokaisen sanan kohdalla päteekö sille tietty ehto ja jos pätee, ottivat sanan talteen. Koska kaikkien metodien ehto oli erilainen, ei toisteisuutta tehtävissä osattu poistaa vaan kaikkien koodi oli ehtoa vaille "copypastea". </p>

<p>Tässä tehtävässä teemme ohjelman, jonka avulla on mahdollista fitlteröidä rivejä <a href="">Project Guttenbergin</a> sivuilta löytyvistä kirjoista. Seuraavassa esimerkkinä Dostojevskin Rikos ja rangaistus. Haluamme, että erilaisia filtteröintiehtoja on monelaisia ja että filtteröinti voi tapahtua myös eri ehtojen kombinaationa. Ohjelman rakenteen pitää myös mahdollistaa uusien ehtojen lisääminen myöhemmin.</p>

<p>Sopiva ratkaisu tilanteeseen filtteröintiehtojen määritteleminen omina rajapinnan <code>Ehto</code>toteuttavina olioina. Seuraavassa rajapinnan määritelmä:</p>

<pre class="sh_java">
public interface Ehto {
    boolean toteutuu(String rivi);
}
</pre>

<p>Seuraavassa eräs rajapinnan toteuttava filtteriluokka:</p>

<pre class="sh_java">
public class SisaltaaSanan implements Ehto {

    String sana;

    public SisaltaaSanan(String sana) {
        this.sana = sana;
    }

    @Override
    public boolean toteutuu(String rivi) {
        return rivi.contains(sana);
    }    
}
</pre>

<p>Luokan oliot ovat siis hyvin yksinkertaisia, ne muistavat konstruktorin parametrina annetun sanan. Olion ainoalta metodilta voi kysyä toteutuuko ehto parametrina olevalle characterStringlle, ja ehdon toteutuminen tarkoittaa olion tapauksessa sisältääkö characterString olion mustaman sanan.</p>

<p>Tehtäväpohjan mukana saat valmiina luokan <code>GutenbergLukija</code> jonka avulla voit tutkia kirjojen rivejä filtteröitynä parametrina annetun hakuehdon perusteella:</p>

<pre class="sh_java">
public class GutenbergLukija {

    private List&lg;String&gt; sanat;

    public GutenbergLukija(String osoite) throws IllegalArgumentException {
        // kirjan verkosta hakeva koodi
    }
    
    public List&lg;String&gt; rivitJoilleVoimassa(Ehto ehto){
        List&lg;String&gt; ehdonTayttavat = new ArrayList&lg;String&gt;();
        
        for (String rivi : sanat) {
            if ( ehto.toteutuu(rivi)) {
                ehdonTayttavat.add(rivi);
            }
        }
        
        return ehdonTayttavat;
    }
}
</pre>

<p>Seuraavassa tulostetaan Rikoksesta ja rangaistuksesta kaikki rivit joilla esiintyy sana "beer":</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new SisaltaaSanan("beer");
        
    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>Kaikki sanat</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>KaikkiRivit</code> joka kelpuuttaa jokaisen rivin.</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new KaikkiRivit();
        
    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>Loppuu huuto- tai kysymysmerkkiin</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>LoppuuHuutoTaiKysymysmerkkiin</code> joka kelpuuttaa ne rivit, joiden viimeinen merkki on huuto- tai kysymysmerkki.</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new LoppuuHuutoTaiKysymysmerkkiin();
        
    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<p><strong>Muistutus:</strong> merkkien vertailu Javassa tapahtuu == operaattorilla:</p>

<pre class="sh_java">
String name = "pekka";

// HUOM: 'p' on merkki eli char p, "p" taas merkkojono jonka ainoa merkki on p
if ( nimi.charAt(0) == 'p' ) {
    System.out.println("alussa p");
} else {
    System.out.println("alussa jokin muu kuin p");
}
</pre>

<h4>Pituus vähintää</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>PituusVahintaan</code> joka oliot kelpuuttavat ne rivit, joiden pituus on vähintään olion konstruktorin parametrina annettu luku.</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new PituusVahintaan(40);
        
    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>molemmat</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>Molemmat</code>. Luokan oliot saavat konstruktorin parametrina kaksi rajapinnan <code>Ehto</code> toteuttavaa olioa. Molemmat-olio kelpuuttavat ne rivit, jotka sen molemmat konstruktorissa saamat ehdot kelpuuttavat.
Seuraavassa tulostetaan kaikki huuto- tai kysymysmerkkiin loppuvat rivit jotka sisältävät sanan "beer".
</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new Molemmat(
                    new LoppuuHuutoTaiKysymysmerkkiin(),
                    new SisaltaaSanan("beer")
                );

    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>negaatio</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>Ei</code>. Luokan oliot saav parametrina rajapinna <code>Ehto</code> toteuttavaavan olioan. Ei-olio kelpuuttavat ne rivit, joita sen parametrina saama ehto ei kelpuuta.
Seuraavassa tulostetaan rivit, joiden pituus vähemmän kuin 10.
</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new Ei( new PituusVahintaan(10) );
      
    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>vähintään yksi</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>VahintaanYksi</code>. Luokan oliot saavat konstruktorin parametrina mielivaltaisen määtän rajapinnan <code>Ehto</code> toteuttavaa olioa, konstruktorissa siis käytetävä vaihtuvanmittaista parametrilistaa. VahintaanYksi-olio kelpuuttavat ne rivit, jotka vähintään yksi sen konstruktoriparametrina saamista ehdoista kelpuuttaa. Seuraavassa tulostetaan rivit jotka sisältävät sanan jonkun sanoista "beer", "milk" tai "oil".
</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new VahintaanYksi(
                    new SisaltaaSanan("beer"),
                    new SisaltaaSanan("milk"),
                    new SisaltaaSanan("oil")
                );

    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<p>Huomaa, että ehtoja voi kombinoida mielivaltaisesti. Seuraavassa ehto, joka hyväksyy rivit joilla on vähintään yksi sanoista "beer", "milk" tai "oil" ja jotka ovat pituudeltaan 20-30 merkkiä.</p>

<pre class="sh_java">
    Ehto sanat = new VahintaanYksi(
                    new SisaltaaSanan("beer"),
                    new SisaltaaSanan("milk"),
                    new SisaltaaSanan("oil")
                );

    Ehto oikeaPituus = new Molemmat(
                         new PituusVahintaan(20),
                         new Ei( new PituusVahintaan(31)),
                       );

    Ehto halutut = new Molemmat(sanat, oikeaPituus);
</pre>

</div>

<h3>StringBuilder</h3>

<p>Olemme tottuneet rakentamaan characterStringja seuraavaan tapaan:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        int[] t = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        System.out.println(muotoile(t));
    }

    public static String muotoile(int[] t) {
        String mj = "{";

        for (int i = 0; i &lt; t.length; i++) {
            mj += t[i];
            if (i != t.length - 1) {
                mj += ", ";
        
            }
        }

        return mj + "}";
    }
</pre>

<p>Tulostus:</p>

<pre>
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
</pre>

<p>Tapa on toimiva mutta ei kovin tehokas. Kuten muistamme, characterStringt ovat <em>immutabeleja</em> eli olioita joita ei voi muuttaa. characterString-operaatioiden tuloksena onkin aina uusi characterString-olio. Eli edellisessäkin esimerkissä syntyi välivaiheena 10 characterString-olioa. Jos syötteen koko olisi isompi, alkaisi välivaiheena olevien olioiden luominen vaikuttaa ohjelman suoritusaikaan ikävällä tavalla.</p>

<div class="tehtavat">
<h3>String builder</h3>

<p>Edellisen kaltaisissa tilanteissa onkin paremi käyttää characterStringn muodostamisessa <code>StringBuilder</code>-olioita. Toisin kuin Stringint, StringBuilderit eivät ole immutabeleja, ja yhtä StringBuilderolioa voi muokata. Tutustu StringBuilderin API-kuvaukseen (löydät sen esim googlaamalla stringbuilder java api 6) ja muuta tehtäväpohjassa oleva metodi <code>public static String muotoile(int[] t)</code> toimimaan StringBuilderia käyttäen seuraavaan tapaan:</p>

<pre>
{
 1, 2, 3, 4, 
 5, 6, 7, 8, 
 9, 10
}
</pre>

<p>Eli aaltosulkeet tulevat omalle rivilleen. Taulukon alkioita tulostetaan 4 per rivi ja rivin ensimmäistä edeltää välilyönti. Pilkun jälkeen ennen seuraavaa numeroa tulee olla tasan yksi välilyönti.</p>

</div>

<h2>Loppuhuipennus</h2>

<p>Kurssi alkaa olla ohi ja on loppuhuipennuksen aika!</p>

<div class="tehtavat">

<h3>Matopeli</h3>


<p>Tässä tehtävässä luodaan rakenteet ja osa toiminnallisuudesta seuraavannäköiseen matopeliin.</p>

    <p><img src="img-ohja/kali/170-matopeli.png"/></p>

<h4>Pala ja Omena</h4>

<p>Luo pakkaukseen <code>matopeli.domain</code> luokka <code>Pala</code>. Luokalla <code>Pala</code> on konstruktori <code>public Pala(int x, int y)</code>, joka saa palan sijainnin parametrina. Lisäksi luokalla <code>Pala</code> on seuraavat metodit.</p>

<ul>
  <li><code>public int getX()</code> palauttaa Palan konstruktorissa saadun x-koordinaatin.</li>
  <li><code>public int getY()</code> palauttaa Palan konstruktorissa saadun y-koordinaatin.</li>
  <li><code>public boolean osuu(Pala pala)</code> palauttaa true jos oliolla on sama x- ja y-koordinaatti kuin parametrina saadulla Pala-luokan ilmentymällä.</li>
  <li><code>public String toString()</code> palauttaa palan sijainnin muodossa <code>(x,y)</code>. Esim. <code>(5,2)</code> kun x-koordinaatin arvo on 5 ja y-koordinaatin arvo on 2.</li>
</ul>

<p>Toteuta pakkaukseen <code>matopeli.domain</code> myös luokka <code>Omena</code>. Peri luokalla Omena luokka <code>Pala</code>.</p>


<h4>Mato</h4>

<p>Toteuta pakkaukseen <code>matopeli.domain</code> luokka <code>Mato</code>. Luokalla <code>Mato</code> on konstruktori <code>public Mato(int alkuX, int alkuY, Suunta alkusuunta)</code>, joka luo uuden madon jonka suunta on parametrina annettu <code>alkusuunta</code>. Mato koostuu listasta <code>Pala</code>-luokan ilmentymiä. Huom: enum <code>Suunta</code> löytyy valmiina pakkauksesta <code>Matopeli</code>.</p>

<p>Mato luodaan yhden palan pituisena, mutta madon "aikuispituus" on kolme. Madon tulee kasvaa yhdellä aina kun se liikkuu. Kun madon pituus on kolme, se kasvaa isommaksi vain syödessään.</p>

<p>Toteuta madolle seuraavat metodit</p>

<ul>
  <li><code>public Suunta getSuunta()</code> palauttaa madon suunnan.</li>
  <li><code>public void setSuunta(Suunta suunta)</code> asettaa madolle uuden suunnan. Mato liikkuu uuteen suuntaan kun metodia <code>liiku</code> kutsutaan seuraavan kerran.</li>
  <li><code>public int getPituus()</code> palauttaa madon pituuden. Madon pituuden tulee olla sama kuin <code>getPalat()</code>-metodikutsun palauttaman listan alkioiden määrä.</li>
  <li><code>public List&lt;Pala&gt; getPalat()</code> palauttaa listan pala-olioita, joista mato koostuu. Palat ovat listalla järjestyksessä, siten että pää sijaitsee listan lopussa.</li>
  <li><code>public void liiku()</code> liikuttaa matoa yhden palan verran eteenpäin.</li>
  <li><code>public void kasva()</code> kasvattaa madon kokoa yhdellä. Madon kasvaminen tapahtuu seuraavan <code>liiku</code>-metodikutsun yhteydessä. Sitä seuraaviin liiku-kutsuihin kasvaminen ei enää vaikuta.</li>
  <li><code>public boolean osuu(Pala pala)</code> tarkistaa osuuko mato parametrina annettuun palaan. Jos mato osuu palaan, eli joku madon pala osuu metodille parametrina annettuun palaan, tulee metodin palauttaa arvo <code>true</code>. Muuten metodi palauttaa arvon <code>false</code>.</li>
  <li><code>public boolean osuuItseensa()</code> tarkistaa osuuko mato itseensä. Jos mato osuu itseensä, eli joku sen pala osuu johonkin toiseen sen palaan, metodi palauttaa arvon <code>true</code>. Muuten metodi palauttaa arvon <code>false</code>.</li>
</ul>

<p>Metodien <code>public void kasva()</code> ja <code>public void liiku()</code> toiminnallisuus tulee toteuttaa siten, että mato kasvaa vasta seuraavalla liikkumiskerralla.</p>

<p>Liikkuminen kannattaa toteuttaa siten, että madolle luodaan liikkuessa aina uusi pala. Uuden palan sijainti riippuu madon kulkusuunnasta: vasemmalle mennessä uuden palan sijainti on edellisen pääpalan sijainnista yksi vasemmalle, eli sen x-koordinaatti on yhtä pienempi. Jos uuden palan sijainti on edellisen pääpalan alapuolella, eli madon suunta on alas, tulee uuden palan y-koordinaatin olla yhtä isompi kuin pääpalan y-koordinaatti (käytämme siis piirtämisestä tuttua koordinaattijärjestelmää, jossa y-akseli on kääntynyt).</p>

<p>Liikkuessa uusi pala lisätään listalle, ja viimeisin poistetaan listan lopusta. Tällöin jokaisen palan koordinaatteja ei tarvitse päivittää erikseen. Toteuta kasvaminen siten, että palaa viimeisintä palaa ei poisteta jos metodia <code>kasva</code> on juuri kutsuttu.</p>

<p>Huom! Kasvata matoa aina sen liikkuessa jos sen pituus on pienempi kuin 3.</p>

<pre class="sh_java">
        Mato mato = new Mato(5, 5, Suunta.OIKEA);
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());
        
        mato.kasva();
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());

        mato.setSuunta(Suunta.VASEN);
        System.out.println(mato.osuuItseensa());
        mato.liiku();
        System.out.println(mato.osuuItseensa());
</pre>

<pre>
[(5,5)]
[(6,5), (5,5)]
[(7,5), (6,5), (5,5)]
[(8,5), (7,5), (6,5)]
[(8,5), (7,5), (6,5)]
[(9,5), (8,5), (7,5), (6,5)]
false
true
</pre>

<h4>Matopeli, osa 1</h4>

<p>Muokataan seuraavaksi pakkauksessa <code>matopeli.peli</code> olevaa matopelin toiminnallisuutta kapseloivaa luokka <code>Matopeli</code>. Matopeli-luokka perii luokan <code>Timer</code>, joka tarjoaa ajastustoiminnallisuuden pelin päivittämiseen. Luokka <code>Timer</code> vaatii toimiakseen <code>ActionListener</code>-rajapinnan toteuttavan luokan. Olemme toteuttaneet luokalla <code>Matopeli</code> rajapinnan <code>ActionListener</code>.</p>

<p>Muokkaa matopelin konstruktorin toiminnallisuutta siten, että konstruktorissa luodaan peliin liittyvä <code>Mato</code>. Luo mato siten, että sijainti riippuu Matopeli-luokan konstruktorissa saaduista parametreista. Madon x-koordinaatin tulee olla <code>leveys / 2</code>, y-koordinaatin <code>korkeus / 2</code> ja suunnan <code>Suunta.ALAS</code>.</p>

<p>Luo konstruktorissa myös omena. Konstruktorissa luotavan omenan sijainnin tulee olla satunnainen, kuitenkin niin että omenan x-koordinaatti on aina välillä <code>[0, leveys[</code>, ja y-koordinaatti välillä <code>[0, korkeus[</code>.</p>

<p>Lisää matopeliin lisäksi seuraavat metodit</p>
<ul>
  <li><code>public Mato getMato()</code> palauttaa matopelin madon.</li>
  <li><code>public void setMato(Mato mato)</code> asettaa matopeliin metodin parametrina olevan madon. Jos metodia <code>getMato</code> kutsutaan madon asetuksen jälkeen, tulee metodin <code>getMato</code> palauttaa viite <em>samaan</em> matoon.</li>
  <li><code>public Omena getOmena</code> palauttaa matopelin omenan.</li>
  <li><code>public void setOmena(Omena omena)</code> asettaa matopeliin metodin parametrina olevan omenan. Jos metodia <code>getOmena</code> kutsutaan omenan asetuksen jälkeen, tulee metodin <code>getOmena</code> palauttaa viite <em>samaan</em> omenaan.</li>
</ul>



<h4>Matopeli, osa 2</h4>

<p>Muokkaa metodin <code>actionPerformed</code>-toiminnallisuutta siten, että metodissa toteutetaan seuraavat askeleet annetussa järjestyksessä.</p>

<ol>
  <li>Liikuta matoa</li>
  <li>Jos mato osuu omenaan, syö omena ja kutsu madon kasva-metodia. Arvo peliin uusi omena.</li>
  <li>Jos mato törmää itseensä, aseta muuttujan <code>jatkuu</code> arvoksi <code>false</code></li>
  <li>Kutsu rajapinnan <code>Paivitettava</code> toteuttavan muuttujan <code>paivitettava</code> metodia <code>paivita</code>.</li>
  <li>Kutsu Timer-luokalta perittyä <code>setDelay</code>-metodia siten, että pelin nopeus kasvaa suhteessa madon pituuteen. Kutsu <code>setDelay(1000 / <em>mato</em>.getPituus());</code> käy hyvin: kutsussa oletetaan että olet määritellyt oliomuuttujan nimeltä <code>mato</code>.</li>
</ol>

<p>Aletaan seuraavaksi rakentamaan käyttöliittymäkomponentteja.</p>

<h4>Näppäimistön kuuntelija</h4>

<p>Toteuta pakkaukseen <code>matopeli.gui</code> luokka <code>Nappaimistonkuuntelija</code>. Luokalla on konstruktori <code>public Nappaimistonkuuntelija(Mato mato)</code>, ja se toteuttaa rajapinnan <code>KeyListener</code>. Korvaa metodi <code>keyPressed</code> siten, että nuolinäppäintä ylös painettaessa madolle asetetaan suunta ylös. Nuolinäppäintä alas painettaessa madolle asetetaan suunta alas, vasemmalle painettaessa suunta vasen, ja oikealle painettaessa suunta oikea.</p>

<h4>Piirtoalusta</h4>

<p>Toteuta pakkaukseen <code>matopeli.gui</code> luokka <code>Piirtoalusta</code>, joka perii luokan <code>JPanel</code>. Piirtoalusta saa konstruktorin parametrina luokan <code>Matopeli</code> ilmentymän sekä int-tyyppisen muuttujan <code>palanSivunPituus</code>. Muuttuja <code>palanSivunPituus</code> kertoo minkä levyinen ja korkuinen yksittäinen pala on.</p>

<p>Korvaa luokalta <code>JPanel</code> peritty metodi <code>paintComponent</code> siten, että piirrät metodissa <code>paintComponent</code> madon ja omenan. Käytä madon piirtämiseen Graphics-olion tarjoamaa <code>fill3DRect</code>-metodia. Madon värin tulee olla valkoinen (<code>Color.WHITE</code>). Omenan piirtämisessä tulee käyttää Graphics-olion tarjoamaa <code>fillOval</code>-metodia. Omenan värin tulee olla punainen (<code>Color.RED</code>).</p>

<p>Toteuta luokalla <code>Piirtoalusta</code> myös rajapinta <code>Paivitettava</code>. Paivitettava-rajapinnan määrittelemän metodin <code>paivita</code> tulee kutsua JPanel-luokan <code>repaint</code>-metodia.</p>

<h4>Kayttoliittyma</h4>

<p>Muuta luokkaa <code>Kayttoliittyma</code> siten, että käyttöliittymä sisältää piirtoalustan. Metodissa <code>luoKomponentit</code> tulee luoda piirtoalustan ilmentymä ja lisätä se container-olioon. Luo metodin <code>luoKomponentit</code> lopussa luokan <code>Nappaimistokuuntelija</code> ilmentymä, ja lisää se frame-olioon.</p>

<p>Lisää luokalle <code>Kayttoliittyma</code> myös metodi <code>public Paivitettava getPaivitettava()</code>, joka palauttaa metodissa <code>luoKomponentit</code> luotavan piirtoalustan.</p>

<p>Voit käynnistää käyttöliittymän <code>Main</code>-luokassa seuraavasti. Ennen pelin käynnistystä odotamme että käyttöliittymä luodaan. Kun käyttöliittymä on luotu, se kytketään matopeliin ja matopeli käynnistetään.</p>

<pre class="sh_java">
        Matopeli matopeli = new Matopeli(20, 20);

        Kayttoliittyma kali = new Kayttoliittyma(matopeli, 20);
        SwingUtilities.invokeLater(kali);

        while (kali.getPaivitettava() == null) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException ex) {
                System.out.println("Piirtoalustaa ei ole vielä luotu.");
            }
        }

        matopeli.setPaivitettava(kali.getPaivitettava());
        matopeli.start();
</pre>

</div>

<h2>Kurssipalaute</h2>

<div class="tehtavat">

<h3>Kurssipalaute</h3>

<p>Olemme saaneet paljon arvokasta palautetta TMC:n kautta. Näin kurssin viimeisenä kysymyksenä haluaisimme koko kurssin sisältöä koskevan palautteen. Anna palaute täyttämällä <a href="https://ilmo.cs.helsinki.fi/kurssit/servlet/Valinta">täältä</a> löytyvälomake. Palaute on anonyymi.</p> 

<p>Jotta saat merkatuksi tämän tehtävän, aja tehtävän TMC-testit ja lähetä tehtävä palvelimelle. </p>

</div>

<div class="viikkoraja">Retired</div>

<h3>Tiedostojen valitseminen käyttöliittymästä</h3>

<p>Silloin tällöin eteen tulee tilanne, jossa käyttäjän pitää pystyä valitsemaan tiedosto tiedostojärjestelmästä. Java tarjoaa tiedostojen valintaan valmiin käyttöliittymäkomponentin <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JFileChooser.html" target="_blank">JFileChooser</a></code>.</p>

<p>JFileChooser poikkeaa tähän mennessä käyttämistämme käyttöliittymäkomponenteista siinä, että se avaa uuden ikkunan. Avautuvan ikkunan ulkonäkö riippuu hieman käyttöjärjestelmästä, esimerkiksi hieman vanhemmassa <a href="http://fedoraproject.org/" target="_blank">Fedora</a>-käyttöjärjestelmässä ikkuna on seuraavannäköinen.</p>

<p><img src="img-ohja/kali/jfilechooser-kuva.png"/></p>

<p>JFileChooser-olio voidaan luoda missä tahansa. Olion metodille <code>showOpenDialog</code> annetaan parametrina käyttöliittymäkomponentti, johon se liittyy, esimerkiksi <code>JFrame</code>-luokan ilmentymä. Metodi <code>showOpenDialog</code> avaa tiedostonvalintaikkunan, ja palauttaa <code>int</code>-tyyppisen statuskoodin riippuen käyttäjän valinnasta. Luokassa <code>JFileChooser</code> on määritelty <code>int</code>-tyyppiset luokkamuuttujat, jotka kuvaavat statuskoodeja. Esimerkiksi onnistuneella valinnalla on arvo <code>JFileChooser.APPROVE_OPTION</code>.</p>

<p>Valittuun tiedostoon pääsee <code>JFileChooser</code>-oliosta käsiksi metodilla <code>getSelectedFile</code>.</p>

<pre class="sh_java">
    JFileChooser chooser = new JFileChooser();

    int valinta = chooser.showOpenDialog(frame);

    if (valinta == JFileChooser.APPROVE_OPTION) {
        File valittu = chooser.getSelectedFile();
        System.out.println("Valitsit tiedoston: " + valittu.getName());
    } else if (valinta == JFileChooser.CANCEL_OPTION) {
        System.out.println("Et valinnut tiedostoa!");
    }
</pre>

<p>Yllä oleva esimerkki avaa valintaikkunan, ja tulostaa valitun tiedoston nimen jos valinta onnistuu. Jos valinta epäonnistuu, ohjelma tulostaa <code>"Et valinnut tiedostoa!"</code>.</p>

<h4>Tiedostojen filtteröinti</h4>

<p>Tiedostojen filtteröinnillä tarkoitetaan vain tietynlaisten tiedostojen näyttämistä tiedostoikkunassa. JFileChooser-oliolle voi asettaa filtterin metodilla <code>setFileFilter</code>. Metodi <code>setFileFilter</code> saa parametrina abstraktin luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/filechooser/FileFilter.html" target="_blank">FileFilter</a></code>-ilmentymän, esimerkiksi luokasta <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/filechooser/FileNameExtensionFilter.html" target="_blank">FileNameExtensionFilter</a></code> tehdyn olion.</p>

<p>Luokka <code>FileNameExtensionFilter</code> mahdollistaa tiedostojen filtteröinnin niiden päätteiden perusteella. Esimerkiksi pelkät <code>txt</code>-päätteiset tekstitiedostot saa näkyviin seuraavasti.</p>

<pre class="sh_java">
    JFileChooser chooser = new JFileChooser();
    chooser.setFileFilter(new FileNameExtensionFilter("Tekstitiedostot", "txt"));

    int valinta = chooser.showOpenDialog(frame);

    if (valinta == JFileChooser.APPROVE_OPTION) {
        File valittu = chooser.getSelectedFile();
        System.out.println("Valitsit tiedoston: " + valittu.getName());
    } else if (valinta == JFileChooser.CANCEL_OPTION) {
        System.out.println("Et valinnut tiedostoa!");
    }
</pre>

<div class="tehtavat">


<NEXTWEEK></NEXTWEEK>
<h3>Nopeustesti</h3>



<p>Luodaan ohjelma, joka mittaa kliksutteluvauhtia. Käyttöliittymä tulee näyttämään esimerkiksi seuraavalta.</p>

<p><img src="img-ohja/kali/169-nopeustesti.png"/></p>

<h4 class="req">Oma luokka JButtonille</h4>

<p>Toteuta pakkaukseen <code>nopeustesti</code> luokka <code>Nappi</code>, joka perii JButtonin. Luokalla <code>Nappi</code> tulee olla konstruktori <code>public Nappi(String text, Color aktiivinen, Color passiivinen)</code>. Konstruktorin parametrina saama characterString <code>text</code> tulee antaa parametrina yläluokan konstruktorille (kutsu <code>super(text)</code>).</p> 

<p>Korvaa luokasta JButton peritty metodi <code>protected void paintComponent(Graphics g)</code> siten, että piirrät metodissa napin kokoisen värillisen ympyrän. Saat napin leveyden ja korkeuden JButton-luokalta perityistä metodeista <code>getWidth()</code> ja <code>getHeight()</code>. Kutsu korvatun metodin alussa yläluokan <code>paintComponent</code>-metodia.</p>

<p>Ympyrän värin tulee riippua Napin tilasta: jos nappi on aktiivinen (metodi <code>isEnabled</code> palauttaa <code>true</code> tulee ympyrän väri olla konstruktorin parametrina saatu <code>aktiivinenVari</code>. Muulloin käytetään väriä <code>passiivinenVari</code>.</p>

<h4 class="req">Perustoiminta</h4>

<p>Toteuta luokkaan <code>Nopeustesti</code> käyttöliittymä, jossa on neljä nappulaa ja teksti. Käytä asettelussa napeille omaa JPanel-alustaa, joka asetetaan BorderLayout-asettelijan keskelle. Teksti tulee BorderLayout-asettelijan alaosaan.</p>

<p>Käytä edellisessä osassa luomaasi <code>Nappi</code>-luokkaa. Napeille tulee antaa konstruktorissa tekstit 1, 2, 3 ja 4.</p>

<h4 class="req">Nappuloiden aktiivisuus</h4>

<p>Vain yhden nappulan kerrallaan tulee olla painettavissa (eli aktiivisena). Voit tehdä nappulasta ei-aktiivisen metodikutsulla <code>nappi.setEnabled(false)</code>. Vastaavasti nappi muutetaan aktiiviseksi kutsulla <code>nappi.setEnabled(true)</code>.</p>

<p>Kun aktiivisena olevaa nappulaa painetaan, tulee käyttöliittymän arpoa uusi aktiivinen nappi.</p>

<h4 class="req">Pisteytys</h4>

<p>Tehdään peliin pisteytys: mitataan 20 painallukseen kuluva aika. Helpoin tapa ajan mittaamiseen on metodin <code>System.currentTimeMillis()</code> kutsuminen. Metodi palauttaa kokonaisluvunu, joka laskee millisekunteja (tuhannesosasekunteja) jostain tietysti ajanhetkestä lähtien. Siispä voit mitata kulunutta aikaa kutsumalla <code>currentTimeMillis</code> pelin alussa ja lopussa ja laskemalla erotuksen.</p>

<p>Toteuta siis seuraava: peli laskee napinpainallusten määrän, ja 20. painalluksen jälkeen asettaa kaikki nappulat epäaktiivisiksi ja näyttää <code>JLabel</code>-komponentissa viestin <code>"Pisteesi: XXXX"</code>, jossa <code>XXXX</code> on painalluksiin kulunut aika (millisekunteina) jaettuna 20:lla. Pienempi pistemäärä on siis parempi.</p>

<h3>Tiedostonnäytin</h3>

<p>Tässä tehtävässä toteutetaan ohjelma, joka lukee käyttäjän valitseman tiedoston ja näyttää sen sisällön käyttöliittymässä.</p>

<p>Ohjelmassa on eroteltu käyttöliittymään ja sovelluslogiikka. Tehtäväpohjassa on valmiina sovelluslogiikan rajapinta <code>TiedostonLukija</code> sekä käyttöliittymäluokan runko <code>Kayttoliittyma</code>.</p>

<h4>Käyttöliittymän rakentaminen</h4>

<p>Täydennä käyttöliittymäluokan metodi <code>luoKomponentit</code>. Ohjelma tarvitsee toimiakseen kolme käyttöliittymäkomponenttia:</p>

<ul>
  <li><strong>JButton</strong>-nappi, jossa on teksti &quot;Valitse tiedosto...&quot;</li>
  <li><strong>JTextArea</strong>-tekstieditorin avulla näytetään tiedoston sisältö, komponentin editointimahdollisuus tulee kytkeä pois päältä metodilla <code>setEditable</code>. <code>JTextArea</code> eroaa <code>JTextField</code>-komponentista siten, että <code>JTextArea</code>-komponentissa voi olla tekstiä useammalla rivillä.</li>
  <li><strong>JLabel</strong>-tietokenttä, joka sisältää näytettävän tiedoston nimen (ilman polkua!)</li>
</ul>

<p>Koska tässä tehtävässä on vain kolme aseteltavaa komponenttia, riittävät asetteluun <code>BorderLayout</code>-asettelijan vaihtoehdot: <code>BorderLayout.NORTH</code>, <code>BorderLayout.CENTER</code> ja <code>BorderLayout.SOUTH</code>. Käyttöliittymäkomponentti <code>JTextArea</code> kannattaa sijoittaa keskelle, jotta se saa mahdollisimman paljon tilaa tekstin näyttämiselle.</p>

<p>Käyttöliittymän pitäisi näyttää suunnilleen seuraavalta. Alla olevassa esimerkissä <code>JLabel</code>-oliossa ei ole mitään tekstiä.</p>

    <p><img src="img-ohja/kali/161-tiedostonnaytin-alku.png"/></p>


<h4>Tiedoston lukeminen</h4>

<p>Luo pakkaukseen <code>tiedostonnaytin.sovelluslogiikka</code> luokka <code>OmaTiedostonLukija</code>, joka toteuttaa rajapinnan <code>TiedostonLukija</code>. Rajapinnassa on yksi metodi, <code>lueTiedosto</code>, joka lukee sille annetun tiedoston kokonaisuudessaan characterStringon ja palauttaa tämän characterStringn.</p>

<p>Rajapinnan koodi:</p>

<pre class="sh_java">
package tiedostonnaytin.sovelluslogiikka;

import java.io.File;

public interface TiedostonLukija {
    String lueTiedosto(File tiedosto);
}
</pre>

<p><b>Huom:</b> Palautettavassa characterStringssa tulee säilyttää myös rivinvaihdot <code>"\n"</code>. Esimerkiksi <code>Scanner</code>-lukijan metodi <code>nextLine()</code> poistaa palauttamistaan characterStringista rivinvaihdot, joten joudut joko lisäämään ne takaisin tai lukemaan tiedostoa eri tavalla.</p>

<h4>Käyttöliittymän kytkeminen sovelluslogiikkaan</h4>

<p>Viimeisessä tehtävän osassa toteutetaan käyttöliittymän <code>JButton</code>-napille tapahtumankuuntelija. Saat itse päättää luokalle sopivan nimen.</p>

<p>Tapahtumankuuntelijan tehtävänä on näyttää <code>JFileChooser</code>-tiedostonvalintaikkuna kun <code>JButton</code>-nappia painetaan. Kun käyttäjä valitsee tiedoston, tulee tapahtumankuuntelijan lukea tiedoston sisältö ja näyttää se <code>JTextArea</code>-kentässä. Tämän jälkeen tapahtumankuuntelijan tulee vielä päivittää <code>JLabel</code>-kenttään näytetyn tiedoston nimi (ilman tiedostopolkua).</p>

<p>JFileChooser-olion metodille <code>showOpenDialog</code> tulee antaa parametrina <code>Kayttoliittyma</code>-luokassa oleva <code>JFrame</code>-ikkunaolio. Jos käyttäjä valitsee tiedoston, tulee tiedosto lukea tapahtumankuuntelijassa <code>Kayttoliittyma</code>-luokassa määriteltyä <code>TiedostonLukija</code>-oliota apuna käyttäen. Kannattaa luoda tapahtumankuuntelija siten, että sille annetaan konstruktorissa kaikki tarvitut oliot.</p>

<p>Huomaa, että valintaikkunan voi myös sulkea valitsematta tiedostoa!</p>

<!--
<p><code>JButton</code>-nappiin tulee siis liittää <code>ActionListener</code>-rajapinnan toteuttava tapahtumankuuntelija, joten tehtävässä täytyy luoda tätä varten uusi luokka. <code>JFileChooser</code> palauttaa käyttäjän valitsemaa operaatiota vastaavan paluuarvon sekä viitteen valittuun tiedostoon, jos käyttäjä valitsi tiedoston (eikä peruuttanut valintaa).</p>

<p>JFileChooser-olion metodille <code>showOpenDialog</code> tulee antaa parametrina <code>Kayttoliittyma</code>-luokassa oleva <code>JFrame</code>-ikkunaolio. Jos käyttäjä valitsee tiedoston, tulee tiedosto lukea tapahtumankuuntelijassa <code>Kayttoliittyma</code>-luokassa määriteltyä <code>TiedostonLukija</code>-oliota apuna käyttäen. Kannattaa luoda tapahtumankuuntelija siten, että sille annetaan konstruktorissa tarvitut oliot.</p>

<p>Kun käyttäjä valitsee tiedoston, tulee <code>JTextArea</code>-kentän tekstisisällöksi asettaa tiedoston sisältö.</p>-->

<p>Kun tiedosto on avattu, tulee käyttöliittymän näyttää esimerkiksi seuraavalta.</p>

    <p><img src="img-ohja/kali/161-tiedostonnaytin-avattu.png"/></p>

</div>


<div class="tehtavat">



<h3>Tekstiseikkailu</h3>


  <p>Tehtäväsarjassa tehdään laajennettava tekstiseikkailupelin runko. Seikkailu koostuu <em>kohdista</em>, joissa jokaisessa ruudulle tulee tekstiä. Kohdat voivat olla joko välivaiheita, kysymyksiä, tai monivalintakohtia. Monivalinta-tyyppisen kohdan näyttämä teksti voi olla esimerkiksi seuraavanlainen:</p>

<pre>
Huoneessa on kaksi ovea. Kumman avaat?

1. Vasemmanpuoleisen.
2. Oikeanpuoleisen.
3. Juoksen pakoon.
</pre>

  <p>Käyttäjä vastaa kohdassa esitettävään tekstiin. Yllä olevaan tekstiin voi vastata <code>1</code>, <code>2</code> tai <code>3</code>, ja vastauksesta riippuu, minne käyttäjä siirtyy seuraavaksi.</p>

  <p>Peliin tullaan toteuttamaan kohtia kuvaava rajapinta ja tekstikäyttöliittymä, jonka kautta peliä pelataan.</p>

  <p><em>Huom!</em> Toteuta kaikki tehtävän vaiheet pakkaukseen "seikkailu"</p>

  <h4 class="req">Kohta ja Välivaihe</h4>

  <p>Pelissä voi olla hyvinkin erilaisia kohtia, ja edellä olleessa esimerkissä ollut monivalinta on vain eräs vaihtoehto.</p>

  <p>Toteuta kohdan käyttäytymistä kuvaava rajapinta <code>Kohta</code>. Rajapinnalla <code>Kohta</code> tulee olla metodi <code>String teksti()</code>, joka palauttaa kohdassa tulostettavan tekstin. Metodin <code>teksti</code> lisäksi kohdalla tulee olla metodi <code>Kohta seuraavaKohta(String vastaus)</code>, jonka toteuttavat luokat palauttavat seuraavan kohdan vastauksen perusteella.</p>

  <p>Toteuta tämän jälkeen yksinkertaisin tekstiseikkailun kohta, eli ei-interaktiivinen tekstiruutu, josta pääsee etenemään millä tahansa syötteellä. Toteuta ei-interaktiivista tekstiruutua varten luokka <code>Valivaihe</code>, jolla on seuraavanlainen API.</p>

  <p>
    <ul>
      <li> Luokka toteuttaa rajapinnan <code>Kohta</code>. </li>
      <li> Konstruktori ottaa parametrikseen käyttäjälle näytettävän tekstin. </li>
      <li> <code>public String teksti()</code>-metodi palauttaa konstruktorissa annetun tekstin sekä rivin <code>"(jatka painamalla enteriä)"</code>. (Rivinvaihto saadaan aikaan merkillä "\n".)</li>
      <li> <code>public void asetaSeuraava(Kohta seuraava)</code>-metodilla voidaan asettaa <code>Kohta</code>-olio, jonka <code>seuraavaKohta(String vastaus)</code> aina palauttaa (vastauksesta riippumatta). </li>
    </ul>
  </p>

  <p>Testaa ohjelmaasi seuraavalla esimerkillä:</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    Valivaihe alkuteksti = new Valivaihe("Olipa kerran ohjelmoija.");
    Valivaihe johdanto = new Valivaihe("Joka alkoi ohjelmoimaan Javalla.");
    alkuteksti.asetaSeuraava(johdanto);

    Kohta nykyinen = alkuteksti;
    System.out.println(nykyinen.teksti());

    nykyinen = nykyinen.seuraavaKohta(reader.nextLine());
    if (nykyinen == null) {
        System.out.println("Virhe ohjelmassa!");
    }

    System.out.println(nykyinen.teksti());

    nykyinen = nykyinen.seuraavaKohta(reader.nextLine());
    if (nykyinen != null) {
        System.out.println("Virhe ohjelmassa!");
    }
</pre>

<pre>
Olipa kerran ohjelmoija.
(jatka painamalla enteriä)

Joka alkoi ohjelmoimaan Javalla.
(jatka painamalla enteriä)

</pre>


<h4>Käyttöliittymä</h4>

  <p>Pelin käyttöliittymä (luokka <code>Kayttoliittyma</code>) saa konstruktorin parametrina <code>Scanner</code>-olion ja <code>Kohta</code>-rajapinnan toteuttavan pelin aloittavan olion. Luokka tarjoaa metodin <code>public void kaynnista()</code>, joka käynnistää pelin suorituksen.</p>

  <p>Käyttöliittymä käsittelee kaikkia kohtia <code>Kohta</code>-rajapinnan kautta. Käyttöliittymän tulee jokaisessa kohdassa kysyä kohtaan liittyvältä metodilta <code>teksti</code> tekstiä, joka käyttäjälle näytetään. Tämän jälkeen käyttöliittymä kysyy käyttäjältä vastauksen, ja antaa sen parametrina kohta-olion metodille <code>seuraavaKohta</code>. Metodi <code>seuraavaKohta</code> palauttaa vastauksen perusteella seuraavan kohdan, johon pelin on määrä siirtyä. Peli loppuu, kun metodi <code>seuraavaKohta</code> palauttaa arvon <code>null</code>.</p>

  <p>Koska pääohjelma tulee käyttämään kohtia vain <code>Kohta</code>-rajapinnan kautta, voidaan peliin lisätä vaikka minkälaisia kohtia pääohjelmaa muuttamatta. Riittää tehdä uusia <code>Kohta</code>-rajapinnan toteuttavia luokkia.</p>

  <p>Toteuta luokka <code>Kayttoliittyma</code>, ja testaa sen toimintaa seuraavalla esimerkillä</p>

<pre class="sh_java">
        Scanner lukija = new Scanner(System.in);
        Valivaihe alku = new Valivaihe("Olipa kerran ohjelmoija.");
        Valivaihe johdanto = new Valivaihe("Joka alkoi ohjelmoimaan Javalla.");
        Valivaihe loppu = new Valivaihe("Ja päätti muuttaa Helsinkiin.");

        alku.asetaSeuraava(johdanto);
        johdanto.asetaSeuraava(loppu);

        new Kayttoliittyma(lukija, alku).kaynnista();
</pre>


<pre>
Olipa kerran ohjelmoija.
(jatka painamalla enteriä)
&gt;

Joka alkoi ohjelmoimaan Javalla.
(jatka painamalla enteriä)
&gt;

Ja päätti muuttaa Helsinkiin.
(jatka painamalla enteriä)
&gt;

</pre>

  <p>Käytä seuraavaa metodia käyttöliittymän <code>kaynnista</code>-metodina. Yritä piirtää paperille mitä käy kun käyttöliittymä käynnistetään.</p>

<pre class="sh_java">
    public void kaynnista() {
        Kohta nykyinen = alkukohta;

        while (nykyinen != null) {
            System.out.println(nykyinen.teksti());
            System.out.print("&gt; ");
            String vastaus = reader.nextLine();

            nykyinen = nykyinen.seuraavaKohta(vastaus);
            System.out.println("");
        }
    }
</pre>

  <p>Käyttöliittymän <code>kaynnista</code>-metodi sisältää siis toistolauseen, jossa ensin tulostetaan käsiteltävän kohdan teksti. Tämän jälkeen kysytään käyttäjältä syötettä. Käyttäjän syöte annetaan vastauksena käsiteltävän kohdan <code>seuraavaKohta</code>-metodille. Metodi <code>seuraavaKohta</code> palauttaa kohdan, jota käsitellään seuraavalla toiston kierroksella. Jos palautettu kohta oli <code>null</code>, lopetetaan toisto.</p>

    <h4>Kysymyksiä</h4>

    <p>Tekstiseikkailussa voi olla kysymyksiä, joihin on annettava oikea vastaus ennen kuin pelaaja pääsee eteenpäin. Tee luokka <code>Kysymys</code> seuraavasti:</p>

    <p>
      <ul>
        <li> Luokka toteuttaa <code>Kohta</code>-rajapinnan. </li>
        <li> Konstruktori saa parametreina kysymystekstin ja oikean vastauksen. </li>
        <li> Seuraavan kohdan voi asettaa <code>asetaSeuraava</code>-metodilla. </li>
        <li> Jos <code>seuraavaKohta</code>-metodia kutsutaan oikealla vastauksella, metodi palauttaa seuraavan kohdan, muuten metodi ei päästä etenemään ja palauttaa arvon <code>this</code>, eli viitteen tähän olioon. </li>
      </ul>
    </p>

    <p>Luokkaa voi testata seuraavalla pääohjelmalla:</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    Kysymys alku = new Kysymys("Minä vuonna Javan ensimmäinen versio julkaistiin?", "1995");
    Valivaihe hyva = new Valivaihe("Hyvä! Lisätietoa: Javan alkuperäinen ideoija on James Gosling.");

    alku.asetaSeuraava(hyva);

    new Kayttoliittyma(lukija, alku).kaynnista();
</pre>

<pre>
Minä vuonna Javan ensimmäinen versio julkaistiin?
&gt; <font color="red">2000</font>

Minä vuonna Javan ensimmäinen versio julkaistiin?
&gt; <font color="red">1995</font>

Hyvä! Lisätietoa: Javan alkuperäinen ideoija on James Gosling.
(jatka painamalla enteriä)
&gt;
</pre>



<h4 class="req">Monivalintakysymykset</h4>

    <p>Tällä hetkellä tekstiseikkailu tukee välivaiheita ja yksinkertaisia kysymyksiä. Tekstiseikkailu on siis lineaarinen, eli lopputulokseen ei voi käytännössä vaikuttaa. Lisätään seikkailuun monivalintakysymyksiä, joiden avulla pelin kehittäjä voi luoda vaihtoehtoista toimintaa.</p>

    <p>Esimerkki vaihtoehtoisesta toiminnasta:</p>

<pre>
Kello on 13:37 ja päätät mennä syömään. Minne menet?
1. Exactumiin
2. Chemicumiin
&gt; <font color="red">1</font>

Ruoka on loppu :(
(jatka painamalla enteriä)
&gt;
</pre>


<pre>
Kello on 13:37 ja päätät mennä syömään. Minne menet?
1. Exactumiin
2. Chemicumiin
&gt; <font color="red">2</font>

Mainio valinta!
(jatka painamalla enteriä)
&gt;
</pre>

    <p>Toteuta luokka <code>Monivalinta</code>, jonka API on seuraavanlainen</p>

    <p>
      <ul>
        <li> Toteuttaa rajapinnan <code>Kohta</code>. </li><br/>
        <li> <code>public Monivalinta(String teksti)</code></li> Luokan konstruktori saa parametrina näytettävän tekstin. <br/>
        <li> <code>public void lisaaVaihtoehto(String valinta, Kohta seuraava)</code></li> Lisää vaihtoehdon ja siihen liittyvän seuraavan kohdan. Yhdessä monivalintakysymyksessä voi olla rajaton määrä vaihtoehtoja.<br/>
        <li> <code>public String teksti()</code></li> Palauttaa characterStringna sekä konstruktorissa annetun perustekstin että kaikki valintavaihtoehdot. Valintavaihtoehdot tulee olla eritelty numeroilla.<br/>
        <li> <code>public Kohta seuraavaKohta(String valinta)</code></li> Palauttaa käyttäjän valitsemaa vaihtoehtoa vastaavan kohdan. Käyttäjä valitsee aina kirjoittamalla numeron. Huom! Voit muuttaa characterStringn numeroksi luokan <code>Integer</code> luokkametodilla <code>parseInt</code>. <br/>
      </ul>
    </p>


    <p>Testaa ohjelmasi toimintaa seuraavalla pääohjelmalla:</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    Monivalinta lounas = new Monivalinta("Kello on 13:37 ja päätät mennä syömään. Minne menet?");
    Monivalinta chemicum = new Monivalinta("Lounasvaihtoehtosi ovat seuraavat:");

    Valivaihe exactum = new Valivaihe("Exactumista on kaikki loppu, joten menet Chemicumiin.");

    exactum.asetaSeuraava(chemicum);

    lounas.lisaaVaihtoehto("Exactumiin", exactum);
    lounas.lisaaVaihtoehto("Chemicumiin", chemicum);

    Valivaihe nom = new Valivaihe("Olipas hyvää");

    chemicum.lisaaVaihtoehto("Punajuurikroketteja, ruohosipuli-soijajogurttikastiketta", nom);
    chemicum.lisaaVaihtoehto("Jauhelihakebakot, paprikakastiketta", nom);
    chemicum.lisaaVaihtoehto("Mausteista kalapataa", nom);

    new Kayttoliittyma(lukija, lounas).kaynnista();
</pre>

<pre>
Kello on 13:37 ja päätät mennä syömään. Minne menet?
1. Exactumiin
2. Chemicumiin
&gt; <font color="red">1</font>

Exactumista on kaikki loppu, joten menet Chemicumiin.
(jatka painamalla enteriä)
&gt;

Lounasvaihtoehtosi ovat seuraavat:
1. Punajuurikroketteja, ruohosipuli-soijajogurttikastiketta
2. Jauhelihakebakot, paprikakastiketta
3. Mausteista kalapataa
&gt; <font color="red">2</font>

Olipas hyvää
(jatka painamalla enteriä)
&gt;

</pre>

    <p><em>Luokan <code>Monivalinta</code> sisäinen toteutus saattaa olla haastava. Kannattaa esimerkiksi käyttää listaa vastausvaihtoehtojen (characterStringjen) tallentamiseen, ja hajautustaulua kohtien tallentamiseen valintavaihtoehdon indeksillä. </em></p>

</div>


<div class="tehtavat">

  <h3>Tilastot kuntoon</h3>

  <p>NHL:ssä pidetään pelaajista yllä monenlaisia tilastotietoja. Teemme nyt oman ohjelman NHL-pelaajien tilastojen hallintaan.</p>

<h4>Pelaajalistan tulostus</h4>

  <p>Tee luokka <code>Pelaaja</code>, johon voidaan tallettaa pelaajan nimi, joukkue, pelatut ottelut, maalimäärä, ja syöttömäärä. Luokalla tulee olla konstruktori, joka saa edellämainitut tiedot edellä annetussa järjestyksessä.</p>

  <p>Tee kaikille edelläminituille arvoille myös ns. getterimetodit, jotka palauttavat arvot:</p>

<ul>
  <li><code>String getName</code></li>
  <li><code>String getJoukkue</code></li>
  <li><code>int getOttelut</code></li>
  <li><code>int getMaalit</code></li>
  <li><code>int getSyotot</code></li>
  <li><code>int getPisteet</code> - laskee kokonaispistemäärän eli maalien ja syöttöjen summan</li>
</ul>

<p>Talleta seuraavat pelaajat ArrayList:iin ja tulosta listan sisältö:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        ArrayList&lt;Pelaaja&gt; pelaajat = new ArrayList&lt;Pelaaja&gt;();
        pelaajat.add(new Pelaaja("Alex Ovechkin", "WSH", 71, 28, 46));
        pelaajat.add(new Pelaaja("Dustin Byfuglien", "ATL", 69, 19, 31));
        pelaajat.add(new Pelaaja("Phil Kessel", "TOR", 70, 28, 24));
        pelaajat.add(new Pelaaja("Brendan Mikkelson", "ANA, CGY", 23, 0, 2));
        pelaajat.add(new Pelaaja("Matti Luukkainen", "SaPKo", 1, 0, 0 ));

        for (Pelaaja pelaaja : pelaajat) {
            System.out.println(pelaaja);
        }
    }
</pre>

<p>Pelaajan <code>toString()</code>-metodin muodostaman tulostuksen tulee olla seuraavassa muodossa:</p>

<pre>
Alex Ovechkin WSH 71 28 + 46 = 74
Dustin Byfuglien ATL 69 19 + 31 = 50
Phil Kessel TOR 70 28 + 24 = 52
Brendan Mikkelson ANA, CGY 23 0 + 2 = 2
Matti Luukkainen SaPKo 1 0 + 0 = 0
</pre>

  <p>Ensin siis nimi, sitten joukkue, jonka jälkeen ottelut, maalit, plusmerkki, syötöt, yhtäsuuruusmerkki ja kokonaispisteet eli maalien ja syöttöjen summa.</p>

<h4>Tulostuksen siistiminen</h4>

  <p>Tee <code>Pelaaja</code>-luokkaan metodi <code>toSiisticharacterString()</code>, joka palauttaa samat tiedot siististi aseteltuna siten, että jokaiselle muuttujalle on varattu tietty määrä tilaa tulostuksessa.</p>

<p>Tulostuksen tulee näyttää seuraavalta:</p>

<pre>
Alex Ovechkin             WSH             71  28 + 46 = 74
Dustin Byfuglien          ATL             69  19 + 31 = 50
Phil Kessel               TOR             70  28 + 24 = 52
Brendan Mikkelson         ANA, CGY        23   0 +  2 =  2
Matti Luukkainen          SaPKo            1   0 +  0 =  0
</pre>

  <p>Nimen jälkeen joukkueen nimien täytyy alkaa samasta kohdasta. Saat tämän aikaan esim. muotoilemalla nimen tulostuksen yhteydessä seuraavasti:</p>

<pre class="sh_java">
String nameJaTyhjaa = String.format("%-25s", nimi);
</pre>

  <p>Komento tekee characterStringn <code>nimiJaTyhjaa</code> joka alkaa characterStringn <code>nimi</code> sisällöllä ja se jälkeen tulee välilyöntejä niin paljon että characterStringn pituudeksi tulee 25. Joukkueen nimi tulee vastaavalla tavalla tulostaa 14 merkin pituisena characterStringna. Tämän jälkeen on otteluiden määrä (2 merkkiä), jota seuraa 2 välilyöntiä. Tämän jälkeen on maalien määrä (2 merkkiä), jota seuraa characterString " + ". Tätä seuraa syöttöjen määrä (2 merkkiä), characterString " = ", ja lopuksi yhteispisteet (2 merkkiä).</p>

  <p>Lukuarvot eli ottelu-, maali-, syöttö- ja pistemäärä muotoillaan kahden merkin mittaisena, eli lukeman 0 sijaan tulee tulostua välilyönti ja nolla. Seuraava komento auttaa tässä:</p>

<pre class="sh_java">
String maalitMerkkeina = String.format("%2d", maalit);
</pre>

<h4>Pistepörssin tulostus</h4>

  <p>Lisää luokalle Pelaaja rajapinta <code>Comparable&lt;Pelaaja&gt;</code>, jonka avulla pelaajat voidaan järjestää kokonaispistemäärän mukaiseen <em>laskevaan</em> järjestykseen. Järjestä pelaajat Collections-luokan avulla ja tulosta pistepörssi:</p>

<pre class="sh_java">
        Collections.sort(pelaajat);

        System.out.println("NHL pistepörssi:\n");
        for (Pelaaja pelaaja : pelaajat) {
            System.out.println(pelaaja);
        }
</pre>

<p>
Tulostuu:
</p>

<pre>
NHL pistepörssi:

Alex Ovechkin             WSH           71  28 + 46 = 74
Phil Kessel               TOR           70  28 + 24 = 52
Dustin Byfuglien          ATL           69  19 + 31 = 50
</pre>

  <p>Ohjeita tähän tehtävään materiaalissa.</p>

<h4>Kaikkien pelaajien tiedot</h4>

  <p>Tilastomme on vielä hieman vajavainen, siinä on vaan muutaman pelaajan tiedot (ja nekin vastaavat 16.3. tilannetta). Kaikkien tietojen syöttäminen käsin olisi kovin vaivalloista. Onneksemme internetistä osoitteesta <code>http://nhlstatistics.herokuapp.com/players.txt</code> löytyy päivittyvä, koneen luettavaksi tarkoitettu lista pelaajatiedoista.</p>

  <p><b>Huom:</b> kun menet osoitteeseen ensimmäistä kertaa, sivun latautuminen kestää muutaman sekunnin (sivu pyörii virtuaalipalvelimella joka sammutetaan jos sivua ei ole hetkeen käytetty). Sen jälkeen sivu toimii nopeasti.</p>

  <p>Datan lukeminen internetistä on helppoa. Projektissasi on valmiina luokka <code>Tilasto</code>, joka lataa annetun verkkosivun.</p>

<pre class="sh_java">
import java.io.InputStream;
import java.net.URL;
import java.util.Scanner;

public class Tilasto {
    private static final String OSOITE =
            "http://nhlstatistics.herokuapp.com/players.txt";

    private Scanner lukija;

    public Tilasto() {
        this(OSOITE);
    }

    public Tilasto(String osoite) {
        try {
            URL url = new URL(osoite);
            lukija = new Scanner(url.openStream());
        } catch (Exception ex) {
        }
    }

    public Tilasto(InputStream in) {
        try {
            lukija = new Scanner(in);
        } catch (Exception ex) {
        }
    }

    public boolean onkoRivejaJaljella() {
        return reader.hasNextLine();
    }

    public String annaSeuraavaRivi() {
        String rivi = reader.nextLine();
        return rivi.trim();
    }
}
</pre>

  <p><code>Tilasto</code>-luokka lukee pelaajien tilastotiedot internetistä. Metodilla <code>annaSeuraavaRivi()</code> saadaan selville yhden pelaajan tiedot. Tietoja on tarkoitus lukea niin kauan kuin pelaajia riittää, tämä voidaan tarkastaa metodilla <code>onkoRivejaJaljella()</code> </p>

  <p>Kokeile että ohjelmasi onnistuu tulostamaan <code>Tilasto</code>-luokan hakemat tiedot:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Tilasto tilasto = new Tilasto();

        while (tilasto.onkoRivejaJaljella()) {
            String pelaajaRivina = tilasto.annaSeuraavaRivi();
            System.out.println(pelaajaRivina);
        }
    }
</pre>

  <p>Tulostus on seuraavan muodoinen:</p>

<pre>
Evgeni Malkin;PIT;62;39;46;54 <br/>

Steven Stamkos;TBL;70;50;34;64 <br/>

Claude Giroux;PHI;66;26;56;27 <br/>

Jason Spezza;OTT;72;29;46;30 <br/>
// ... ja yli 800:n muun pelaajan tiedot
</pre>

  <p><b>Huom:</b> tulostuksen alussa ja lopussa ja jokaisen pelaajan välissä on html-tägejä, esim. &lt;br/&gt; joka aiheuttaa www-sivulle rivin vaihtumisen.</p>

  <p>Tulostuksessa pelaajan tiedot on erotettu toisistaan puolipisteellä. Ensin nimi, sitten joukkue, ottelut, maalit, syötöt ja laukaukset.</p>

  <p>Pelaajaa vastaava characterString on siis yksittäinen characterString. Saat pilkottua sen osiin <code>split</code>-komennolla seuraavasti:</p>

<pre class="sh_java">
        while (tilasto.onkoRivejaJaljella()) {
            String pelaajaRivina = tilasto.annaSeuraavaRivi();
            String[] pelaajaOsina = pelaajaRivina.split(";");
            for (int j = 0; j < pelaajaOsina.length; j++) {
                System.out.print(pelaajaOsina[j] + " ");
            }
            System.out.println("");
        }
</pre>

  <p>Kokeile että tämä toimii. Saat tästä tehtävästä pisteet seuraavan tehtävän yhteydessä.</p>

  <h4>Kaikkien pelaajien pistepörssi</h4>

  <p>Tee kaikista <code>Tilasto</code>-luokan hakemien pelaajien tiedoista Pelaaja-olioita ja lisää ne ArrayListiin. Lisää tehtävään luokka <code>PelaajatTilastosta</code>. Käytä alla olevaa koodia luokan runkona.</p>

<pre class="sh_java">
import java.util.ArrayList;

public class PelaajatTilastosta {
    public ArrayList&lt;Pelaaja&gt; haePelaajat(Tilasto tilasto) {
        ArrayList&lt;Pelaaja&gt; pelaajat = new ArrayList&lt;Pelaaja&gt;();
        while (tilasto.onkoRivejaJaljella()) {
            String pelaajaRivina = tilasto.annaSeuraavaRivi();
            String[] pelaajaOsina = pelaajaRivina.split(";");

            // Lisätään uusi pelaaja vain, jos syötteessä on kenttiä riittävästi
            if (pelaajaOsina.length &gt; 4) {
                int ottelut = Integer.parseInt(pelaajaOsina[2].trim());
                // Täydennä koodia lukemalla kaikki pelaajaOsina-taulukon kentät uuteen Pelaaja-olioon
                // ...
                // pelaajat.add(new Pelaaja( ... ));
            }
        }

        return pelaajat;
    }
}
</pre>

  <p>Tehtävänäsi on täydentää runkoa siten, että jokaisesta luetusta rivistä luodaan pelaaja, joka lisätään pelaajat-listaan. Huom! <code>Tilasto</code>-luokka palauttaa characterStringja, joten joudut muuntamaan characterStringja myös numeroiksi. Esimerkiksi numeromuotoinen <code>ottelut</code> on muutettava <code>int</code>:iksi <code>Integer.parseInt</code>-metodilla.</p>

  <p>Jos characterStringn metodi <code>split</code> ei ole tuttu, se jakaa characterStringn useampaan osaan annetun merkin kohdalta. Esimerkiksi komento <code>characterString.split(";");</code> palauttaa characterStringsta taulukon, jossa alkuperäisen characterStringn puolipisteellä erotetut osat ovat kukin omassa taulukon indeksissä.</p>

  <p>Voit käyttää testauksen apuna seuraavaa pääohjelmaa:</p>

<pre class="sh_java">
        Tilasto tilasto = new Tilasto();

        PelaajatTilastosta pelaajienHakija = new PelaajatTilastosta();
        ArrayList&lt;Pelaaja&gt; pelaajat = pelaajienHakija.haePelaajat(tilasto);

        for (Pelaaja pelaaja : pelaajat) {
            System.out.println( pelaaja );
        }
</pre>

<h4>Maali ja syöttöpörssi</h4>

  <p>Haluamme tulostaa myös maalintekijäpörssin eli pelaajien tiedot maalimäärän mukaan järjestettynä sekä syöttöpörssin. <a href="http://www.nhl.com/ice/app?component=completePointLeadersList&page=statshome&service=direct">NHL:n</a> kotisivu tarjoaa tämänkaltaisen toiminnallisuuden, eli selaimessa näytettävä lista on mahdollista saada järjestettyä halutun kriteerin mukaan.</p>

  <p>Edellinen tehtävä määritteli pelaajien suuruusjärjestyksen perustuvan kokonaispistemäärään. Luokalla voi olla vain yksi <code>compareTo</code>-metodi, joten joudumme muunlaisia järjestyksiä saadaksemme turvautumaan muihin keinoihin.</p>

        <p>Vaihtoehtoiset järjestämistavat toteutetaan erillisten luokkien avulla. Pelaajien vaihtoehtoisten järjestyksen määräävän luokkien tulee toteuttaa <code>Comparator&lt;Pelaaja&gt;</code>-rajapinta. Järjestyksen määräävän luokan olio vertailee kahta parametrina saamaansa pelaajaa. Metodeja on ainoastaan yksi <code>compare(Pelaaja p1, Pelaaja p2)</code>, jonka tulee palauttaa negatiivinen arvo, jos pelaaja <code>p1</code> on järjestyksessä ennen pelaajaa <code>p2</code>, positiivinen arvo jos <code>p2</code> on järjestyksessä ennen
<code>p1</code>:stä ja 0 muuten.</p>

  <p>Periaatteena on luoda jokaista järjestämistapaa varten oma vertailuluokka, esim. maalipörssin järjestyksen määrittelevä luokka:</p>

<pre class="sh_java">
import java.util.Comparator;

public class Maali implements Comparator&lt;Pelaaja&gt; {
    public int compare(Pelaaja p1, Pelaaja p2) {
        // maalien perusteella tapahtuvan vertailun koodi tänne
    }
}
</pre>

  <p>Tee <code>Comparator</code>-rajapinnan toteuttavat luokat <code>Maali</code> ja <code>Syotto</code>, ja niille vastaavat maali- ja syöttöpörssien generoimiseen sopivat sopivat vertailufunktiot.</p>

  <p>Järjestäminen tapahtuu edelleen luokan <code>Collections</code> metodin <code>sort</code> avulla. Metodi saa nyt toiseksi parametrikseen järjestyksen määräävän luokan olion:</p>

<pre class="sh_java">
Maali maalintekijat = new Maali();
Collections.sort(pelaajat, maalintekijat);
System.out.println("NHL parhaat maalintekijät\n");

// tulostetaan maalipörssi
</pre>

  <p>Järjestyksen määrittelevä olio voidaan myös luoda suoraan sort-kutsun yhteydessä:</p>

<pre class="sh_java">
Collections.sort(pelaajat, new Maali());
System.out.println("NHL parhaat maalintekijät\n");

// tulostetaan maalipörssi
</pre>

  <p>Kun sort-metodi saa järjestyksen määrittelevän olion parametrina, se käyttää olion <code>compareTo()</code>-metodia pelaajia järjestäessään.</p>


</div>

<div class="tehtavat">

  <h3>Olioiden samuus</h3>

<p>
<b>pois?</b>
</p>

  <p>Kaikki oliot ovat tyyppiä <code>Object</code>, joten minkä tahansa tyyppisen olion voi antaa parametrina <code>Object</code>-tyyppisiä parametreja vastaanottavalle metodille.</p>

  <p>Tehtävän mukana tulee rajapinta <code>Vertaaja</code>. Toteuta pakkaukseen <code>samuus</code> luokka <code>OlioidenVertaaja</code>, joka toteuttaa rajapinnan <code>Vertaaja</code>. Metodien tulee toimia seuraavasti:</p>

  <ul>
    <li><strong>public boolean samaOlio(Object o1, Object o2)</strong> metodi palauttaa true, mikäli parametrina saatujen olioiden viitteet ovat samat, muutoin metodi palauttaa false. Olioiden viitteiden samuutta vertaillaan &quot;==&quot;-ilmaisulla.</li>
    <li><strong>public boolean vastaavat(Object o1, Object o2)</strong> metodi palauttaa true, mikäli parametrina saadut oliot ovat samanlaiset. Muutoin metodi palauttaa false. Käytä tässä vertailussa <code>equals</code>-metodia. Tarkemmin <code>equals</code>-metodin toiminnasta <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#equals(java.lang.Object)">Javan Object luokan APIsta</a>. Huomaa, että <code>equals</code>-metodin toiminta riippuu siitä, onko verrattavan olion luokka korvannut <code>Object</code>-luokassa määritellyn <code>equals</code>-metodin. </li>
    <li><strong>public boolean samacharacterStringEsitys(Object o1, Object o2)</strong> metodi palauttaa true, mikäli parametrina saatujen olioiden characterStringesitykset (metodin <code>toString</code>-palauttamat characterStringt) ovat samat. Muutoin metodi palauttaa false.</li>
  </ul>

  <p>Tehtävän mukana tulee luokka <code>Person</code>, jossa <code>equals</code>- ja <code>compareTo</code>-metodit on korvattu. Kokeile toteuttamiesi metodien toimintaa seuraavalla esimerkkikoodilla.</p>

<pre class="sh_java">
   OlioidenVertaaja vertaaja = new OlioidenVertaaja();
   Person henkilo1 = new Person("221078-123X", "Pekka", "Helsinki");
   Person henkilo2 = new Person("221078-123X", "Pekka", "Helsinki");  // täysin samansisältöinen kuin eka
   Person henkilo3 = new Person("110934-123X", "Pekka", "Helsinki");  // eri pekka vaikka asuukin helsingissä

   System.out.println(vertaaja.samaOlio(henkilo1, henkilo1));
   System.out.println(vertaaja.samaOlio(henkilo1, henkilo2));
   System.out.println(vertaaja.vastaavat(henkilo1, henkilo2));
   System.out.println(vertaaja.vastaavat(henkilo1, henkilo3));
   System.out.println(vertaaja.samacharacterStringEsitys(henkilo1, henkilo2));

   Person henkilo4 = new Person("221078-123X", "Pekka", "Savonlinna"); // henkilo1:n pekka mutta asuinpaikka muuttuu

   System.out.println(vertaaja.samaOlio(henkilo1, henkilo4));
   System.out.println(vertaaja.vastaavat(henkilo1, henkilo4));
   System.out.println(vertaaja.samacharacterStringEsitys(henkilo1, henkilo4));
</pre>

  <p>Ylläolevan koodin tulostuksen pitäisi olla seuraava:</p>

<pre>
true
false
true
false
true
false
true
false
</pre>


<h3>Kuviot</h3>

    <p>Tehtäväpohjan mukana tulee luokat <code>Ympyra</code>, <code>Suorakulmio</code> ja <code>TasasivuinenKolmio</code>. Luokat liittyvät samaan aihepiiriin, ja niillä on hyvin paljon yhteistä toiminnallisuutta. Tutustu luokkiin ennenkuin lähdet tekemään, jolloin hahmotat tarkemmin syyt muutoksille. Jos huomaat että luokissa on alustavasti sisennys hieman pielessä, kannattaa sisennys hoitaa kuntoon luettavuuden helpottamiseksi.</p>

    <h4>Kuvio</h4>

    <p>Toteuta pakkaukseen <code>kuviot</code> abstrakti luokka <code>Kuvio</code>, jossa on kuvioihin liittyvää toiminnallisuutta. Luokan kuvio tulee sisältää konstruktori <code>public Kuvio(int x, int y)</code>, metodit <code>public int getX()</code>, <code>public int getY()</code>, sekä abstraktit metodit <code>public abstract double pintaAla()</code> ja <code>public abstract double piiri()</code>.</p>


    <h4>Ympyra perii kuvion</h4>

    <p>Muuta luokan <code>Ympyra</code> toteutusta siten, että se perii luokan <code>Kuvio</code>. Luokan <code>Ympyra</code> ulkoinen toiminnallisuus ei saa muuttua, eli sen tulee tarjota samat metodit kuin aiemminkin -- joko luokan <code>Kuvio</code> avulla tai itse. Muistathan että konstruktorikutsun <code>super</code> avulla voit käyttää yliluokan konstruktoria. Kun metodi <code>public int getX()</code> on toteutettu jo yliluokassa se ei tarvitse erillistä toteutusta luokassa <code>Ympyra</code>.</p>

<pre class="sh_java">
        Kuvio kuvio = new Ympyra(10, 10, 15);
        System.out.println("X " + kuvio.getX());
        System.out.println("Y " + kuvio.getY());
        System.out.println("Pinta-ala " + kuvio.pintaAla());
        System.out.println("Piiri " + kuvio.piiri());
</pre>

<pre>
X 10
Y 10
Pinta-ala 706.85834...
Piiri 94.24777...
</pre>

    <h4>Suorakulmio ja Tasakylkinen kolmio perii kuvion</h4>

    <p>Muuta luokkien <code>Suorakulmio</code> ja <code>TasakylkinenKolmio</code> toteutusta siten, että ne perivät luokan <code>Kuvio</code>. Luokkien ulkoinen toiminnallisuus ei saa muuttua, eli niiden tulee tarjota samat metodit kuin aiemminkin -- joko luokan <code>Kuvio</code> avulla tai itse.</p>

<pre class="sh_java">
        Kuvio kuvio = new Suorakulmio(10, 10, 15, 15);
        System.out.println("X " + kuvio.getX());
        System.out.println("Y " + kuvio.getY());
        System.out.println("Pinta-ala " + kuvio.pintaAla());
        System.out.println("Piiri " + kuvio.piiri());
        System.out.println("");

        kuvio = new TasakylkinenKolmio(10, 10, 15);
        System.out.println("X " + kuvio.getX());
        System.out.println("Y " + kuvio.getY());
        System.out.println("Pinta-ala " + kuvio.pintaAla());
        System.out.println("Piiri " + kuvio.piiri());
</pre>

<pre>
X 10
Y 10
Pinta-ala 225.0
Piiri 60.0

X 10
Y 10
Pinta-ala 97.42785...
Piiri 45.0
</pre>


</div>



<h3>TreeMap</h3>

        <p>Joukkojen järjestyksessä pitäminen onnistuu <code>Set</code> rajapinnan toteuttavan <code>TreeSet</code>-olion avulla. Aiemmassa <code>Tehtavakirjanpito</code>-esimerkissä henkilökohtaiset tehtäväpisteet tallennettiin <code>Map</code>-rajapinnan toteuttavaan <code>HashMap</code>-olioon. Kuten <code>HashSet</code>, <code>HashMap</code> ei pidä alkioita järjestyksessä. Rajapinnasta <code>Map</code> on olemassa toteutus <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html" target="_blank">TreeMap</a></code>, jossa hajautustaulun avaimia pidetään järjestyksessä. Muutetaan <code>Tehtavakirjanpito</code>-luokkaa siten, että henkilökohtaiset pisteet tallennetaan <code>TreeMap</code>-tyyppiseen hajautustauluun.</p>

<pre class="sh_java">
public class Tehtavakirjanpito {
    private Map&lt;String, Set&lt;Integer&gt;&gt; tehdytTehtavat;

    public Tehtavakirjanpito() {
        this.tehdytTehtavat = new TreeMap&lt;String, Set&lt;Integer&gt;&gt;();
    }

    public void lisaa(String kayttaja, int tehtava) {
        if (!this.tehdytTehtavat.containsKey(kayttaja)) {
            this.tehdytTehtavat.put(kayttaja, new TreeSet&lt;Integer&gt;());
        }

        Set&lt;Integer&gt; tehdyt = this.tehdytTehtavat.get(kayttaja);
        tehdyt.add(tehtava);
    }

    public void tulosta() {
        for (String kayttaja: this.tehdytTehtavat.keySet()) {
            System.out.println(kayttaja + ": " + this.tehdytTehtavat.get(kayttaja));
        }
    }
}
</pre>

        <p>Muunsimme samalla <code>Set</code>-rajapinnan toteutukseksi <code>TreeSet</code>-luokan. Huomaa että koska olimme käyttäneet rajapintoja, muutoksia tuli hyvin pieneen osaan koodista. Etsi kohdat jotka muuttuivat!</p>

        <p>Käyttäjäkohtaiset tehtävät voidaan nyt tulostaa järjestyksessä.</p>

<pre class="sh_java">
        Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
        kirjanpito.lisaa("Mikael", 3);
        kirjanpito.lisaa("Mikael", 4);
        kirjanpito.lisaa("Mikael", 3);
        kirjanpito.lisaa("Mikael", 3);

        kirjanpito.lisaa("Pekka", 4);
        kirjanpito.lisaa("Pekka", 4);

        kirjanpito.lisaa("Matti", 1);
        kirjanpito.lisaa("Matti", 2);

        kirjanpito.tulosta();
</pre>

<pre>
Matti: [1, 2]
Mikael: [3, 4]
Pekka: [4]
</pre>


    <p>Luokka <code>TreeMap</code> vaatii että <em>avaimena</em> käytetyn luokan tulee toteuttaa <code>Comparable</code>-rajapinta. Jos luokka ei toteuta rajapintaa <code>Comparable</code>, voidaan luokalle <code>TreeMap</code> antaa konstruktorin parametrina <code>Comparator</code>-luokan toteuttama olio aivan kuten <code>TreeSet</code>-luokalle.</p>



<div class="tehtavat">



  <h3>Sähköposteja</h3>

  <p>Tehtävänäsi on toteuttaa sähköpostiohjelmaan komponentti, joka säilöö viestejä. Tehtäväpohjan mukana tulee luokka <code>Sahkoposti</code>, joka esittää sähköpostiviestiä. Luokalla <code>Sahkoposti</code> on oliomuuttujat:</p>

  <p>
    <ul>
      <li>saapumisaika (yksinkertaisesti kokonaisluku)</li>
      <li>lähettäjä</li>
      <li>otsikko</li>
      <li>sisältö</li>
    </ul>
  </p>

  <p>Toteutetaan tässä luokka <code>Viestivarasto</code>, joka tarjoaa sähköpostien hallintaan liittyviä toimintoja.</p>

  <h4>Viestivarasto, lisääminen ja hakeminen</h4>

<p>Luo pakkaukseen <code>posti</code> luokka <code>Viestivarasto</code>, ja lisää sille seuraavat metodit:</p>

<p>
  <ul>
    <li><code>public void lisaa(Sahkoposti s)</code> lisää viestin</li>
    <li><code>public Sahkoposti hae(String otsikko)</code> palauttaa viestin jolla on annettu otsikko tai <em>null</em> jos sellaista ei ole. </li>
  </ul>
</p>

<p>Voit olettaa että millään kahdella viestillä ei ole samaa otsikkoa.</p>



  <h4>Ajan perusteella hakeminen</h4>

  <p>Lisää luokkaan <code>Viestivarasto</code> seuraavat metodit</p>

<p>
  <ul>
    <li><code>public Sahkoposti hae(int aika)</code> palauttaa viestin joka saapui annettuun aikaan tai <em>null</em> jos sellaista ei ole. Voit olettaa että millään kahdella viestillä ei ole samaa saapumisaikaa.</li>
    <li><code>public Sahkoposti haeUusinViesti()</code> hakee uusimman viestin (eli sen jonka saapumisaika on isoin) ai <em>null</em> jos sellaista ei ole.</li>
    <li><code>public Sahkoposti haeUusinViesti(int ylaraja)</code> hakee uusimman viestin joka ei ole saapunut annetun ajan <code>ylaraja</code> jälkeen. Metodi palauttaa <em>null</em> jos tällaista viestiä ei ole.</li>
  </ul>
</p>

  <p><em>Huom!</em> Kannattaa käyttää kahta erillistä rakennetta viestien tallentamiseen. Otsikon perusteella tallentamiseen voit käyttää <code>HashMap</code>pia, ja viestien tallentamiseen ajan mukaan <code>TreeMap</code>pia. Näin saat toteutettua hae-operaatiot tehokkaasti. Tutustu myös <code>TreeMap</code>in metodeihin <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html#lastKey()" target="_blank">lastKey()</a></code> ja <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html#floorKey()" target="_blank">floorKey()</a></code>.</p>

</div>


<h2>Ohjelmien automaattinen testaaminen</h2>

<p><em>Errare humanum est</em></p>

<p>Ihminen on erehtyväinen ja paraskin ohjelmoija tekee virheitä. Ohjelman kehitysvaiheessa tapahtuvien virheiden lisäksi huomattava osa virheistä syntyy olemassa olevaa ohjelmaa muokattaessa. Ohjelman muokkauksen aikana tehdyt virheet eivät välttämättä näy muokattavassa osassa, vaan voivat ilmaantua välillisesti erillisessä osassa ohjelmaa: osassa, joka käyttää muutettua osaa.</p>

<p>Ohjelmien automaattinen testaaminen tarkoittaa toistettavien testien luomista. Testeillä varmistetaan että ohjelma toimii halutusti, ja että ohjelma säilyttää toiminnallisuutensa myös muutosten jälkeen. Sanalla <em>automaattinen</em> painotetaan sitä, että luodut testit ovat toistettavia ja että ne voidaan suorittaa aina haluttaessa -- ohjelmoijan ei tarvitse olla läsnä testejä suoritettaessa.</p>

<p>Otimme aiemmin askeleita kohti testauksen automatisointia antamalla Scanner-oliolle parametrina characterStringn, jonka se tulkitsee käyttäjän näppäimistöltä antamaksi syötteeksi. Automaattisessa testaamisessa testaaminen viedään viedä pidemmälle: koneen tehtävänä on myös tarkistaa että ohjelman tuottama vastaus on odotettu.</p>

<p>Automaattisen testauksen tällä kurssilla painotettu osa-alue on <em>yksikkötestaus</em>, jossa testataan ohjelman pienten osakokonaisuuksien -- metodien ja luokkien -- toimintaa. Yksikkötestaamiseen käytetään Javalla yleensä <a href="http://www.junit.org" target="_blank">JUnit</a>-testauskirjastoa.</p>

<h3>Pino ja automaattiset testit</h3>

<p>Pino on kaikille ihmisille tuttu asia. Esimerkiksi ravintola Unicafessa lautaset ovat yleensä pinossa. Pinon päältä voi ottaa lautasen ja pinon päälle voi lisätä lautasia. On myös helppo selvittää onko pinossa vielä lautasia jäljellä.</p>

<p>Pino on myös ohjelmoinnissa usein käytetty aputietorakenne. Rajapintana lukuja sisältävä pino näyttää seuraavalta.</p>

<pre class="sh_java">
public interface Pino {
    boolean tyhja();
    boolean taynna();
    void pinoon(int luku);
    int pinosta();
    int huipulla();
    int lukuja();
}
</pre>

<p>Rajapinnan määrittelemien metodien on tarkoitus toimia seuraavasti:</p>

<ul>
  <li><code>public boolean tyhja()</code> palauttaa true jos pino on tyhjä</li>
  <li><code>public boolean taynna()</code> palauttaa true jos pino on täynnä</li>
  <li><code>public void pinoon(int luku)</code> laittaa parametrina olevan luvun pinon päälle</li>
  <li><code>public int huipulla()</code> kertoo pinon huipulla olevan alkion</li>
  <li><code>public int pinosta()</code> poistaa ja palauttaa pinon päällä olevan alkion</li>
  <li><code>public int lukuja()</code> kertoo pinossa olevien lukujen määrän</li>
  <li><code>public int tilaa()</code> kertoo pinon vapaan tilan määrän</li>
</ul>

<p>Toteutetaan rajapinnan <code>Pino</code> toteuttava luokka <code>OmaPino</code>, johon talletetaan lukuja. Pinoon mahtuvien lukujen määrä annetaan pinon konstruktorissa. Toteutamme pinon hieman aiemmasta poikkeavasti -- emme testaa ohjelmaa pääohjelman avulla, vaan  käytämme pääohjelman sijasta automatisoituja JUnit-testejä ohjelman testaamiseen.</p>

<h4 class="req">Tutustuminen JUnitiin</h4>

<p>NetBeansissa olevat ohjelmamme ovat tähän asti sijainneet aina <em>Source Packages</em>issa tai sen sisällä olevissa pakkauksissa. Ohjelman lähdekoodit tulevat aina kansioon <em>Source Packages</em>. Automaattisia testejä luodessa testit luodaan valikon <em>Test Packages</em> alle. Uusia JUnit-testejä voi luoda valitsemalla projektin oikealla hiirennapilla ja valitsemalla avautuvasta valikosta <code>New -> JUnit Test...</code>. Jos vaihtoehto JUnit test ei näy listassa, löydät sen valitsemalla <em>Other</em>.</p>

<p><img src="img-ohja/testaus/new-junit-test.png"/></p>

<p>JUnit-testit sijaitsevat luokassa. Uutta testitiedostoa luodessa ohjelma pyytää testitiedoston nimen. Tyypillisesti nimeksi annetaan testattavan luokan tai toiminnallisuuden nimi. Luokan nimen tulee aina päättyä sanaan <code>Test</code>. Esimerkiksi alla luodaan testiluokka <code>PinoTest</code>, joka sijaitsee pakkauksessa <code>pino</code>. NetBeans haluaa luoda käyttöömme myös valmista runkoa testiluokalle -- joka käy hyvin.</p>

<p><img src="img-ohja/testaus/pinotest.png"/></p>

<p>Jos NetBeans kysyy minkä JUnit-version haluat käyttöösi, valitse <code>JUnit 4.x</code>.</p>

<p><img src="img-ohja/testaus/junit4.png"/></p>

<p>Kun testiluokka <code>PinoTest</code> on luotu, näkyy se projektin valikon <em>Test Packages</em> alla.</p>

<p><img src="img-ohja/testaus/pinotest-luotu.png"/></p>

<p>Luokka <code>PinoTest</code> näyttää aluksi seuraavalta</p>

<pre class="sh_java">
package pino;

import org.junit.*;
import static org.junit.Assert.*;

public class PinoTest {

    public PinoTest() {
    }

    @BeforeClass
    public static void setUpClass() throws Exception {
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
    }

    @Before
    public void setUp() {
    }

    @After
    public void tearDown() {
    }
    // TODO add test methods here.
    // The methods must be annotated with annotation @Test. For example:
    //
    // @Test
    // public void hello() {}
}
</pre>

<p>Meille oleellisia osia luokassa <code>PinoTest</code> ovat metodit <code>public void setUp</code>, jonka yläpuolella on merkintä <code>@Before</code>, ja kommentoitu metodipohja <code>public void hello()</code>, jonka yläpuolella on merkintä <code>@Test</code>. Metodit, joiden yläpuolella on merkintä <code>@Test</code> ovat ohjelman toiminnallisuutta testaavia testimetodeja. Metodi <code>setUp</code> taas suoritetaan ennen jokaista testiä.</p>

<p>Muokataan luokkaa <code>PinoTest</code> siten, että sillä testataan rajapinnan <code>Pino</code> toteuttamaa luokkaa <code>OmaPino</code>. Älä välitä vaikkei luokkaa <code>OmaPino</code> ole vielä luotu. Pino on testiluokan oliomuuttuja, joka alustetaan ennen jokaista testiä metodissa <code>setUp</code>.</p>

<pre class="sh_java">
package pino;

import org.junit.*;
import static org.junit.Assert.*;

public class PinoTest {

    Pino pino;

    @Before
    public void setUp() {
        pino = new OmaPino(3);
    }

    @Test
    public void alussaTyhja() {
        assertTrue(pino.tyhja());
    }

    @Test
    public void lisayksenJalkeenEiTyhja() {
        pino.pinoon(5);
        assertFalse(pino.tyhja());
    }

    @Test
    public void lisattyAlkioTuleePinosta() {
        pino.pinoon(3);
        assertEquals(3, pino.pinosta());
    }

    @Test
    public void lisayksenJaPoistonJalkeenPinoOnTaasTyhja() {
        pino.pinoon(3);
        pino.pinosta();
        assertTrue(pino.tyhja());
    }

    @Test
    public void lisatytAlkiotTulevatPinostaOikeassaJarjestyksessa() {
        pino.pinoon(1);
        pino.pinoon(2);
        pino.pinoon(3);

        assertEquals(3, pino.pinosta());
        assertEquals(2, pino.pinosta());
        assertEquals(1, pino.pinosta());
    }

    @Test
    public void tyhjennyksenJalkeenPinoonLaitettuAlkioTuleeUlosPinosta() {
        pino.pinoon(1);
        pino.pinosta();

        pino.pinoon(5);

        assertEquals(5, pino.pinosta());
    }

    // ...
}
</pre>

<p>Jokainen testi, eli merkinnällä <code>@Test</code> varustettu metodi, alkaa tilanteesta, jossa on luotu uusi tyhjä pino. Jokainen yksittäinen @Test-merkitty metodi on oma testinsä. Yksittäisellä testimetodilla testataan aina yhtä pientä osaa pinon toiminnallisuudesta. Testit suoritetaan toisistaan täysin riippumattomina, eli jokainen testi alkaa "puhtaaltä pöydältä", <code>setUp</code>-metodin alustamasta tilanteesta.</p>

<p>Yksittäiset testit noudattavat aina samaa kaavaa. Ensin luodaan tilanne jossa tapahtuvaa toimintoa halutaan testata, sitten tehdään testattava toimenpide, ja lopuksi tarkastetaan onko tilanne odotetun kaltainen. Esimerkiksi seuraava testi testaa että lisäyksen ja poiston jälkeen pino on taas tyhjä -- huomaa myös kuvaava testimetodin nimentä:</p>

<pre class="sh_java">
    @Test
    public void lisayksenJaPoistonJalkeenPinoOnTaasTyhja() {
        pino.pinoon(3);
        pino.pinosta();
        assertTrue(pino.tyhja());
    }
</pre>

<p>Ylläoleva testi testaa toimiiko metodi <code>tyhja()</code> jos pino on tyhjennetty. Ensin laitetaan pinoon luku metodilla <code>pinoon</code>, jonka jälkeen pino tyhjennetään kutsumalla metodia <code>pinosta()</code>. Tällöin on saatu aikaan tilanne jossa pinon <em>pitäisi</em> olla tyhjennetty. Viimeisellä rivillä testataan, että pinon metodi <code>tyhja()</code> palauttaa arvon <code>true</code> testausmetodilla <code>assertTrue()</code>. Jos metodi <code>tyhja()</code> ei palauta arvoa <code>true</code> näemme testejä suorittaessa virheen. </p>

<p>Jokainen testi päättyy jonkun <code>assert</code>-metodin kutsuun. Esimerkiksi metodilla <code>assertEquals()</code> voidaan varmistaa onko metodin palauttama luku tai characterString haluttu, ja metodilla <code>assertTrue()</code> varmistetaan että metodin palauttama arvo on <code>true</code>. Erilaiset <code>assert</code>-metodit saadaan käyttöön luokan alussa olevalla määrittelyllä <code>import static org.junit.Assert.*;</code>.

<p>Testit suoritetaan joko painamalla <em>alt</em> ja <em>F6</em> tai valitsemalla <em>Run -> Test project</em>. (Macintosh-koneissa tulee painaa <em>ctrl</em> ja <em>F6</em>). Punainen väri ilmaisee että testin suoritus epäonnistui -- testattava toiminnallisuus ei toiminut kuten toivottiin. Vihreä väri kertoo että testin testaama toiminnallisuus toimi kuten haluttiin.</p>

<h4 class="req">Luokan OmaPino toteutus</h4>

<p>Pinon toteuttaminen testien avulla tapahtuisi askel kerrallaan siten, että lopulta kaikki testit toimivat. Ohjelman rakentaminen aloitetaan yleensä hyvin varovasti. Rakennetaan ensin luokka <code>OmaPino</code> siten, että ensimmäinen testi <em>alussaTyhja</em> alkaa toimimaan. Älä tee mitään kovin monimutkaista, "quick and dirty"-ratkaisu kelpaa näin alkuun. Kun testi menee läpi (eli näyttää vihreää), siirry ratkaisemaan seuraavaa kohtaa.</p>

<p>Testi <em>alussaTyhja</em> menee läpi aina kun palautamme arvon <code>true</code> metodista <code>tyhja</code>.</p>

<pre class="sh_java">
package pino;

import java.util.ArrayList;
import java.util.List;

public class OmaPino implements Pino {

    public OmaPino(int maksimikoko) {
    }

    @Override
    public boolean tyhja() {
        return true;
    }

    // tyhjät metodirungot
</pre>

<p>Siirrytään ratkaisemaan kohtaa <em>lisayksenJalkeenEiTyhja</em>. Tarvitsemme toteutuksen metodille <code>pinoon</code>. Yksi lähestymistapa on muokata luokkaa <code>OmaPino</code> siten, että se sisältää taulukon. Taulukkoa käytetään, että pinottavat values talletetaan pinon taulukkoon yksi kerrallaan. Seuraava kuvasarja selkeyttää taulukossa olevien alkioiden pinoon laittamista ja pinosta ottamista.</p>

<pre>
<font color ="red">pino = new OmaPino(4);</font>

  0   1   2   3
-----------------
|   |   |   |   |
-----------------
alkioita: 0

<font color ="red">pino.pinoon(5);</font>

  0   1   2   3
-----------------
| 5 |   |   |   |
-----------------
alkiota: 1

<font color ="red">pino.pinoon(3);</font>

  0   1   2   3
-----------------
| 5 | 3 |   |   |
-----------------
alkiota: 2

<font color ="red">pino.pinoon(7);</font>

  0   1   2   3
-----------------
| 5 | 3 | 7 |   |
-----------------
alkiota: 3

<font color ="red">pino.pinosta();</font>

  0   1   2   3
-----------------
| 5 | 3 |   |   |
-----------------
alkiota: 2
</pre>

<p>Ohjelman tulee siis muistaa kuinka monta alkiota pinossa on. Uusi alkio laitetaan jo pinossa olevien perään. Alkion poisto aiheuttaa sen, että taulukon viimeinen käytössä ollut paikka vapautuu ja alkiomäärän muistavan muuttujan arvo pienenee.</p>

<p>Luokan <code>OmaPino</code> toteutusta jatketaan askel kerrallaan kunnes kaikki testit menevät läpi. Jossain vaiheessa ohjelmoija todennäköisesti huomaisi, että taulukko kannattaa vaihtaa <code>ArrayList</code>-rakenteeksi.</p>

<p>Huomaat todennäköisesti ylläolevan esimerkin luettuasi että olet jo tehnyt hyvin monta testejä käyttävää ohjelmaa. Osa TMC:n toiminnallisuudesta rakentuu JUnit-testien varaan, ongelmat ovat varsinkin kurssin alkupuolella pilkottu pieniin testeihin, joiden avulla ohjelmoijaa on ohjattu eteenpäin. TMC:n mukana tulevat testit ovat kuitenkin usein monimutkaisempia kuin ohjelmien normaalissa automaattisessa testauksessa niiden tarvitsee olla. TMC:ssä ja kurssilla käytettävien testien kirjoittajien tulee muunmuassa varmistaa luokkien olemassaolo, jota normaalissa automaattisessa testauksessa harvemmin tarvitsee tehdä.</p>

<p>Harjoitellaan seuraavaksi ensin testien lukemista, jonka jälkeen kirjoitetaan muutama testi.</p>

<div class="tehtavat" id="viikko11">



  <h3>Tehtävälista</h3>

  <p>Tehtäväpohjassa on rajapinnan <code>Tehtavalista</code> toteuttava luokka <code>MuistiTehtavalist</code>. Ohjelmaa varten on koodattu valmiiksi testit, joita ohjelma ei kuitenkaan läpäise. Tehtävänäsi on tutustua testiluokkaan <code>TehtavalistaTest</code>, ja korjata luokka <code>MuistiTehtavalista</code> siten, että ohjelman testit menevät läpi.</p>

  <p>Huom! Tässä tehtävässä sinun ei tarvitse koskea  testiluokkaan <code>TehtavalistaTest</code>.</p>


  <h3>Lukutilasto</h3>

  <p><em>Huom!</em> Tässä tehtävässä on jo mukana testiluokka, johon sinun tulee kirjoittaa lisää testejä. Vastauksen oikeellisuus testataan vasta TMC-palvelimella: tehtävästä saa pisteet vasta kun <em>molemmat</em> tehtävät on suoritettu palvelimella hyväksytysti. Ole tarkka metodien nimennän <em>ja</em> lisättyjen lukujen kanssa.</p>

  <p>Tehtävässä tulee pakkauksessa <code>tilasto</code> sijaitseva luokka <code>Lukutilasto</code>.</p>

<ul>
  <li><code>public void lisaaLuku(int luku)</code><br/>Lisää annetun luvun lukutilastoon.</li>
  <li><code>public int sum()</code><br/>Palauttaa tilastossa olevien lukujen summan.</li>
  <li><code>public int lukujenMaara()</code><br/>Palauttaa tilastossa olevien lukujen maaran.</li>
  <li><code>public boolean sisaltaa(int luku)</code><br/>Palauttaa totuusarvon, joka kertoo onko parametrina annettu luku tilastossa.</li>
</ul>

  <p>Testikansiossa olevassa pakkauksessa <code>tilasto</code> on luokka <code>LukutilastoTest</code>, johon sinun tulee lisätä uusia testimetodeja.</p>

  <h4>Lukujen määrän kasvamisen tarkistus</h4>

  <p>Lisää testiluokkaan testimetodi <code>public void lukujenMaaraKasvaaKahdellaKunLisataanKaksiLukua()</code>, jossa lukutilastoon lisätään values 3 ja 5. Tämän jälkeen metodissa tarkistetaan että lukutilastossa on kaksi lukua käyttäen lukutilaston metodia lukujenMaara. Käytä <code>Assert</code>-luokan <code>assertEquals</code>-metodia palautettujen arvojen tarkastamiseen.</p>

  <h4>Summan tarkistus yhdellä luvulla</h4>

  <p>Lisää testiluokkaan testimetodi <code>public void summaOikeinYhdellaLuvulla()</code>, jossa lukutilastoon lisätään luku 3. Tämän jälkeen metodissa tarkistetaan lukutilaston summa-metodin avulla että tilastossa olevien lukujen summa on 3.  Käytä <code>Assert</code>-luokan <code>assertEquals</code>-metodia palautettujen arvojen tarkastamiseen.</p>
</div>



<h3>Jätkänshakin sovelluslogiikka (pakollinen)</h3>

<p><em>Huom!</em> tämä tehtävä on pakollinen yliopistoon hakeville.</p>

<p><em>Tämä tehtävä on kolmen yksittäisen tehtäväpisteen arvoinen.</em> Tehtävässä toteutetaan sovelluslogiikka jätkänshakille ja harjoitellaan ohjelmarakenteen osittaista omatoimista suunnittelua.</p>

<p>Tehtäväpohjassa tulee mukana käyttöliittymä <a href="http://fi.wikipedia.org/wiki/Ristinolla">jätkänshakille</a>, jossa pelilaudan koko on aina 3x3 ruutua. Käyttöliittymä huolehtii ainoastaan pelilaudalla tehtyihin tapahtumiin reagoimisesta, sekä pelilaudan ja pelitilanteen tietojen päivittämisestä. Pelin logiikka on erotettu <code>JatkanshakinSovelluslogiikka</code>-rajapinnan avulla omaksi luokakseen.</p>

<pre class="sh_java">
package jatkanshakki.sovelluslogiikka;

public interface JatkanshakinSovelluslogiikka {
    char getNykyinenVuoro();
    int getMerkkienMaara();

    void asetaMerkki(int sarake, int rivi);
    char getMerkki(int sarake, int rivi);

    boolean isPeliLoppu();
    char getVoittaja();
}
</pre>


<p>Rajapinnan <code>JatkanshakinSovelluslogiikka</code> lisäksi tehtäväpohjassa on apuluokka, joka määrittelee pelilaudan ruutujen mahdolliset tilat <code>char</code>-tyyppisinä kirjaimina. Ruutu voi olla joko tyhjä, tai siinä voi olla risti tai nolla. Apuluokassa <code>Jatkanshakki</code> on näille määrittelyt:</p>

<pre class="sh_java">
package jatkanshakki.sovelluslogiikka;

public class Jatkanshakki {
    public static final char RISTI = 'X';
    public static final char NOLLA = 'O';
    public static final char TYHJA = ' ';
}
</pre>

<p>Tehtävänäsi on täydentää pakkauksessa <code>jatkanshakki.sovelluslogiikka</code> olevaa rajapinnan <code>JatkanshakinSovelluslogiikka</code> toteuttavaa luokkaa <code>OmaJatkanshakinSovelluslogiikka</code>. Luokka <code>OmaJatkanshakinSovelluslogiikka</code> mahdollistaa jätkänshakin pelaamisen.</p>

<p>Rajapinta <code>JatkanshakinSovelluslogiikka</code> määrittelee seuraavat toiminnot, jotka luokan <code>OmaJatkanshakinSovelluslogiikka</code> tulee toteuttaa:</p>

  <ul>
    <li><strong>char getNykyinenVuoro()</strong> palauttaa pelaajan merkkiä vastaavan arvon: <code>RISTI</code>, <code>NOLLA</code> tai pelin päätyttyä <code>TYHJA</code></li>
    <li><strong>int getMerkkienMaara()</strong> palauttaa pelilaudalle tähän mennessä asetettujen merkkien määrän (välillä 0-9)</li>
    <li><strong>void asetaMerkki(int sarake, int rivi)</strong> asettaa pelaajan vuoron mukaisen merkin annettuun ruutuun sarakkeen (0-2) ja rivin (0-2) perusteella ja antaa vuoron toiselle pelaajalle. Metodi heittää poikkeuksen <code>IllegalArgumentException</code>, jos sarake tai rivi on pelilaudan ulkopuolella tai ruudussa on jo merkki, ja poikkeuksen <code>IllegalStateException</code>, jos peli on jo loppu.</li>
    <li><strong>char getMerkki(int sarake, int rivi)</strong> palauttaa sarakkeen ja rivin määrittelemän ruudun tilan, joka voi olla <code>TYHJA</code>, <code>RISTI</code> tai <code>NOLLA</code>. Metodi heittää poikkeuksen <code>IllegalArgumentException</code>, jos sarake tai rivi on pelilaudan ulkopuolella.</li>
    <li><strong>boolean isPeliLoppu()</strong> palauttaa arvon <code>true</code>, jos toinen pelaajista voitti pelin tai peli päättyi tasapeliin, muutoin metodi palauttaa <code>false</code></li>
    <li><strong>char getVoittaja()</strong> palauttaa arvon <code>TYHJA</code>, jos peli on kesken tai peli päättyi tasapeliin, muutoin metodi palauttaa voittajan merkin: <code>RISTI</code> tai <code>NOLLA</code></ul>

<p>Ensimmäinen pelivuoro on aina merkillä <code>RISTI</code>. Pelin voittaa se pelaaja, joka saa ensimmäisenä kolme merkkiä vaakasuoraan, pystysuoraan tai vinottain. Tasapeli todetaan vasta, kun pelilauta on täynnä merkkejä eli tyhjiä ruutuja ei enää ole.</p>

<p><b>Vinkki:</b> Pelilaudan tilanteen voi esittää esimerkiksi yhdeksän alkion <code>char</code>-taulukolla, jonne talletetaan peliruutujen tilat. Sarakkeen ja rivin perusteella voidaan laskea taulukon indeksi: <code>rivi * 3 + sarake</code>.</p>

</div>



<!-- END SNIP -->

<!-- FLOATING MENU -->
<div id="fl_menu">
  <div class="label">Materiaali</div>
  <div class="menu" id="fl_menu_items">
  </div>
</div>



<script>
//config
$float_speed=0; //milliseconds
$float_easing="easeOutQuint";
$menu_fade_speed=0; //milliseconds
$closed_menu_opacity=0.5;

//cache vars
$fl_menu=$("#fl_menu");
$fl_menu_menu=$("#fl_menu .menu");
$fl_menu_label=$("#fl_menu .label");

$(window).load(function() {
    menuPosition=$('#fl_menu').position().top;
    FloatMenu();
    $fl_menu.hover(
        function(){ //mouse over
            $fl_menu_label.fadeTo($menu_fade_speed, 1);
            $fl_menu_menu.fadeIn($menu_fade_speed);
        },
        function(){ //mouse out
            $fl_menu_label.fadeTo($menu_fade_speed, $closed_menu_opacity);
            $fl_menu_menu.fadeOut($menu_fade_speed);
        }
    );
});

$(window).scroll(function () {
    FloatMenu();
});

function FloatMenu(){
    var scrollAmount=$(document).scrollTop();
    var newPosition=menuPosition+scrollAmount;
    if($(window).height()<$fl_menu.height()+$fl_menu_menu.height()){
        $fl_menu.css("top",menuPosition);
    } else {
        $fl_menu.stop().animate({top: newPosition}, $float_speed, $float_easing);
    }
}
</script>



</body>

</html>


