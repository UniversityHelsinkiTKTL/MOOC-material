<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Programming Basics Continuation Course, Spring 2012</title>
    <link rel="stylesheet" href="stylesheets/common.css" type="text/css" media="screen, print" />
    <link rel="stylesheet" href="stylesheets/menu.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="stylesheets/shjs/sh_style.css" type="text/css" media="screen, print" />
    <link rel="stylesheet" href="stylesheets/exercises.css" type="text/css" media="screen, print" />

    <script type="text/javascript" src="javascripts/jquery-1.7.1.min.js"></script>

    <script type="text/javascript" src="javascripts/exercises-test.js"></script>
    <script type="text/javascript" src="javascripts/common-new.js"></script>

    <script type="text/javascript" src="javascripts/jquery.easing.js"></script>
    <script type="text/javascript" src="javascripts/shjs/sh_main.min.js"></script>
    <script type="text/javascript" src="javascripts/shjs/sh_java.min.js"></script>
</head>
<body>
    <h1>Advanced programming course</h1>

    <p>Arto Vihavainen and Matti Luukkainen</p>

    <div id="toc" class="menu" data-first-chapter-index="1" data-first-exercise-index="109">
      <div id="materiaali_toc"></div>
      <div id="tehtavat_toc"></div>
    </div>

    <p><strong><big>Note for the reader</big></strong></p>

    <p>This is direct continuation to the programming basics course <a href="../ohpe/index.html">material</a>.</p>

    <p>This material is meant for the Helsinki University Department of Computer Science fall 2012 programming basics and advanced programming course. The material is based on springs of 2012, 2011, and 2010 course materials, of which content has been affected by Matti Paksula, Antti Laaksonen, Pekka Mikkola, Juhana Laurinharju, Martin Pärtel, Joel Kaasinen  and Mikael Nousiainen.</p>

    <p>Read the material so that you do all of the examples you read yourself. It's worth making small changes to the examples and observe how the changes affect the program. At first you might think that doing the examples yourself and editing them too would slow down your learning. However, this isn't true at all. As far as we know, no one has yet learned to program by just reading (or by just listening to a lecture). Learning is based substantially on actively doing and growing a routine. The examples, and especially doing your own experiments, are one of the best ways to truly internalize the read text.</p>

    <p>Try to do assignments, or at least to try them out as you read the text. If you can't get an assignment pass right off the bat, don't get depressed, since you'll be always able to get help with the assignment at the workshop.</p>

    <p>The text isn't meant to be just read once. You'll most certainly have to return to parts you've already read, or to assignments you've already done. This text doesn't contain everything essential related to programming. As a matter of fact, no book exists that would have everything essential. So you will in every case - on your programming career - have to find information on your own. The excersises of the course already hold some instructions on how and where you'd be able to find useful information.</p>

    <p>To some parts we've also attached screencasts; by watching the videos you'll be able to see how the code is written instead of just reading ready-made code.</p>

    <p></p>

    <p>The course picks up where the programming basics left off, and everything learned in the programming basics course is now assumed to be known. It's a good idea to go and check the <a href="../ohpe/index.html">material</a> of the programming basics course.</p>


    <p><em>Note!</em> On this course we use a programming environment known as <a href="http://netbeans.org/">NetBeans</a>. The instructions for using NetBeans and the assignment server can be found <a href="netbeans.html">here</a>.</p>

<div class="tyhja"></div>

<div class="viikkoraja">Week 1</div>



<h2>Recapping the programming basics</h2>

    <p>In this chapter we briefly recap a few concepts we became familiar with in the programming basics. You can familiarize yourself with the programming basics course material <a href="../ohpe/index.html">here</a>.</p>

    <p>Rusty programming skills can also be refreshed with the help of the excersises found <a href="http://www.cs.helsinki.fi/group/java/s12/ohpe/materiaali-ohpekertaus.html">here</a>.</p>

    <h3>Program, commands and variables</h3>

    <p>A computer program consists of a series of commands that a computer runs one at a time, from top to bottom. The commands always have a predefined structure and semantics. In Java - the programming language we use on the course - the commands are read from top to down, left to right. Programming courses are traditionally started by introducing a program that prints the string <code>Hello World!</code>. Below is a command written in Java that prints the <code>Hello World!</code> string.</p>

<pre class="sh_java">
        System.out.println("Hello World!");
</pre>

    <p>In the command the method <code>println</code> - which belongs to the <code>System</code> class - gets called, which prints the string passed in to it as a parameter, and after that a linebreak. The method is given the string <code>Hello World!</code> as a parameter; consequently the program prints out <code>Hello World!</code> followed by a linebreak.</p>

    <p>Variables can be used as part of the functionality of the program. Below is a program which introduces the variable <code>length</code> of the integer type. The value 197 is set to this variable on the next line. After this the value <code>179</code> of the variable <code>length</code> is printed.</p>

<pre class="sh_java">
        int length;
        length = 179;
        System.out.println(length);
</pre>

    <p>The execution of the program above would happen one line at a time. First the line <code>int length;</code> is executed, in which the variable <code>length</code> is introduced. Next the line <code>length = 179;</code> is executed, in which we set the value <code>179</code> to the variable that was introduced on the previous line. After this the line <code>System.out.println(length);</code> is run, in which we call the print method we saw earlier. To this method we give the variable <code>length</code> as a parameter. The method prints the content - the value - of the variable <code>length</code>, which is <code>179</code>.</p>

    <p>In the program above we really wouldn't have to introduce the variable <code>length</code> on one line and then set it's value on the next. The introduction of a variable and setting it's value can be done on the same line.</p>

<pre class="sh_java">
        int length = 179;
</pre>

    <p>When executing the line above, the variable <code>length</code> is introduced and as it is introduced the value <code>179</code> is set to it.</p>

    <p>In reality all information within a computer is represented as a series of bits - ones and zeros. Variables are an abstraction offered by the programming language with which we can handle different values more easily. The variables are used to store values and to maintain the state of the program. In Java, we have the primitive variable types <code>int</code> (integer), <code>double</code> (floating-point), <code>boolean</code> (truth value), <code>char</code> (character), and the reference variable types <code>String</code> (character string), <code>ArrayList</code> (array), and all classes. We'll return to primitive data type variables and to reference type variables and their differences later.</p>


<h3>Comparing variables and reading input</h3>

    <p>The functionality of programs is built with the help of control structures. Control structures make different functions possible depending on the variables of the program. Below, an example of an <code>if - else if - else</code> control structure, in which a different function is made depending on result of the comparison. In the example a string <code>Accelerate</code> is printed if the value of the variable <code>speed</code> is smaller than 110, the string <code>Break</code> if the <code>speed</code> is greater than 120, and the string <code>Cruising</code> in other cases.</p>

<pre class="sh_java">
        int speed = 105;

        if (speed < 110) {
            System.out.println("Accelerate");
        } else if (speed > 120) {
            System.out.println("Break");
        } else {
            System.out.println("Cruising");
        }
</pre>

        <p>Because in the example above the value of the variable <code>speed</code> is 105, the program will always print the string <code>Accelerate</code>. Remember that the comparison of strings is done with the <code>equals</code> method that belongs to the string. Below is an example in which an object created from Java's <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html" target="_blank">Scanner</a> class is used to read the input of a user. The program checks if the strings entered by the user are equal.</p>

<pre class="sh_java">
        Scanner reader = new Scanner(System.in);

        System.out.print("Enter the first string: ");
        String first = reader.nextLine();

        System.out.print("Enter the second string: ");
        String second = reader.nextLine();

        System.out.println();

        if (first.equals(second)) {
            System.out.println("The strings you entered are the same!");
        } else {
            System.out.println("The strings you entered weren't the same!");
        }
</pre>

        <p>The functionality of the program depends on the user's input. Below is an example; the red text is user input.</p>

<pre>
Enter the first string: <font color="red">carrot</font>
Enter the second string: <font color="red">lettuce</font>

The strings you entered weren't the same!
</pre>

<h3>Loops</h3>

        <p>Repetition is often required in programs. First we make a so-called while-true-break loop, which we run until the user inputs the string <code>password</code>. The statement <code>while(true)</code> begins the loop, which will then be repeated until it runs into the keyword <code>break</code>.</p>

<pre class="sh_java">
        Scanner reader = new Scanner(System.in);

        while (true) {
            System.out.print("Enter password: ");
            String password = reader.nextLine();

            if (password.equals("password")) {
                break;
            }
        }

        System.out.println("Thanks!");
</pre>


<pre>
Enter password: <font color="red">carrot</font>
Enter password: <font color="red">password</font>
Thanks!
</pre>


        <p>You can also pass a comparison to a while loop instead of the boolean <code>true</code>. Below, the user input is printed so that there's stars above and below it.</p>

<pre class="sh_java">
        Scanner reader = new Scanner(System.in);

        System.out.print("Enter string: ");
        String characterString = reader.nextLine();

        int starNumber = 0;
        while (starNumber &lt; characterString.length()) {
            System.out.print("*");
            starNumber = starNumber + 1;
        }
        System.out.println();

        System.out.println(characterString);

        starNumber = 0;
        while (starNumber &lt; characterString.length()) {
            System.out.print("*");
            starNumber = starNumber + 1;
        }
        System.out.println();
</pre>


<pre>
Enter string: <font color="red">carrot</font>
******
carrot
******
</pre>

        <p>The example above should make you feel a little bad inside. The bad feelings are hopefully because you see that the example violates the rules learned in the programming basics. The example has unneccessary repetition which should be removed with the help of methods.</p>

        <p>In addition to the while-loop we also have two versions of the for-loop at our disposal. The newer for-loop is used for going through lists.</p>

<pre class="sh_java">
        ArrayList&lt;String&gt; greets = new ArrayList&lt;String&gt;();
        greets.add("Hei");
        greets.add("Hallo");
        greets.add("Hi");

        for (String greet: greets) {
            System.out.println(greet);
        }
</pre>

<pre>
Hei
Hallo
Hi
</pre>

        <p>The more traditional for-loop is used in situations similiar to where you would use a while-loop. It can, for example, be used to go through arrays. In the following example all values in the array <code>values</code> will be multiplied by two and then finally printed using the newer for-loop.</p>

<pre class="sh_java">
        int[] values = new int[] {1, 2, 3, 4, 5, 6};

        for (int i = 0; i &lt; values.length; i++) {
            values[i] = values[i] * 2;
        }

        for (int value: values) {
            System.out.println(value);
        }
</pre>

<pre>
2
4
6
8
10
12
</pre>

        <p>The traditional for-loop is very useful in cases where we go through indices one at a time. The loop below will go through the characters of a character string one by one, and prints the character string <code>Hip!</code> every time we encounter the character <code>a</code>.</p>

<pre class="sh_java">
        String characterString = "saippuakauppias";
        for (int i = 0; i &lt; characterString.length(); i++) {
            if (characterString.charAt(i) == 'a') {
                System.out.println("Hip!");
            }
        }
</pre>

<pre>
Hip!
Hip!
Hip!
Hip!
</pre>

<h3>Methods</h3>

    <p>Methods are a way of chopping up the functionality of a program into smaller entities. All Java programs start their execution from the <code>main</code> program method, which is defined with the statement <code>public static void main(String[] args)</code>. The statement defines a static method - that is a method which belongs to the class - which receives a character string array as its parameter.</p>

    <p>The program defines methods to abstract the functionalities of the program. When programming, one should try to achieve a situation in which the program can be looked at from a <em>higher level</em>, in such a case the main method consists of calls to a group of self-defined, well-named methods. The methods then specify the functionality of the program and perhaps are based on calls to other methods.</p> 

    <p>Methods that are defined using the keyword <code>static</code> belong to the <em>class</em> that holds the method, and work as so-called support methods. The methods that are defined without the keyword <code>static</code> belong to the instances - <em>the objects</em> - created from the class and can modify the state of that individual object.</p>

    <p>A method always has a visibility modifier (public, visible to 'everyone', or private, only visible within its class), a return type (void, returns nothing) and a name. In the following code we create a method which belongs to a class, <code>public static void print(String characterString, int times)</code>. This method prints a character string the defined amount of times. This time we use the method <code>System.out.print</code>, which works just like <code>System.out.println</code>, but doesn't print a linebreak.</p>

<pre class="sh_java">
        public static void print(String characterString, int times) {
            for (int i = 0; i &lt; times; i++) {
                System.out.print(characterString);
            }
        }
</pre>

    <p>The method above prints the character string it receives as a parameter, the amount of times the integer - which was also passed in as a parameter - says.</p>

    <p>In the chapter on loops we noticed that the code had some nasty copy-paste stuff in it. With the help of methods, we can move the printing of stars to a separate method. We create a method <code>public static void printStars(int times)</code>, which prints the amount of stars it receives as a parameter. The method uses a <code>for</code> loop instead of a <code>while</code>.</p>

<pre class="sh_java">
        public static void printStars(int times) {
            for (int i = 0; i < kertaa; i++) {
                System.out.print("*");
            }
            System.out.println();
        }
</pre>

        <p>Metodia hyödyntäessä aiemmin kauhistusta aihettanut esimerkkimme näyttää seuraavalta.</p>

<pre class="sh_java">
        Scanner lukija = new Scanner(System.in);

        System.out.print("Syötä characterString: ");
        String characterString = reader.nextLine();

        printStars(characterString.length());
        System.out.println(characterString);
        printStars(characterString.length());
</pre>


<h3>Class</h3>

    <p>Methods can abstract a program up to a certain point, but as the program becomes larger it's sensible to chop down the program even further into smaller and more logical entities. With the help of classes, we can define higher level concepts of a program and functionalities related to those concepts. Every Java program requires a class in order to work, so the <code>Hello World!</code> example wouldn't work without the class definition. A class is defined with the keywords <code>public class nameOfTheClass</code>.</p>

<pre class="sh_java">
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
</pre>

    <p>In a program, classes are used to define concepts and functionalities related to those concepts. Objects can be created from a class which are the embodiments of the class. Every object belongs to a certain class has the same structure, but the variables belonging to the objects can be different. The methods of objects handle the state of the object, that is, the variables of the object.</p>

    <p>Let's inspect the class <code>Book</code> below; the class has the object variables name (String) and publishingYear (integer).</p>

<pre class="sh_java">
        public class Book {
            private String name;
            private int publishingYear;

            public Book(String name, int publishingYear) {
                this.name = name;
                this.publishingYear = publishingYear;
            }

            public String getName() {
                return this.name;
            }

            public int getPublishingYear() {
                return this.publishingYear;
            }
        }
</pre>

    <p>The definition in the beginning, <code>public class Book</code>, tells the name of the class. This is followed by the definitions of object variables. Object variables are variables which for each of the objects created from the class are their own -- the object variables of one object are unrelated to the state of the same variables of another object. It's usually appropriate to hide the object variables from the users of the class, to define the visibility modifier <em>private</em> for them. If the visibility modifier is set to <em>public</em>, the user of the object will be able to directly access the object variables.</p>

    <p>Objects are created from a class with a <em>constructor</em>. A constructor is a method that initializes an object (creates the variables belonging to the object) and executes the commands that are within the constructor. The constructor is always named the same as the class that has the constructor in it. In the constructor <code>public Book(String name, int publishingYear)</code> a new object is created from the class <code>Book</code> and it's variables are set to the values that were passed in as parameters.</p>

    <p>Two methods that handle the information in the object are also defined for the class above. The method <code>public String getName()</code> returns the name of the object in question. The method <code>public int getPublishingYear()</code> returns the publishing year of the object in question.</p>

    <h3>Object</h3>

    <p>Objects are created with the help of the constructor that is defined within a class. In the program code the costructor is called with the <code>new</code> command, which returns a reference to the new object. Objects are instances created from classes. Let's inspect a program that creates two different books, after which it prints the values returned by the <code>getName</code> methods beloning to the objects.</p>

<pre class="sh_java">
        Book senseAndSensibility = new Book("Sense and Sensibility", 1811);
        Book prideAndPrejudice = new Book("Pride and Prejudice", 1813);

        System.out.println(senseAndSensibility.getName());
        System.out.println(prideAndPrejudice.getName());
</pre>

<pre>
Sense and Sensibility
Pride and Prejudice
</pre>

    <p>So, each object has it's own internal state. The state is formed from object variables that belong to the object. Object variables can be both primitive type variables and reference type variables. If reference type variables belong to the objects, it is possible that other objects also refer to the same referenced objects! Let's visualize this with the bank example, in which there's accounts and persons.</p>

<pre class="sh_java">
        public class Account {
            private String accountID;
            private int balanceAsCents;

            public Account(String accountID) {
                this.accountID = accountID;
                this.balanceAsCents = 0;
            }

            public void deposit(int sum) {
                this.balanceAsCents += sum;
            }

            public int getBalanceAsCents() {
                return this.balanceAsCents;
            }

            // .. other methods related to an account
        }
</pre>

<pre class="sh_java">
        import java.util.ArrayList;

        public class Person {
            private String name;
            private ArrayList&lt;Account&gt; accounts;

            public Person(String name) {
                this.name = name;
                this.accounts = new ArrayList&lt;Account&gt;();
            }

            public void addAccount(Account account) {
                this.accounts.add(account);
            }

            public int moneyTotal() {
                int total = 0;
                for (Account account: this.accounts) {
                    total += account.getBalanceAsCents();
                }

                return total;
            }

            // ... other methods related to a person
        }
</pre>

    <p>Each object created from the <code>Person</code> class has it's own name and it's own list of accounts. Next, let's create two persons and two accounts. One of the accounts is owned by only one person and the other one is shared.</p>

<pre class="sh_java">
        Person matti = new Person("Matti");
        Person maija = new Person("Maija");

        Account salaryAccount = new Account("NORD-LOL");
        Account householdAccount = new Account("SAM-LOL");

        matti.addAccount(salaryAccount);
        matti.addAccount(householdAccount);
        maija.addAccount(householdAccount);

        System.out.println("Money on Matti's accounts: " + matti.moneyTotal());
        System.out.println("Money on Maija's accounts: " + maija.moneyTotal());
        System.out.println();

        salaryAccount.deposit(150000);

        System.out.println("Money on Matti's accounts: " + matti.moneyTotal());
        System.out.println("Money on Maija's accounts: " + maija.moneyTotal());
        System.out.println();

        householdAccount.deposit(10000);

        System.out.println("Money on Matti's accounts: " + matti.moneyTotal());
        System.out.println("Money on Maija's accounts: " + maija.moneyTotal());
        System.out.println();
</pre>

<pre>
Money on Matti's accounts: 0
Money on Maija's accounts: 0

Money on Matti's accounts: 150000
Money on Maija's accounts: 0

Money on Matti's accounts: 160000
Money on Maija's accounts: 10000
</pre>

    <p>Initially, the accounts of both persons are empty. When money is added to the salaryAccount - which <code>matti</code> has a reference to - the amount of money on Matti's accounts grows. When money is added to the householdAccount <em>the amount of money each person has grows</em>. This is because both Matti and Maija have "access" to the householdAccount, so in each of the persons' object variable <code>accounts</code>, there's a reference to the householdAccount.</p>


<h3>The structure of a program</h3>

	<p>A program should be clear and easy to understand for both the original writer and others. The most important aspects of a clear program are class structure and good naming conventions. Each class should have a single, clearly defined responsibility. Methods are used to reduce repetition and to create a structure for the internal functionality of the class. A method should also have a clear responsibility to ensure it stays short and simple. Methods that do many things should be divided into smaller helper methods, which are called by the original method. A good programmer writes code that can be understood even weeks after it was originally written.</p>

	<p>Good, understandable code uses descriptive naming of variables, methods and classes, and consistent indentation. Let's look at the example below, a small program for buying and selling goods. Even though the only thing available is carrots, with no bookkeeping, the user interface could be extended to use a storage class to keep track of items.

<pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            } else if (command.equals("buy")) {
                String line = null;
                while(true) {
                    System.out.print("What to buy: ");
                    line = reader.nextLine();
                    if(line.equals("carrot")) {
                        break;
                    } else {
                        System.out.println("Item not found!");
                    }
                }

                System.out.println("Bought!");
            } else if (command.equals("sell")) {
                String line = null;
                while(true) {
                    System.out.print("What to sell: ");
                    line = reader.nextLine();
                    if(line.equals("carrot")) {
                        break;
                    } else {
                        System.out.println("Item not found!");
                    }
                }

                System.out.println("Sold!");
            }
        }
    }
}
</pre>

	<p>This example has numerous problems. The first problem is the long <code>start</code> method. It can be shortened by moving most of the command handling to a separate method.</p>

<pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            } else {
                handleCommand(command);
            }
        }
    }

    public void handleCommand(String command) {
        if (command.equals("buy")) {
            String line = null;
            while(true) {
                System.out.print("What to buy: ");
                line = reader.nextLine();
                if(line.equals("carrot")) {
                    break;
                } else {
                    System.out.println("Item not found!");
                }
            }

            System.out.println("Bought!");
        } else if (command.equals("sell")) {
            String line = null;
            while(true) {
                System.out.print("What to sell: ");
                line = reader.nextLine();
                if(line.equals("carrot")) {
                    break;
                } else {
                    System.out.println("Item not found!");
                }
            }

            System.out.println("Sold!");
        }
    }
}
</pre>

	<p><code>handleCommand</code> still has some repetition for reading the user input. Both buying and selling first print a character string with the question, then take input from the user. If the input is incorrect (other than "carrot"), "Item not found!" is printed. We will create a new method, <code>public String readInput(String question)</code>, to handle this. Note that if the program used some other object to keep track of inventory, we would compare user input to the inventory's contents instead.</p>

<pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            } else {
                handleCommand(command);
            }
        }
    }

    public void handleCommand(String command) {
        if (command.equals("buy")) {
            String input = readInput("What to buy: ");
            System.out.println("Bought!");
        } else if (command.equals("sell")) {
            String input = readInput("What to sell: ");
            System.out.println("Sold!");
        }
    }

    public String readInput(String question) {
        while (true) {
            System.out.print(question);
            String line = reader.nextLine();

            if (line.equals("carrot")) {
                return line;
            } else {
                System.out.println("Item not found!");
            }
        }
    }
}
</pre>

	<p>The program is now divided into appropriate parts. There are still a few things, other than implementing more methods, we can do to improve readability. The <code>start</code> method has an <code>if</code> branch that ends in <code>break</code>, which exits the loop. We can remove the unnecessary <code>else</code> branch, simply moving the <code>handleCommand</code> method to be called after the if statement. The program still works exactly as before, but the method is now shorter and easier to read. A similar situation exists in the <code>readInput</code> method, so we will clean it up too.</p>

<pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            }
            
            handleCommand(command);
        }
    }

    public void handleCommand(String command) {
        if (command.equals("buy")) {
            String input = readInput("What to buy: ");
            System.out.println("Bought!");
        } else if (command.equals("sell")) {
            String input = readInput("What to sell: ");
            System.out.println("Sold!");
        }
    }

    public String readInput(String question) {
        while (true) {
            System.out.print(question);
            String line = reader.nextLine();

            if (line.equals("carrot")) {
                return line;
            }

            System.out.println("Item not found!");
        }
    }
}
</pre>


	<p>Dividing a program into smaller parts, like we did above, is called <em>refactoring</em>. It does not change how the program works, but the internal structure is changed to be more clear and easier to maintain. The current version is much more clear than the original one, but it can be improved further. For example, <code>handleCommand</code> can be further divided into two different methods, one for handling buying and the other for selling.</p>

<pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            }
            
            handleCommand(command);
        }
    }

    public void handleCommand(String command) {
        if (command.equals("buy")) {
            commandBuy();
        } else if (command.equals("sell")) {
            commandSell();
        }
    }

    public void commandBuy() {
        String input = readInput("What to buy: ");
        System.out.println("Bought!");
    }

    public void commandSell() {
        String input = readInput("What to sell: ");
        System.out.println("Sold!");
    }

    public String readInput(String question) {
        while (true) {
            System.out.print(question);
            String line = reader.nextLine();

            if (line.equals("carrot")) {
                return line;
            } else {
                System.out.println("Item not found!");
            }
        }
    }
}
</pre>

	<p>The program now has a clear structure with descriptively named methods. Every method is short and has a small task to handle. Note that refactoring the code did not add any new functionality, it merely changed the way the program works internally.</p>

        <h3>Programming and the importance of practicing</h3>

	<p>As far as we know, nobody has yet learned programming by listening to lectures. To develop the skill required in programming, it is essential to practice both what you have learned earlier and things that are new to you. Programming can be compared to speaking languages or playing an instrument, both of which can only be learned by doing. Master violinists are probably not good at playing <em>only</em> because they practice a lot. Playing an instrument is fun, which makes one more motivated to practice. The same applies to programming.</p>

        <p>As Linus Torvalds said, <em>"Most good programmers do programming not because they expect to get paid or get adulation by the public, but because it is fun to program"</em>.</p>

	<p>Dr. Luukkainen has written a list of instructions for new programmers to follow when learning to program. Follow this advice to become a great programmer!</p>

        <ul>
          <li> Take small steps
            <ul>
	      <li> Divide the problem you are trying to solve into smaller parts and solve them <strong>one at a time</strong> </li>
              <li> Keep testing that your solution is moving in the right direction, ensuring that you have solved the current part correctly</li>
          </ul></li>
          <li> Keep the code as clean as you can
            <ul>
              <li> use proper indentation </li>
              <li> use descriptive names for variables, methods, classes, everything</li>
	      <li> keep all methods short, including <code>main</code> </li>
              <li> write methods that only do one thing </li>
              <li> <strong>remove all copy-paste code by refactoring (or don't copy and paste code in the first place!)</strong></li>
              <li> replace "bad" and unclear code with clean, easy to read code </li>
          </ul></li>
        </ul>



        <h3>Visibility</h3>

	<p>Until now, we have been using two different keywords to define the <em>visibility</em> of methods and instance variables. <code>public</code> makes the method or instance variable visible and accessable to everyone. Methods and constructors are usually marked as public, so that they can be called from outside the class.</p>

	<p>Declaring a method or instance variable <code>private</code> hides it from the outside, making it only accessible from inside the same class.</p>

<pre class="sh_java">
public class Book {
    private String name;
    private String contents;

    public Book(String name, String contents) {
        this.name = name;
        this.contents = contents;
    }

    public String getName() {
        return this.name;
    }

    public String getContents() {
        return this.contents;
    }

    // ...
}
</pre>

	<p>The instance variables in the Book class above can only be accessed with the public methods <code>getName</code> and <code>getContents</code>. Fields declared as private are only accessible in code inside the class. Methods can also be declared as private, which prevents them from being called outside the class.</p>


        <p>Now it's time to start practicing!</p>

<div class="tehtavat" id="viikko7">

<NEXTWEEK></NEXTWEEK>

   <h3>Smileys</h3>

  <p>Create the support method <code>private static void printWithSmileys(String characterString)</code> for the class <code>Smileys</code> which comes with the assignment template. The method is to print the given character string surrounded with smileys. Use the character string <code>:)</code> as the smiley.</p>

<pre class="sh_java">
printWithSmileys("\\:D/");
</pre>

<pre>
:):):):):)
:) \:D/ :)
:):):):):)
</pre>

  <p>Note, that the character string must have \\ so we can print the symbol \.</p>

  <p><em>Note!</em> if the length of the character string is an odd number, add an extra space on the right side of the given character string.</p>

<pre class="sh_java">
printWithSmileys("\\:D/");
printWithSmileys("87.");
</pre>

<pre>
:):):):):)
:) \:D/ :)
:):):):):)
:):):):):)
:) 87.  :)
:):):):):)
</pre>

  <p>It's a good idea to first think how many smileys should be printed for a character string of a certain length. The length of a character string can be found out with the method <code>length</code> which belongs to it. A loop is helpful for printing the top and bottom smiley rows, the middle row can be handled with a normal print command. You can check if a length is an odd number with the help of a remainder <code>characterString.length() % 2 == 1</code>.</p>

<h3>character string changer</h3>

  <p>In this assignment we create a character string changer, which consists of two classes. The class <code>Changer</code> turns a single character to another one. The Changer holds a number of Changes and changes character strings with the help of Change objects it holds.</p>

  <h4>Change-class</h4>

  <p>Create a class <code>Change</code>, that has the following functionalities:</p>

  <ul>
    <li> constructor <code>public Change(char fromCharacter, char toCharacter)</code> that creates an object that makes changes from character <code>fromCharacter</code> to <code>toCharacter</code></li>
    <li> method <code>public String change(String characterString)</code> returns the changed version of the given character string</li>
  </ul>

  <p>The class is used in the following way:</p>

<pre class="sh_java">
  String word = "carrot";
  Change change1 = new Change('a', 'b');
  word = change1.change(word);

  System.out.println(word);

  Change Change2 = new Change('k', 'x');
  word = Change2.change(word);

  System.out.println(word);
</pre>

<p>The example above would print:</p>

<pre>
  porkkbnb
  porxxbnb
</pre>

<p><strong>Tip:</strong> you can handle replacing characters in two ways, either with the help of a method in the class <code>String</code> (look for it yourself!) or by going through the character string character by character while forming the changed character string.</p>

<p>If you don't use the ready-made method of String, it is good to remember that even though you compare character strings with the command <code>equals</code> you compare single characters with the == operator:</p>

<pre class="sh_java">
  String word = "carrot";

  String replacedA = ""; 
  for ( int i=0; i &lt; word.length(); i++) {
     char character = word.charAt(i);
     if ( character == 'a' ) {  
        replacedA += '*'
     }  else {
        replacedA += character;
     } 
  }

  System.out.println(replacedA);  // prints c*rrot
</pre>

<h4>Changer-class</h4>

  <p>Create the class <code>Changer</code>, with the following functions:</p>

  <ul>
    <li> constructor <code>public Changer()</code> creates a new changer</li>
    <li> method <code>public void addChange(Change change)</code> adds a new Change to the Changer</li>
    <li> method <code>public String change(String characterString)</code> executes all added Changes for the character string in the order of their adding and returns the changed character string</li>
  </ul>

  <p>The class is used in the following way:</p>

<pre class="sh_java">
  Changer scandiesAway = new Changer();
  scandiesPois.addChange(new Change('ä', 'a'));
  scandiesPois.addChange(new Change('ö', 'o'));
  System.out.println(scandiesAway.change("ääliö älä lyö, ööliä läikkyy"));
</pre>

  <p>The above example would print:</p>

<pre>
  aalio ala lyo, oolia laikkyy
</pre>

<p><strong>Tip:</strong> It's a good idea to store the Changes to a list object variable of Changer (in the same fashion as on the basics course we stored players to a team, phone numbers to a phone book or books to a library, for example) A Changer is executed so that the changes are done to the character string one at a time as in the following example:</p>

<pre class="sh_java">
    ArrayList&lt;Change&gt; changes = new ArrayList&lt;Change&gt;();

    changes.add( new Change('a', 'b') );
    changes.add( new Change('k', 'x') );
    changes.add( new Change('o', 'å') );

    String word = "carrot";

    for (Change Change : changes) {
        word = Change.change(word);
    }

    System.out.println(word);  // tulostuu pårxxbnb
</pre>

<p><strong>REMINDER</strong> when you add an ArrayList, a Scanner or a Random, Java doesn't recognize the class unless you "import" it by adding the following lines to the beginning:</p>

<pre class="sh_java">
import java.util.ArrayList;    // imports ArrayList
import java.util.*;            // imports all tools from java.util, including ArrayList, Scanner ja Random
</pre>

<h3>Calculator</h3>

  <p>In this assignment, we make a similiar simple calculator that we already had in the material of programming basics' week 1. This time however, we pay attention to the structure of the program. Especially we will make the <em>main</em>-method (the main program) very light. The main program method doesn't actually do anything else than just start the program:</p>

<pre class="sh_java">
public class MainProgram {
    public static void main(String[] args) {
        Calculator calculator = new Calculator();
        calculator.start();
    }
}
</pre>

  <p>What the main program here does is it just creates the object that implements the actual application logic and then starts it. This is the proper way of creating programs and from now on we'll try to achieve this structure.</p>

  <h4>Reader</h4>

  <p>In order to communicate with the user, the calculator needs a Scanner-object. As we've seen, reading integers with a Scanner is a little laborious. We now create a separate class <code>Reader</code> that encapsulates a Scanner-object.</p>

  <p>Implement the class <code>Reader</code> and add the following methods to it</p>

  <ul>
    <li><code>public String readString()</code></li>
    <li><code>public int readInteger()</code></li>
  </ul>

  <p>Within the Reader there should be a Scanner-object as an instance variable, which the methods use in the old familiar way we know from programming basics. Remember that when reading integers, it's good to first read the entire line and then turn that in to an integer. Here we can utilize the method <code>parseInt</code> of the <code>Integer</code>-class.</p>

  <h4>Application body</h4>

  <p>The calculator works like this:</p>

<pre>
command: <font color="red">sum</font>
value1: <font color="red">4</font>
value2: <font color="red">6</font>
sum of the values 10

command: <font color="red">product</font>
value1: <font color="red">3</font>
value2: <font color="red">2</font>
product of the values 6

command: <font color="red">end</font>
</pre>

  <p>Implement the class <code>Calculator</code> to take care of the application logic of your program, and for that class a method <code>public void start()</code> which looks exactly like this:</p>

<pre class="sh_java">
    public void start() {
        while (true) {
            System.out.print("command: ");
            String command = reader.readString();
            if (command.equals("end")) {
                break;
            }

            if (command.equals("sum")) {
                sum();
            } else if (command.equals("difference")) {
                difference();
            } else if (command.equals("product")) {
                product();
            }
        }

        statistics();
    }
</pre>

  <p>The calculator has the operations <code>sum, difference, product</code>.</p>

  <p>Finish the bodies for the methods <code>sum</code>, <code>difference</code>, <code>product</code> and <code>stasistics</code>. All of them are to be of the type <code>private void</code> which means that the methods are available only for internal use in the calculator.</p>

  <p>Add an instance variable of the type <code>Reader</code> for the calculator and create the reader in the constructor. <em>The calculator may not have a separate Scanner-type variable!</em></p>

  <h4>Implementation of the application logic</h4>

  <p>Now implement the methods <code>sum</code>, <code>difference</code> and <code>product</code> so that they work according to the example above. In the example first a command is asked from the user and then two values, then the desired operation is executed and the value of the operation is printed. Notice that asking the user for the values happens within the methods <code>sum</code>, <code>difference</code> and <code>product</code>! The methods use the Reader-object to ask the values, so the body of the methods is as follows:</p>

<pre class="sh_java">
    private void sum() {
       System.out.print("value1: ");   
       int value1 = // read the value using the Reader-object
       System.out.print("value2: "); 
       int value2 = // read the value using the Reader-object
       // print the value according to the example above
    }
</pre>

<h4>Statistics</h4>

  <p>After the <code>while</code>-loop in the <code>start</code>-method, the method <code>statistics</code> is called. The method is meant to print the amount of operations done with the Calculator-object:</p>

<pre>
command: <font color="red">sum</font>
value1: <font color="red">4</font>
value2: <font color="red">6</font>
sum of the values 10

command: <font color="red">product</font>
luku1: <font color="red">3</font>
luku2: <font color="red">2</font>
product of the values 6

command: <font color="red">end</font>
Calculations done 2
</pre>

  <p>Implement the method <code>private void statistics()</code>, and make the required changes to the code of the Calculator-class in order to collect the statistics.</p>

  <p>Note: if an invalid command is given to the program (something other than sum, difference, product or end), the calculator will not react to the command in any way, but instead continues by asking the next command. Statistics is not to count an invalid command as a completed calculation.</p>

<pre>
command: <font color="red">integral</font>
command: <font color="red">difference</font>
value1: <font color="red">3</font>
value2: <font color="red">2</font>
difference of the values 1

command: <font color="red">end</font>
Calculations done 1
</pre>

<p><strong>Bonus assignment (not tested):</strong> Reading the user input is repeated in the same way in all three operation implementing methods. Remove the repetition from your code with the help of a support method. The method can return the two values asked from the user in an array, for example.</p>

</div>


<h2>Primitive- and reference-type variables</h2>

        <p>Java is a strongly typed language, what this means is that all of it's variables have a <em>type</em>. The types of the variables can be divided in to two categories: <strong>primitive-type and reference-type variables</strong>. Both types of variables have their own "slot", which holds the information belonging to them. Primitive-type variables hold the concrete <em>value</em> in their slot, while the reference-type variables hold a <em>reference</em> to a concrete <em>object</em>.</p>

        <h3>Primitive-type variables</h3>

        <p>The value of a primitive type variable is saved in a slot created for the variable. Each primitive-type variable has it's own slot and it's own value. A variable's slot is created when it is introduced (<code>int number;</code>, for example). A value is set to a slot with the assignment operation <code>=</code>. Below is an example of the introduction of a primitive-type int (integer) variable and setting of it's value in the same expression.</p>

<pre class="sh_java">
int number = 42;
</pre>

        <p>Primtive type variables, among others, are <code>int</code>, <code>double</code>, <code>char</code>, <code>boolean</code> and more rarely used <code>short</code>, <code>float</code>, <code>byte</code> and <code>long</code>. Also <code>void</code> is a primitive-type, but it doesn't have it's own slot or value. The void-type is used when we want to express that a method doesn't return a value.</p>

    <p>Next we introduce two primitive-type variables and set values to them.</p>

<pre class="sh_java">
int five = 5;
int six = 6;
</pre>

        <p>The primitive-type variables introduced above are named <code>five</code> and <code>six</code>. When introducing the variable <code>five</code> the value 5 is set to the <em>slot</em> that was created for it (<code>int five = 5;</code>).  When introducing the variable <code>six</code> the value 6 is set to the <em>slot</em> that was created for it (<code>int six = 6;</code>). The variables <code>five</code> and <code>six</code> are both of the type <code>int</code>, or integers.</p>

        <p>Primitive-type variables can be visualized as boxes that both have the values belonging to them saved in to them:</p>

        <p><img src="img-ohja/vis/alkeis-vs-viittaus-vitonen-ja-kutonen.png" /></p>

        <p>Next lets inspect how the values of primitive-type variables get copied.</p>

<pre class="sh_java">
int five = 5;
int six = 6;

five = six; // the variable 'five' now holds the value 6 - the value that was in the variable 'six'.
six = 64; // the variable 'six' now holds the value 64

// the variable 'five' still holds the value 6
</pre>

        <p>Above we introduce the variables <code>five</code> and <code>six</code> and we set values to them. After this the value held in the slot of the variable <code>six</code> is copied to the slot of the variable <code>five</code> (<code>five = six;</code>). If the value of the variable <code>six</code> is changed after this point the value in the variable <code>five</code> remains unaffected: the value of the variable <code>five</code> is in it's own slot and is not related to the value in the slot of the variable <code>six</code> in any way. The end situation as a picture.</p>

        <p><img src="img-ohja/vis/alkeis-vs-viittaus-vitonen-ja-kutonen-64.png" /></p>

        <h4>Primitive type variable as a method parameter and return value</h4>

        <p>When a primitive type variable is passed to a method as a parameter, the method parameter is set to the value in the given variable's slot. In practice, the method parameters also have own slots to which the value is copied like in an assignment expressions. Let us consider the following method <code>addToValue(int value, int amount)</code>.</p>

<pre class="sh_java">
public int addToValue(int value, int amount) {
    return value + amount;
}
</pre>

        <p>The method <code>addToValue</code> is given two parameters: <code>value</code> and <code>amount</code>. The method returns a new value, which is the sum of the given parameters. Let us investigate how the method is called.</p>

<pre class="sh_java">
int myValue = 10;
myValue = addToValue(myValue, 15);
// the variable 'myValue' now holds the value 25
</pre>

        <p>In the example, <code>addToValue</code> is called using the variable <code>myValue</code> and the value <code>15</code>. These are copied to the method parameters <code>value</code>, which will hold the value 10 (the contents of <code>myValue</code>), and <code>amount</code>, which wil hold the value 15. The method returns the sum of <code>value</code> and <code>amount</code>, which is equal to <code>10 + 15 = 25</code>.</p>

        <p>Note! In the previous example, the value of the variable <code>myValue</code> is changed only because it is assigned the return value of <code>addToValue</code> (<code>myValue = addToValue(myValue, 15);</code>). If the call to <code>addToValue</code> were as follows, the value of the variable <code>myValue</code> would remain unchanged.</p>

<pre class="sh_java">
int myValue = 10;
addToValue(myValue, 15);
// the variable 'myValue' still holds the value 10
</pre>

<h4>Minimum and maximum values</h4>

        <p>Each primitive data type can represent a specific range of values limited by its minimum and maximum value, which are the smallest and largest values representible by the type. This is because a predefined data size is used for the internal represetantion of the type in Java (and most other programming languages).</p>

        <p>The minimum and maximum values for a few Java primitive types are:</p>

        <p>
          <table cellspacing="5" >
            <tr><th>Data type</th><th>Description</th><th>Minimum value</th><th>Max value</th></tr>
            <tr><td>int</td><td>Integer</td><td>-2 147 483 648 (<code>Integer.MIN_VALUE</code>)</td><td>2 147 483 647 (<code>Integer.MAX_VALUE</code>)</td></tr>
            <tr><td>long</td><td>Long interger</td><td>-9 223 372 036 854 775 808 (<code>Long.MIN_VALUE</code>)</td><td>9 223 372 036 854 775 807 (<code>Long.MAX_VALUE</code>)</td></tr>
            <tr><td>boolean</td><td>Truth value</td><td colspan=2><code>true</code> or <code>false</code></td></tr>
            <tr><td>double</td><td>Floating point</td><td><code>Double.MIN_VALUE</code></td><td><code>Double.MAX_VALUE</code></td></tr>
          </table>
        </p>

        <p><strong>Rounding errors</strong></p>

        <p>When using floating point data types, it is important to keep in mind that floating point types are always an <em>approximation</em> of the actual value. Because floating point types use a predefined data size to represent the value similarly to all other primitive data types, we may observe quite surprising rounding errors. For example, consider the following case.</p>

<pre class="sh_java">
double a = 0.39;
double b = 0.35;
System.out.println(a - b);
</pre>

        <p>The example prints the value <code>0.040000000000000036</code>. Programming languages usually include tools to more accurately handle floating point numbers. In Java, for example, the class <em>BigDecimal</em> can be used to store infinitely long floating point numbers.</p>

        <p>When comparing floating point numbers, rounding errors are usually taken into account by comparing the distance between the values. For example, with the variables in the previous example, the expression <code>a - b == 0.04</code> does not produce the expected result due to a rounding error.</p>

<pre class="sh_java">
double a = 0.39;
double b = 0.35;

if((a - b) == 0.04) {
    System.out.println("Successful comparison!");
} else {
    System.out.println("Failed comparison!");
}
</pre>

<pre>
Failed comparison!
</pre>

        <p>One method to calculate the distance between two values is as follows. The helper function <code>Math.abs</code> returns the absolute value of the value passed to it.</p>

<pre class="sh_java">
double a = 0.39;
double b = 0.35;

double distance = 0.04 - (a - b);

if(Math.abs(distance) &lt; 0.0001) {
    System.out.println("Successful comparison!");
} else {
    System.out.println("Failed comparison!");
}
</pre>

<h3>Reference-Type Variables</h3>

        <p>Reference-type variables memorize the information which has been assigned to them "on the other end of the line". Reference-type variables contain a reference to the location where the information is stored. Differently from primitive-type variables, reference-type variable do not have a limited scope because their value or <em>information</em> is stored at the referenced location. Another substantial difference between primitive-type and reference-type variables is that various different reference-type variables can point to the same object.</p>

<!--
        <p>Reference-type variables are objects which are created through the <code>new</code> keyword. The value of a reference-type variable is still assigned using the operator <code>=</code>; however, the <code>new</code> operator creates an object and returns the reference to that object. The reference is stored within the variable, and it becomes its value.</p> 
-->

<p>Let us have a look at two reference-type variables. In the following examples we make use of the class <em>Calculator</em>:</p>

<pre class="sh_java">
public class Calculator {
    private int value;

    public Laskuri(int originalValue) { // Contructor
        this.value = originalValue;
    }

    public void increaseValue() {
        this.value = this.value + 1;
    }

    public int getValue() {
        return value;
   }
}
</pre>

        <p>Main:</p>

<pre class="sh_java">
Calculator bonusCalculator = new Calculator(5);
Calculator axeCalculator = new Calculator(6);
</pre>

        <p>In the examples we first create a reference-type variable called <code>bonusCalculator</code>. The <code>new</code> operator tells that we define storage space for the information to be assigned to the variable, then we execute the code which follows the <code>new</code> operator, and we return a referece to the object that has been so created. The reference which is returned is assigned to the <code>bonusCalculator</code> variable through the <code>=</code> equal sign. The same thing happens with the variable called <code>axeCalculator</code>. If we want to think about it with pictures, we can imagine a reference-type variable as it were a box, the variable itself, with a line or an arrow, which starts at the box and points to an object. In fact, the variable does not contain the object, but it points to the object information. </p>

        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit.png" /></p>

        <p>Next, let us have a look at how a referene-type object is duplicated.</p>

<pre class="sh_java">
Calculator bonusCalculator = new Calculator(5);
Calculator axeCalculator = new Calculator(6);

bonusCalculator = axeCalculator; // the reference contained by the variable axeCalculator is copied to the variable bonusCalculator
                           // that is to say a reference to a Calculator-type object which received the value 6 in its constructor is copied to the variable  bonusCalculator
</pre>

        <p>When we copy a reference-type variable (see above <code>bonusCalculator =  axeCalculator;</code>), the reference to the variable duplicates, too. In this case, a reference to the <code>axeCalculator</code> variable slot is copied to the <code>bonusCalculator</code> variable slot. Now, both the objects point to the same place!</p>

        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-3.png" /></p>

        <p>Let us continue with the example above and let us set a new reference to the variable <code>axeCalculator</code>; this new reference will point to a new object created by the command <code>new Calculator(10)</code>.</p>

<pre class="sh_java">
Calculator bonusCalculator = new Calculator(5);
Calculator axeCalculator = new Calculator(6);

bonusCalculator = axeCalculator; // the reference contained by the variable axeCalculator is copied to the variable bonusCalculator
                           // that is to say a reference to a Calculator-type object which received the value 6 in its constructor is copied to the variable 

axeCalculator = new Calculator(10); // a new reference is assigned to the axeCalculator variable 
                              // which points to the object created by the command new Laskuri(10)

// the bonusCalculator variable still contains a reference to the Calculator object which received value 6 in its parameter
</pre>

        <p>In these examples, we do the same operations which were shown in the assignment example in the primitive-type variables section. In the very last example, we copied the reference of reference-type variables, whereas in the primitive-type variables section we copied the value of primitive-type variables. In both cases, we copy the contents of a slot: the primitive-type variable slot contains a value, whereas the reference-type variable slot contains a reference.</p>

        <p>At the end of the previous example no variable points to the Calculator object which received value 5 in its constructor. Java's garbage collection deletes such useless objects from time to time. Our final situation looks like the following:</p>


        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-2.png" /></p>

        <p>Let us have a look to a third example still, and let us focus on an essencial difference between primitive-type and reference-type variables.</p>

<pre class="sh_java">
Calculator bonusCalculator = new Calculator(5);
Calculator axeCalculator = new Calculator(6);

bonusCalculator = axeCalculator; // the reference contained by the variable axeCalculator is copied to the variable bonusCalculator
                           // that is to say a reference to a Calculator-type object which received the value 6 in its constructor is copied to the variable 

axeCalculator.increaseValue(); // we increase by one the value of the object referenced by axeCalculator

System.out.println(bonusCalculator.getValue());
System.out.println(axeCalculator.getValue());
</pre>

<pre>
7
7
</pre>

        <p>Both <code>bonusCalculator</code>and <code>axeCalculator</code> point to the same object, after we have run the command <code>bonusCalculator = axeCalculator;</code>, and therefore, now they both have the same value 7, even though we have increased only one of them.</p>

        <p>The situation might be clear if we look at the following picture. The method <code>axeCalculator.increaseValue()</code> increases by one the <code>value</code> variable of the object pointing to the <code>axeCalculator</code> variable. Because <code>bonusCalculator</code> points to the same object, the method <code>bonusCalculator.getValue()</code> returns the same value which was increased by the method <code>axeCalculator.increaseValue()</code>.</p>

        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-4.png" /></p>

        <p>In the following example, three reference-type variables all point to the same <code>Calculator</code> object.</p>

<pre class="sh_java">
Calculator bonus = new Calculator(5);
Calculator ihq = bonus;
Calculator lennon = bonus;
</pre>

        <p>In the example, we create only one <code>Calculator</code> object, but all the three <code>Calculator</code> variables point to that same one. Therefore, <code>bonus</code>, <code>ihq</code>, and <code>lennon</code> method calls all modify the same object. To tell it once again: when reference-type variables are copied, their references also duplicate. The same concept in a picture:</p>


        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-5.png" /></p>

        <p>Let us focus again on duplication with one example.</p>

<pre class="sh_java">
Calculator bonus = new Calculator(5);
Calculator ihq = bonus;
Calculator lennon = bonus;

lennon = new Calculator(3);
</pre>

        <p>The modification of the <code>lennon</code> variable contents – that is to say the change of reference – does not affect the references of either <code>bonus</code> or <code>ihq</code>. Always when we assign a value to a variable, we change the contents of only that variable's own slot. The same concept in a picture:</p>

        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-6.png" /></p>

        <h4>A Reference-Type Variables and Method Parameters</h4>

        <p>When a reference-type variable is given to a method as its parameter, we create a method parameter which is the copy of the reference of a variable. In other words, we copy the reference to the parameter's own slot. Differently from what happens with original-type variables, we copy the reference, and not their value. In fact, we can we can modify the object behind the reference even form within the method. Let us take the method <code>public void addToCalculator(Calculator calculator, int amount)</code>.</p>

<pre class="sh_java">
public void addToCalculator(Calculator calculator, int amount) {
    for (int i = 0; i &lt; amount; i++) {
        calculator.increaseValue();
    }
}
</pre>

        <p>We give two parameters to the method <code>addToCalculator</code> – a reference-type value and an original-type variable. The contents of both variable slots are copied to method parameter slots. The reference-type parameter <code>calculator</code> receives a copy of a reference, whereas the original-type parameter <code>amount</code> receives the copy of value. The method will call the <code>increaseValue()</code> method of the <code>Calculator</code>-type parameter, and it will do it as many times as the value of the <code>amount</code> variable. Let us analise the method call more deeply.</p>

<pre class="sh_java">
int times = 10;

Calculator bonus = new Calculator(10);
addToCalculator(bonus, times);
// the bonus variable value is now 20
</pre>

        <p>In the example, we call the <code>addToCalculator</code> method whose given variables are <code>bonus</code> and <code>times</code>. This means that the reference of the reference-type variable <code>bonus</code> and the value of the original-type variable <code>times</code> – which is <code>10</code> – are copied as parameters whose names are <code>calculator</code> and <code>amount</code>, respectively. The method executes the <code>increaseValue()</code> method of the <code>calculator</code> variable a number of times which equals the value of <code>amount</code>. See the following picture:</p>


        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-7.png" /></p>

        <p><em>The method contains variables which are completely separated from the main program!</em></p>

        <p>As far as the reference-type variable is concerned, a reference duplicates and it is given to the method, and the variable inside the method will still point to the same object. As far as the original-type variable is concerned, a value is copied, and the variable inside the method will have its completely independent value.</p>

        <p>The method recognises the calculator which the <code>bonus</code> variable points to, and the alterations made by the method have a direct impact on the object. The situation is different with original-type variables, and the method only receives a copy of the value of the <code>times</code> variable. In fact, it is not possible to modify the value of original-type variables directly within a method.</p>

        <h4>A method which returns a reference-type variable</h4>

        <p>When a method returns a reference-type variable, it returns the reference to an object located elsewhere. Once the reference is returned by a method, it can be assigned to a variable in the same way as a normal assignment would happen, through the equal sign (=). Let us have a look at the method <code>public Calculator createCalculator(int startValue)</code>, which creates a new reference-type variable.</p>

<pre class="sh_java">
public Calculator createCalculator(int startValue) {
    return new Calculator(startValue);
}
</pre>

    <p>The creteCalculator method creates an object and returns its <code>newCalculator</code> reference. By calling the method, we always create a new object. In the following example we create two different <code>Calculator</code>-type objects.</p>

<pre class="sh_java">
Calculator bonus  = createCalculator(10);
Calculator lennon = createCalculator(10);
</pre>

        <p>The method <code>createCalculator</code> always creates a new <code>Calculator</code>-type object. With the first call, <code>Calculator bonus  = createCalculator(10);</code> we assign the method return reference to the <code>bonus</code> variable. With the second call, we create another reference and we assign it to the <code>lennon</code> variable. The variables <code>bonus</code> and <code>lennon</code> do not contain the same reference because the method creates a new object in both cases, and it returns the reference to that particular object.</p>


        <h2 id="stat_ja_ei">Static and Non-Static</h2>


        <p>Let us go back to a topic which we introduced in the 30th section of Introduction to Programming, and let us go deeper into into. The static or non-static nature of a variable or of a method depends on their scope. Static methods are always related to their class, whereas non-static methods can modify the variables of the object itself.</p>

        <h3>Static, Class Libraries and Final</h3>

        <p>The methods which receive the definition static are not related to objects but to classes. it is possible to define class-specific variables by adding the word <code>static</code> to their name. For instance, <code>Integer.MAX_VALUE</code>, <code>Long.MIN_VALUE</code> and <code>Double.MAX_VALUE</code> are all static methods. Static methods are called via their class name, for instance <code>ClassName.variable</code> or <code>ClassName.method()</code>.</p>

        <p>We call class library that class which contains common-use methods and variables. For instance, Java <code>Math</code> class is a class library. It provides the <code>Math.PI</code> variable, inter alia. Often, creating your own class libraries can prove useful. Helsinki Regional Transport Authority (Finnish: Helsingin Seudun Liikenne, HSL) could use a class library to keep its ticket prices at its fingertips.</p>

<pre class="sh_java">
public class HslPrices {
    public static final double SINGLETICKET_AUDULT = 2.50;
    public static final double TRAMTICKET_AUDULT = 2.50;
}
</pre>

        <p>The keyword <code>final</code> in the variable definition tells that once we assign a value to a variable, we can not assign a new one to it. Final-type variables are constant, and they always have to have a value. For instance, the class variable which tells the greatest integer, <code>Integer.MAX_VALUE</code>, is a constant class variable.</p>

        <p>Once we have the class presented above, <code>HslPrices</code>, all the programs which need the single or tram-ticket price can have access to it through the class <code>HslPrices</code>. With the next example, we present the class <code>Person</code>, which has the method <code>enoughMoneyForSingleTicket()</code>, which makes use of the ticket price found in the class <code>HslPrices</code>.</p>

<pre class="sh_java">
public class Person {
    private String name;
    private double money;
    // more object variables

    // constructor

    public boolean enoughMoneyForSingleTicket() {
        if(this.rahat >= HslPrices.SINGLETICKET_AUDULT) {
            return true;
        }

        return false;
    }

    // the other methods regarding the class Person
}
</pre>

<p>The method <code>public boolean enoughMoneyForSingleTicket()</code> compares the object variable <code>money</code> of class <code>Person</code> to the static variable <code>SINGLETICKET_AUDULT</code> of class <code>HslPrices</code>. The method <code>enoughMoneyForSingleTicket()</code> can be called only through an object reference. For instance:</p>

<pre class="sh_java">
Person matti = new Person();

if (matti.enoughMoneyForSingleTicket()) {
    System.out.println("I'll buy a ticket.");
} else {
    System.out.println("Fare dodging, yeah!");
}
</pre>

<p>Note the naming convention! All <em>constants</em>, i.e. all variable which are provided with the definition final, are written with CAPITAL_LETTERS_AND_UNDERLINE_CHARACTERS.</p> 

<p>Static methods function analogously. For instance, the class <code>HslPrices</code> could <em>encapsulate</em> the variables and only provide <em>accessors</em>. We call accessors the methods which allow us to either read a variable value or to assign them a new one.</p>

<pre class="sh_java">
public class HslPrices {
    public static final double SINGLETICKET_AUDULT = 2.50;
    public static final double TRAMTICKET_AUDULT = 2.50;

  public static double getSingleTicketPrice() {   // Accessor
    return SINGLETICKET_AUDULT;
  }

  public static double getTramTicketPrice() {   // Accessor
    return TRAMTICKET_AUDULT;
  }
}
</pre>

<p>In such cases, when we code a class such as <code>Person</code>, we can't call the variable straight, but we have to get it through the method <code>getSingleTicketPrice()</code>.</p>

<pre class="sh_java">
public class Peson {
    private String name;
    private double money;
    // other object variables

    // constructor

    public boolean enoughMoneyForSingleTicket() {
        if(this.money >= HslPrices.giveSingleTicketPrice()) {
            return true;
        }

        return false;
    }

    // other methods regarding the class Person
}
</pre>


<p>Even though Java allows for static variable use, we do not usually require it. Often, using static methods causes problems with the program structure, because static variables are as inconvenient as <a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad">global variables</a>. <b>The only static variables we use in this course are constant, i.e. final!</b></p>

    <h3>Non-Static</h3>

    <p>Non-static methods and variables are related to objects. The object variables, or attributes, are defined at the beginning of the class. When an object is created with the <code>new</code> operator, we allocate storage space for all its object variables. The variable values are personal of the object, which means that every object receives personal variable values. Let us focus again on the class <code>Person</code>, which has got the object variable <code>name</code> and <code>money</code>.</p>

<pre class="sh_java">
public class Person {
  private String name;
  private double money;

  // other details
}
</pre>

    <p>When we create a new instance of class <em>Person</em>, we also initialize its variables. If we do not initialize the reference-type variable <code>name</code>, it receives value <em>null</em>. Let us add the <em>constructor</em> and a couple of methods to our class <em>Person</em>.</p>

<pre class="sh_java">
public class Person {
  private String name;
  private double money;

    // constructor
    public Person(String name, double money) {
        this.name = name;
        this.money = money;
    }

    public String getName() {
        return this.name;
    }

    public double getMoney() {
        return this.money;
    }

    public void addMoney(double amount) {
        if(amount &gt; 0) {
          this.money += amount;
        }
    }

    public boolean enoughMoneyForSigleTicket() {
        if(this.money >= HslPrices.getSingleTicketPrice()) {
            return true;
        }

        return false;
    }
}
</pre>

    <p>The constructor <code>Person(String name, double money)</code> creates a new Person object, and it returns its reference. The method <code>getName()</code> returns the reference to a <code>name</code> object, and the <code>getMoney()</code> method returs the original-type variable <code>money</code>. The method <code>addMoney(double amount)</code> receives as parameter an amount of money, and it adds it to the <code>money</code> object variable if the parameter's value is greater than 0.</p>

    <p>Object methods are called through their object reference. The following code example creates a new Person object, increases its money, and prints its name, at the end. Note that the method calls follow the pattern <code>objectName.methodName()</code></p>

<pre class="sh_java">
Person matti = new Person("Matti", 5.0);
matti.addMoney(5); 

if (matti.enoughMoneyForSingleTicket()) {
    System.out.println("I'll buy a single ticket.");
} else {
    System.out.println("Fare dodging, yeah!");
}
</pre>

    <p>The example prints "<code>I'll buy a single ticket.</code>"</p>

    <h4>Class Methods</h4>

    <p>Non-static class methods can be also called without specifing the object affix which indicates the class. In the following example, the <code>toString()</code> method points to the class <code>Person</code>, which calls the object method <code>getName()</code>.</p>

<pre class="sh_java">
public class Person {
    // earlier written content

    public String toString() {
        return this.getName();
    }
}
</pre>

    <p>The <code>toString()</code> method calls the class method <code>getName()</code>, which belongs to the object in question. The <code>this</code> affix emphasize that the calls precisely refers to this object.</p>

    <p>Non-static methods can also call static methods, that is the class-specific ones. On the other hand, static methods can not call non-static methods without a reference to the object itself, which is essential to retrive the object information.</p>


    <h4>A Variable within a Method</h4>

    <p>The variables which are defined inside a method are auxiliary variables used during the method execution, and they are not to be confused with object variables. The example below shows how a local variable is created inside a method. The <code>index</code> variable exists and is accessible only during the method execution.</p>

<pre class="sh_java">
public class ... {
    ...

    public static void printTable(String[] table) {
        int index = 0;

        while(index &lt; table.length) {
            System.out.println(table[index]);
            index++;
        }
    }
}
</pre>

    <p>In the <code>printTable()</code> method, we create the auxiliary variable <code>index</code> which we use to parse the table. The variable <code>index</code> exists only during the method execution.</p>


<div class="tehtavat">
  <h3>Tavara, Matkalaukku ja Lastiruuma</h3>

  <p>Tässä tehtäväsarjassa tehdään luokat <code>Tavara</code>, <code>Matkalaukku</code> ja <code>Lastiruuma</code>, joiden avulla harjoitellaan olioita, jotka sisältävät toisia olioita.</p>

  <h4 class="req">Tavara-luokka</h4>

  <p>Tee luokka <code>Tavara</code>, josta muodostetut oliot vastaavat erilaisia tavaroita. Tallennettavat tiedot ovat tavaran nimi ja paino (kg).</p>

  <p>Lisää luokkaan seuraavat metodit:</p>

  <ul>
    <li>Konstruktori, jolle annetaan parametrina tavaran nimi ja paino</li>
    <li>Metodi <code>public String getName()</code>, joka palauttaa tavaran nimen</li>
    <li>Metodi <code>public int getPaino()</code>, joka palauttaa tavaran painon</li>
    <li>Metodi <code>public String toString()</code>, joka palauttaa characterStringn muotoa "nimi (paino kg)"</li>
  </ul>

  <p>Seuraavassa on luokan käyttöesimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);

        System.out.println("Bookn nimi: " + kirja.getName());
        System.out.println("Bookn paino: " + kirja.getPaino());

        System.out.println("Book: " + kirja);
        System.out.println("Puhelin: " + puhelin);
    }
}
</pre>

<p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
Bookn nimi: Aapiskukko
Bookn paino: 2
Book: Aapiskukko (2 kg)
Puhelin: Nokia 3210 (1 kg)
</pre>

<h4 class="req">Matkalaukku-luokka</h4>

  <p>Tee luokka <code>Matkalaukku</code>. Matkalaukkuun liittyy tavaroita ja maksimipaino, joka määrittelee tavaroiden suurimman mahdollisen yhteispainon.</p>

  <p>Lisää luokkaan seuraavat metodit:</p>

  <ul>
    <li> Konstruktori, jolle annetaan maksimipaino</li>
    <li> Metodi <code>public void lisaaTavara(Tavara tavara)</code>, joka lisää parametrina annettavan tavaran matkalaukkuun. Metodi ei palauta mitään arvoa.</li>
    <li> Metodi <code>public String toString()</code>, joka palauttaa characterStringn muotoa "x tavaraa (y kg)"</li>
  </ul>

  <p>Tavarat kannattaa tallentaa <code>ArrayList</code>-olioon:</p>

<pre class="sh_java">
ArrayList&lt;Tavara&gt; tavarat = new ArrayList&lt;Tavara&gt;();
</pre>

  <p>Luokan <code>Matkalaukku</code> tulee valvoa, että sen sisältämien tavaroiden yhteispaino ei ylitä maksimipainoa. Jos maksimipaino ylittyisi lisättävän tavaran vuoksi, metodi <code>lisaaTavara</code> ei saa lisätä uutta tavaraa laukkuun.</p>

  <p>Seuraavassa on luokan käyttöesimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

        Matkalaukku matkalaukku = new Matkalaukku(5);
        System.out.println(matkalaukku);

        matkalaukku.lisaaTavara(kirja);
        System.out.println(matkalaukku);

        matkalaukku.lisaaTavara(puhelin);
        System.out.println(matkalaukku);

        matkalaukku.lisaaTavara(tiiliskivi);
        System.out.println(matkalaukku);
    }
}
</pre>

  <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
0 tavaraa (0 kg)
1 tavaraa (2 kg)
2 tavaraa (3 kg)
2 tavaraa (3 kg)
</pre>

  <h4>Kielenhuoltoa</h4>

  <p>Ilmoitukset "0 tavaraa" ja "1 tavaraa" eivät ole kovin hyvää suomea &ndash; paremmat muodot olisivat "ei tavaroita" ja "1 tavara". Tee tämä muutos luokkaan <code>Matkalaukku</code>.</p>

  <p>Nyt edellisen ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
ei tavaroita (0 kg)
1 tavara (2 kg)
2 tavaraa (3 kg)
2 tavaraa (3 kg)
</pre>

<h4 class="req">Kaikki tavarat</h4>

<p>Lisää luokkaan <code>Matkalaukku</code> seuraavat metodit:</p>

<ul>
  <li> metodi <code>tulostaTavarat</code>, joka tulostaa kaikki matkalaukussa olevat tavarat</li>
  <li> metodi <code>yhteispaino</code>, joka palauttaa tavaroiden yhteispainon</li>
</ul>

<p>Seuraavassa on luokan käyttöesimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

        Matkalaukku matkalaukku = new Matkalaukku(10);
        matkalaukku.lisaaTavara(kirja);
        matkalaukku.lisaaTavara(puhelin);
        matkalaukku.lisaaTavara(tiiliskivi);

        System.out.println("Matkalaukussa on seuraavat tavarat:");
        matkalaukku.tulostaTavarat();
        System.out.println("Yhteispaino: " + matkalaukku.yhteispaino() + " kg");
    }
}
</pre>

  <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
Matkalaukussa on seuraavat tavarat:
Aapiskukko (2 kg)
Nokia 3210 (1 kg)
Tiiliskivi (4 kg)
Yhteispaino: 7 kg
</pre>


  <p>Muokkaa myös luokkaasi siten, että käytät vain kahta oliomuuttujaa. Toinen sisältää maksimipainon, toinen on lista laukussa olevista tavaroista.</p>

<h4 class="req">Raskain tavara</h4>

  <p>Lisää vielä luokkaan <code>Matkalaukku</code> metodi <code>raskainTavara</code>, joka palauttaa painoltaan suurimman tavaran. Jos yhtä raskaita tavaroita on useita, metodi voi palauttaa minkä tahansa niistä. Metodin tulee palauttaa olioviite. Jos laukku on tyhjä, palauta arvo <em>null</em>.</p>

  <p>Seuraavassa on luokan käyttöesimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("Tiiliskivi", 4);

        Matkalaukku matkalaukku = new Matkalaukku(10);
        matkalaukku.lisaaTavara(kirja);
        matkalaukku.lisaaTavara(puhelin);
        matkalaukku.lisaaTavara(tiiliskivi);

        Tavara raskain = matkalaukku.raskainTavara();
        System.out.println("Raskain tavara: " + raskain);
    }
}
</pre>

  <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
Raskain tavara: Tiiliskivi (4 kg)
</pre>

<h4 class="req">Lastiruuma-luokka</h4>

  <p>Tee luokka <code>Lastiruuma</code>, johon liittyvät seuraavat metodit:</p>

  <ul>
    <li> konstruktori, jolle annetaan maksimipaino</li>
    <li> metodi <code>public void lisaaMatkalaukku(Matkalaukku laukku)</code>, joka lisää parametrina annetun matkalaukun lastiruumaan</li>
    <li> metodi <code>public String toString()</code>, joka palauttaa characterStringn muotoa "x matkalaukkua (y kg)"</li>
  </ul>

  <p>Tallenna matkalaukut sopivaan <code>ArrayList</code>-rakenteeseen.</p>

  <p>Luokan <code>Lastiruuma</code> tulee valvoa, että sen sisältämien matkalaukkujen yhteispaino ei ylitä maksimipainoa. Jos maksimipaino ylittyisi uuden matkalaukun vuoksi, metodi <code>lisaaMatkalaukku</code> ei saa lisätä uutta matkalaukkua.</p>

<p>Seuraavassa on luokan käyttöesimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

        Matkalaukku matinLaukku = new Matkalaukku(10);
        matinLaukku.lisaaTavara(kirja);
        matinLaukku.lisaaTavara(puhelin);

        Matkalaukku pekanLaukku = new Matkalaukku(10);
        pekanLaukku.lisaaTavara(tiiliskivi);

        Lastiruuma lastiruuma = new Lastiruuma(1000);
        lastiruuma.lisaaMatkalaukku(matinLaukku);
        lastiruuma.lisaaMatkalaukku(pekanLaukku);

        System.out.println(lastiruuma);
    }
}
</pre>

  <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
2 matkalaukkua (7 kg)
</pre>

<h4 class="req">Lastiruuman sisältö</h4>

  <p>Lisää luokkaan <code>Lastiruuma</code> metodi <code>public void tulostaTavarat()</code>, joka tulostaa kaikki lastiruuman matkalaukuissa olevat tavarat.</p>

<p>Seuraavassa on luokan käyttöesimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

        Matkalaukku matinLaukku = new Matkalaukku(10);
        matinLaukku.lisaaTavara(kirja);
        matinLaukku.lisaaTavara(puhelin);

        Matkalaukku pekanLaukku = new Matkalaukku(10);
        pekanLaukku.lisaaTavara(tiiliskivi);

        Lastiruuma lastiruuma = new Lastiruuma(1000);
        lastiruuma.lisaaMatkalaukku(matinLaukku);
        lastiruuma.lisaaMatkalaukku(pekanLaukku);

        System.out.println("Ruuman matkalaukuissa on seuraavat tavarat:");
        lastiruuma.tulostaTavarat();
    }
}
</pre>

<p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
Ruuman matkalaukuissa on seuraavat tavarat:
Aapiskukko (2 kg)
Nokia 3210 (1 kg)
tiiliskivi (4 kg)
</pre>

<h4>Paljon tiiliskiviä</h4>

  <p>Testataan vielä, että lastiruuman toiminta on oikea eikä maksimipaino pääse ylittymään. Tee Main-luokkaan metodi <code>public static void lisaaMatkalaukutTiiliskivilla(Lastiruuma lastiruuma)</code>, joka lisää parametrina annettuun lastiruumaan 100 matkalaukkua, joissa jokaisessa on yksi tiiliskivi. Tiiliskivien painot ovat 1, 2, 3, ..., 100 kg.</p>

  <p>Ohjelman runko on seuraava:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Lastiruuma lastiruuma = new Lastiruuma(1000);
        lisaaMatkalaukutTiiliskivilla(lastiruuma);
        System.out.println(lastiruuma);
    }

    public static void lisaaMatkalaukutTiiliskivilla(Lastiruuma lastiruuma) {
        // 100 matkalaukun lisääminen, jokaiseen tulee tiiliskivi
    }
}
</pre>

  <p>Ohjelman tulostus on seuraava:</p>

<pre>
44 matkalaukkua (990 kg)
</pre>

</div>

    <h2 id="hashmap">HashMap</h2>

    <p><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html">HashMap</a> is one of Java's most useful data structures. The idea behind HashMap is we define an index for an object key - a unique value, as for instance a social number, a student number, or a phone number. We call <em>hashing</em> the process of changing a key into an index, or simply to define an index. The hashing happens thanks to a particular function which makes sure that we get always the same index with a known key.</p>

    <p>Adding and retriving items based on the keys, allows for a particularly quick search process. Instead of parsing the table items one by one (in the worst case we would have to go through all the items), and instead of looking for a value with a binar search (in which case we would have to go through a number of items which would depend on the logarithm of the table size), we can look at only one table index and check whether a value is mapped to that index.</p>

    <p>HashMap uses the <code>Object</code> class <code>hashCode()</code> method to find a key value. Every HashMap subclass will <em>inherit</em> the <code>hashCode()</code> method. However, we will not go deep into HasMap workings in this course. We will return to heritage in week 4.</p>


    <p>Java's <code>HashMap</code> class capsulates - or hides - the way it works, and it returns made-up methods ready to use.</p>

    <p>When we create a HashMap we need two <em>type parameters</em>, a type for the key variable, and a type for the stored object. The following example uses a <code>String</code>-type object as key, and a <code>String</code>-type object as the stored object.</p>


<pre class="sh_java">
HashMap&lt;String, String&gt; numbers = new HashMap&lt;String, String&gt;();
numbers.put("One", "Yksi");
numbers.put("Two", "Kaksi");

String translation = numbers.get("One");
System.out.println(translation);

System.out.println(numbers.get("Two"));
System.out.println(numbers.get("Three"));
System.out.println(numbers.get("Yksi"));
</pre>

<pre>
Yksi
Kaksi
null
null
</pre>


    <p>In the example, we create a HashMap which both the key and the stored object are strings. We add information to the HashMap with the <code>put()</code> method, which receives the references to the key and to the stored object as parameter. The method <code>get()</code> returns either the reference to the key given as parameter or a <code>null</code> value in case the key was not found.</p>

    <p>Each key is mapped to one value, within the HashMap. If we store a new value with an already existing key, the old value is lost.</p>

<pre class="sh_java">
HashMap&lt;String, String&gt; numbers = new HashMap&lt;String, String&gt;();
numbers.put("One", "Yksi");
numbers.put("Two", "Kaksi");
numbers.put("One", "Uno");

String translation = numbers.get("One");
System.out.println(translation);

System.out.println(numbers.get("Two"));
System.out.println(numbers.get("Three"));
System.out.println(numbers.get("Yksi"));
</pre>

    <p>Because the key "<code>Yksi</code>" is assigned a new value, the print output of the example is like the following.</p>

<pre>
Uno
Kaksi
null
null
</pre>

<div class="tehtavat">

  <h3>Lempinimet</h3>

  <p>Luo <code>main</code>-metodissa
  uusi <code>HashMap&lt;String,String&gt;</code>-olio. Tallenna tähän
  HashMappiin seuraavien henkilöiden nimet ja lempinimet niin, että
  nimi on avain ja lempinimi on arvo. Käytä pelkkiä pieniä kirjaimia.</p>

  <ul>
    <li>matin lempinimi on mage</li>
    <li>mikaelin lempinimi on mixu</li>
    <li>arton lempinimi on arppa</li>
  </ul>

  <p>Tämän jälkeen hae HashMapistä mikaelin lempinimi ja tulosta se.</p>

<p>Testit edellyttävät että kirjoitat nimet pienellä alkukirjaimella.</p>

</div>

        <h3 id="kirjastotietokanta">Book Search through HashMap</h3>

        <p>Let us go deeper into HashMap workings with the help of the following example. Books can be retrived based on their name, which acts as book key. If we find a book for the given name, we obtain the respective reference, as well as the book details. Let us create the example class <code>Book</code>, which has a name and the book contents as object variables.</p>

<pre class="sh_java">
public class Book {
    private String name;
    private String contents;
    private int publishingYear;

    public Book(String name, int publishingYear, String contents) {
        this.name = name;
        this.publishingYear = publishingYear;
        this.contents = contents;
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    public void setPublishingYear(int publishingYear) {
        this.publishingYear = publishingYear;
    }

    public String getContents() {
        return this.contents;
    }

    public void setContents(String contents) {
        this.contents = contents;
    }

    public String toString() {
        return "Nimi: " + this.name + " (" + this.publishingYear + ")\n"
                + "Contents: " + this.contents;
    }
}
</pre>

        <p>In the following example, we create a HashMap which makes use of the book name - a String-type object - and stores the references which point to <code>Book</code>-objects.</p>

<pre class="sh_java">
HashMap&lt;String, Book&gt; bookCollection = new HashMap&lt;String, Book&gt;();
</pre>

    <p>The HashMap above has a <code>String</code> object as key. Let us extend our example so that we would add two books to our book collection, <code>"Sense and Sensibility"</code> and <code>"Pride and Prejudice"</code>.</p>

<pre class="sh_java">
Book senseAndSensibility = new Book("Sense and Sensibility", 1811, "...");
Book prideAndPrejudice = new Book("Pride and Prejudice", 1813, "....");

HashMap&lt;String, Book&gt; bookCollection = new HashMap&lt;String, Book&gt;();
bookCollection.put(senseAndSensibility.getName(), senseAndSensibility);
librabookCollectionry.put(prideAndPrejudice.getName(), prideAndPrejudice);
</pre>

        <p>Books can be retrived from the book collection based on their name. A search for the book <code>"Persuasion"</code> does not return a corresponding entry, in which case the HashMap returns a <code>null</code> reference. However, the book "Pride and Prejudice" was found.</p>

<pre class="sh_java">
Book book = bookCollection.get("Persuasion");
System.out.println(book);
System.out.println();
book = bookCollection.get("Pride and Prejudice");
System.out.println(book);
</pre>

<pre>
null

Name: Pride and Prejudice (1813)
Contents: ...
</pre>

    <p>HashMaps are useful when we know the key to use for our search. Keys are always unique, and it is not possible to store more than one object together with one key alone. The object which we store can still be a list or another HashMap, of course!</p>

    <h3 id="kapseloitu_kirjasto">Library</h3>

    <p>The problem with the book collection above is that we must remember the correct book name when we search for it, character by character. Java built-in <code>String</code> class provides us the tools for this. The <code>toLowerCase()</code> method turns a string's characters to lower case, and the <code>trim()</code> method deletes the white spaces at the beginning and at the end of the string. Computer users tend to write white spaces at the beginning or end of a text, involuntarily.</p>

<pre class="sh_java">
String text = "Pride and Prejudice ";
text = text.toLowerCase(); // the text is now "Pride and Prejudice "
text = text.trim() // the text is now "Pride and Prejudice"
</pre>

    <p>Let us create the the class <code>Library</code>, which capsulates a HashMap containing books, and allows for book search regardless of its spelling. Let us add the methods <code>addBook(Book book)</code> and <code>removeBook(String bookName)</code> to our <code>Library</code> class. It's already clear that we would need various different methods to clean a string. Therefore, we can create a separate method called <code>private String stringCleaner(String string)</code>.</p>

<pre class="sh_java">
public class Library {
    private HashMap&lt;String, Book&gt; collection;

    public Library() {
        this.collection = new HashMap&lt;String, Book&gt;();
    }

    public void lisaaBook(Book book) {
        String name = stringCleaner(book.getName());

        if(this.collection.containsKey(nimi)) {
            System.out.println("The book is already in the library!");
        } else {
            collection.put(name, book);
        }
    }

    public void removeBook(String bookName) {
        bookName = stringCleaner(bookName);

        if(this.collection.containsKey(bookName)) {
            this.collection.remove(bookName);
        } else {
            System.out.println("The book was not found, you can't remove it!");
        }
    }

    private String stringCleaner(String string) {
        if (string == null) {
            return "";
        }

        string = string.toLowerCase();
        return string.trim();
    }
}
</pre>
        <p>We implement our search functionality so that we can retrieve a book using a hash algorithm based on the book name.</p>

<pre class="sh_java">
    public Book getBook(String bookName) {
        bookName = stringCleaner(bookName);
        return this.collection.get(bookName);
    }
</pre>

    <p>The method above returns the wanted book when this is found, otherwise it returns a <code>null</code> value. We can also also go through all the collection keys one by one, and say look for the beginning characters of the book's name. In this way, we would anyway fail to capitalise on HashMap performance speed, because we would need to go through all the book names, in the worst case. Search based on the beginning characters of a string is possible through the <code>keySet()</code> method. The <code>keySet()</code> method returns a set of keys, which can be parsed with the <code>for each</code> loop.</p>

<pre class="sh_java">
    public Book getBookUsingItsBeginningCharacters(String beginning) {
        beginning = stringCleaner(beginning);

        for (String key: this.collection.keySet()) {
            if (key.startsWith(beginning)) {
                return this.collection.get(key);
            }
        }

        return null;
    }
</pre>

    <p>Let us leave the method above out of our library, anyway. Our library is still lacking an essential feature concerning book addition. Let us create the method <code>public ArrayList&lt;Book&gt; bookList()</code>, which returns a list of the books in our library. The method <code>bookList()</code> makes use of the <code>values()</code> method, which is provided by HashList. The <code>values()</code> method returns a set of our library books, which can be given as parameter to the constructor of an <code>ArrayList</code> class.</p>

<pre class="sh_java">
public class Library {
    private HashMap&lt;String, Book&gt; collection;

    public Library() {
        this.collection = new HashMap&lt;String, Book&gt;();
    }

    public Book getBook(String bookName) {
        bookName = stringCleaner(bookName);
        return this.collection.get(bookName);
    }

    public void addBook(Book kirja) {
        String name = stringCleaner(book.getName());

        if(this.collection.containsKey(name)) {
            System.out.println("The book is already in the library!");
        } else {
            this.collection.put(name, book);
        }
    }

    public void removeBook(String bookName) {
        bookName = stringCleaner(bookName);

        if(this.collection.containsKey(bookName)) {
            this.collection.remove(bookName);
        } else {
            System.out.println("The book was not found, you can't remove it!");
        }
    }

    public ArrayList&lt;Book&gt; bookList() {
        return new ArrayList&lt;Book&gt;(this.collection.values());
    }

    private String stringCleaner(String string) {
        if (string == null) {
            return "";
        }

        string = string.toLowerCase();
        return string.trim();
    }
}
</pre>

    <p>Among the programming principles, there is the so called <em>DRY</em> principle (Don't Repeat Yourself), according to which we try to avoid repeting the same code in different places. Turning a string to lower case, and its <em>trimming</em> - that is to say removing white spaces from the beginning and the end of a string - would have recourred various different times without the <code>stringCleaner()</code> method. We hardly notice we are repeating the same code before we have written it, in which case it eventually ends up there. This is not bad, however. The most important thing is that we clean our code as soon as we notice the need.</p>


    <h3>Orignial-Type Variables in a HashMap</h3>

    <p>Both HashMap keys and stored objects are referece-type variables. If we want to use an original-type variable as key or stored value, we can use their reference-type equivalent. Some are introduced below.</p>

    <p>
      <table>
        <tr><th>Original-type</th><th>Reference-type equivalent</th><tr>
        <tr><td>int</td><td><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Integer.html" target="_blank">Integer</a></td></tr>
        <tr><td>double</td><td><a href="docs.oracle.com/javase/6/docs/api/java/lang/Double.html" target="_blank">Double</a></td></tr>
        <tr><td>char</td><td><a href="docs.oracle.com/javase/6/docs/api/java/lang/Character.html" target="_blank">Character</a></td></tr>
      </table>
    </p>

        <p>In fact, Java automatically capsulates original-type values and translates them into reference-type values when that is needed. Even though the number <code>1</code> is an original-type variable, it can be used as an <code>Integer</code> key directly in the following way.</p>

<pre class="sh_java">
HashMap&lt;Integer, String&gt; table = new HashMap&lt;Integer, String&gt;();
table.put(1, "Be!");
</pre>

        <p>In Java, the automatic translation of original-type variables into reference-type ones is called <em>auto-boxing</em>, i.e. allocation into a slot. The same process also works in the opposite way. We can create a method which returns a HashMap containing an Integer. In the following example, the automatic translation happens inside the method <code>addTwitch</code>.</p>


<pre class="sh_java">
public class TwitchRegister {
    private HashMap&lt;String, Integer&gt; twitched;

    public NumberBookkeeping() {
        this.twitched = new HashMap&lt;String, Integer&gt;();
    }

    public void addTwitch(String name, int number) {
        this.twitched.put(nimi, numero);
    }

    public int lastTwitch(String name) {
        this.twitched.get(name);
    }
}
</pre>

        <p>Even though the HashMap contains Integer objects, Java can also translate certain reference-type variables into their original-type equivalent. For instance, <code>Integer</code> objects can be translated into <code>int</code> values, if needed. However, this can be misleading! If we try to translate a null reference into a number, we receive the <em>java.lang.reflect.InvocationTargetException</em> error. When we make use of this automatic translation, we have to be sure that the value we want to translate is not null. The above <code>lastTwitch</code> method must be fixed in the following way.</p>

<pre class="sh_java">
    public int lastTwitch(String name) {
        if(this.twitched.containsKey(name) {
            return this.twitched.get(name);
        }

        return 0;
    }
</pre>



<div class="tehtavat">
  <h3>Velkakirja</h3>

  <p>Luo luokka <code>Velkakirja</code>, jolla on seuraavat toiminnot:</p>

  <ul>
    <li> konstruktori <code>public Velkakirja()</code> luo uuden velkakirjan</li>
    <li> metodi <code>public void asetaLaina(String kenelle, double maara)</code> tallettaa velkakirjaan merkinnän lainasta tietylle henkilölle.</li>
    <li> metodi <code>public double paljonkoVelkaa(String kuka)</code> palauttaa velan määrän annetun henkilön nimen perusteella</li>
  </ul>

<p>Luokkaa käytetään seuraavalla tavalla:</p>

<pre class="sh_java">
  Velkakirja matinVelkakirja = new Velkakirja();
  matinVelkakirja.asetaLaina("Arto", 51.5);
  matinVelkakirja.asetaLaina("Mikael", 30);

  System.out.println(matinVelkakirja.paljonkoVelkaa("Arto"));
  System.out.println(matinVelkakirja.paljonkoVelkaa("Joel"));
</pre>

<p>Yllä oleva esimerkki tulostaisi:</p>

<pre>
51.5
0
</pre>

<p>Ole tarkkana tilanteessa, jossa kysytään velattoman ihmisen velkaa. Kertaa luvun 4.3 lopun esimerkki!</p>

  <p>Huom! Velkakirjan ei tarvitse huomioida vanhoja lainoja. Kun asetat uuden velan henkilölle jolla on vanha velka, vanha velka unohtuu.</p>  

<pre class="sh_java">
  Velkakirja matinVelkakirja = new Velkakirja();
  matinVelkakirja.asetaLaina("Arto", 51.5);
  matinVelkakirja.asetaLaina("Arto", 10.5);

  System.out.println(matinVelkakirja.paljonkoVelkaa("Arto"));
</pre>

<pre>
10.5
</pre>

  <h3>Sanakirja</h3>

  <p>Tässä tehtäväsarjassa toteutetaan sanakirja, josta voi hakea suomen kielen sanoille englanninkielisiä käännöksiä. Sanakirjan tekemisessä käytetään <code>HashMap</code>-tietorakennetta.</p>

  <h4 class="req">Luokka Sanakirja</h4>

  <p>Toteuta luokka nimeltä <code>Sanakirja</code>. Luokalla on aluksi seuraavat metodit:</p>

  <ul>
    <li> <code>public String kaanna(String sana)</code> metodi palauttaa parametrinsa käännöksen. Jos sanaa ei tunneta, palautetaan <em>null</em>.</li>
    <li> <code>public void lisaa(String sana, String kaannos)</code> metodi lisää sanakirjaan uuden käännöksen</li>
  </ul>

  <p>Toteuta luokka Sanakirja siten, että sen ainoa oliomuuttuja on <code>HashMap</code>-tietorakenne.</p>

  <p>Testaa sanakirjasi toimintaa:</p>

<pre class="sh_java">
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    sanakirja.lisaa("cembalo", "harpsichord");

    System.out.println(sanakirja.kaanna("apina"));
    System.out.println(sanakirja.kaanna("porkkana"));
</pre>

<pre>
monkey
null
</pre>

<h4>Sanojen lukumäärä</h4>

  <p>Lisää sanakirjaan metodi <code>public int sanojenLukumaara()</code>, joka palauttaa sanakirjassa olevien sanojen lukumäärän.</p>

<pre class="sh_java">
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    System.out.println(sanakirja.sanojenLukumaara());

    sanakirja.lisaa("cembalo", "harpsichord");
    System.out.println(sanakirja.sanojenLukumaara());
</pre>


<pre>
2
3
</pre>

<h4>Kaikkien sanojen listaaminen</h4>

  <p>Lisää sanakirjaan metodi <code>public ArrayList&lt;String&gt; kaannoksetListana()</code> joka palauttaa sanakirjan sisällön listana <i>avain = arvo</i> muotoisia characterStringja.</p>

<pre class="sh_java">
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    sanakirja.lisaa("cembalo", "harpsichord");

    ArrayList&lt;String&gt; kaannokset = sanakirja.kaannoksetListana();
    for(String kaannos: kaannokset) {
        System.out.println(kaannos);
    }
</pre>

<pre>
banaani = banana
apina = monkey
cembalo = harpsichord
</pre>

<p><strong>Vihje:</strong> saat käytyä kaikki HashMapissa olevat avaimet läpi metodin <code>keySet</code> avulla seuraavasti:</p>

<pre class="sh_java">
    HashMap&lt;String, String&gt; sanaparit = new HashMap&lt;String, String&gt;();

    sanaparit.put("apina", "eläin");
    sanaparit.put("etelä", "ilmansuunta");
    sanaparit.put("sauerkraut", "ruoka");

    for ( String avain : sanaparit.keySet() ) {
        System.out.print( avain + " " );
    }
 
    // tulostuu apina etelä sauerkraut
</pre>



  <h4 class="req">Tekstikäyttöliittymän alku</h4>

  <p>Harjoitellaan tässäkin tehtävässä erillisen tekstikäyttöliittymän tekemistä. Luo luokka <code>Tekstikayttoliittyma</code>, jolla on seuraavat metodit
    <ul>
      <li> konstruktori <code>public Tekstikayttoliittyma(Scanner lukija, Sanakirja sanakirja)</code></li>
      <li> metodi <code>public void start()</code>, joka käynnistää tekstikäyttöliittymän.</li>
    </ul>
  </p>

<p>Tekstikäyttöliittymä tallettaa konstruktorin parametrina saamansa lukijan ja sanakirjan oliomuuttujiin. Muita oliomuuttujia ei tarvita.
<strong>
Käyttäjän syötteen lukeminen tulee hoitaa konstruktorin parametrina saatua lukija-olioa käyttäen! Myös kaikki käännökset on talletettava  konstruktorin parametrina saatuun sanakirja-olioon. Tekstikäyttöliittymä ei saa luoda olioita itse! 
</strong>
</p>

<p><strong>HUOM:</strong> vielä uudelleen edellinen, eli <strong>Tekstikäyttöliittymä ei saa luoda itse skanneria</strong> vaan sen on käytettävä parametrina saamaansa skanneria syötteiden lukemiseen!</p>

  <p>Tekstikäyttöliittymässä tulee aluksi olla vain komento <code>lopeta</code>, joka poistuu tekstikäyttöliittymästä. Jos käyttäjä syöttää jotain muuta, käyttäjälle sanotaan "Tuntematon komento".</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.start();
</pre>

<pre>
Komennot:
  lopeta - poistuu käyttöliittymästä

Komento: <font color="red">apua</font>
Tuntematon komento.

Komento: <font color="red">lopeta</font>
Hei hei!
</pre>

  <h4 class="req">Sanojen lisääminen ja kääntäminen</h4>

  <p>Lisää tekstikäyttöliittymälle komennot <code>lisaa</code> ja <code>kaanna</code>. Komento <code>lisaa</code> lisää kysyy käyttäjältä sanaparin ja lisää sen sanakirjaan. Komento <code>kaanna</code> kysyy käyttäjältä sanaa ja tulostaa sen käännöksen.</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.start();
</pre>

<pre>
Komennot:
  lisaa - lisää sanaparin sanakirjaan
  kaanna - kysyy sanan ja tulostaa sen käännöksen
  lopeta - poistuu käyttöliittymästä

Komento: <font color="red">lisaa</font>
Suomeksi: <font color="red">porkkana</font>
Käännös: <font color="red">carrot</font>

Komento: <font color="red">kaanna</font>
Anna sana: <font color="red">porkkana</font>
Käännös: carrot

Komento: <font color="red">lopeta</font>
Hei hei!
</pre>

</div>


<h2>Towards Automatic Tests</h2>

<p>Testing a program manually is a hopeless burden. It is possible to automate inputs by setting up a string as a Scanner object parameter. The example below shows how it is possible to test automatically the program above.</p>

<pre class="sh_java">
    String input = "translate\n" + "monkey\n"  +
                   "translate\n" + "cheese\n" +
                   "add\n"  + "cheese\n" + "juusto\n" +
                   "translate\n" + "cheese\n" +
                   "quit\n";

    Scanner reader = new Scanner(input);
    Dictionary dictionary = new Dictionary();

    TextUserInterface interface = new TextUserInterface(reader, dictionary);
    interface.start();
</pre>

  <p>The print output contains only the program output, and not the user commands.</p>

<pre>
Commands:
  add - adds a word couple to the dictionary
  translate - asks for a word and prints its translation
  quit - stops the user interface

Command: Give word: Unknown word!

Command: Give word: Unknown word!

Command: In Finnish: Translation:
Command: Give word: Translation: juusto

Command: Cheers!
</pre>

<p>Giving a string to a Scanner class is a way to replace the String inputs given with the keyboard. The contents of the String variable <code>input</code> "simulates" the user input. <code>\n</code> denotes a line break. Each single part of the <code>input</code> variable which ends with a line break corresponds to one nextLine() input.</p>

<p>It is easy to change the text input, and we can add new words to our dictionary, in the following way:</p>

<pre class="sh_java">
    String input = "add\n"  + "cheese\n" + "juusto\n" +
                   "add\n"  + "bier\n" + "olut\n" +
                   "add\n"  + "book\n" + "kirja\n" +
                   "add\n"  + "computer\n" + "tietokone\n" +
                   "add\n"  + "auto\n" + "car\n" +
                   "quit\n";
</pre>

<p>If you want to test again your program manually, change the Scanner object constructor parameter into <code>System.in</code>, i.e system input stream.</p>

<p>The program functionality must be checked from the output pane, still. The result can still be confusing at the beginning, because the athomatic input does not appear in the output pane at all.</p>

<p>The final goal will be to automate also the program functionality inspection, so that both testing the program and analising its output text would happen successfully in a click.</p>




<h2>Java API</h2>

        <p>The Java programming language we use in our course is made of three things. The first is the program syntax and semantics: the way we define variables, the control flow, the variable and class structure, and their functionality. The second is JVM, i.e. <em>Java Virtual Machine</em>, used for running our programs. Our Java programs are translated into a <em>bytecode</em>, which can be run on whatever computer has JVM. We haven't dealt with program translation because the program environment does it on our behalf. Sometimes, if the program environtment does not work as expected we may have to choose <em>clean & build</em>, which deletes the old source code and translates our program again. The third is API (<em>Application Programming Interface</em>), that is to say the program interface or standard library.</p>

        <p>API is a set of built-in classes specific of the programming language, which is provided to users for their own projects. For instance the casses <code>ArrayList</code>, <code>Arrays</code>, <code>Collections</code>, and <code>String</code> are all part of Java's build-in API. A description of the API of Java 7 can be found at the address <a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank">http://docs.oracle.com/javase/7/docs/api/</a>. On the left side of the page we find a description of Java's built-in classes. If you look for the <code>ArrayList</code> class, you  find a link to <a href="http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html" target="_blank">http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html</a>, which shows the stucture, constructors, and methods of the class.</p>

        <p>NetBeans is able to show a class API, if needed. If you write a class name and add the relative import sentence, you can right click on the class name and and choose <em>Show Javadoc</em>. This opens the class API description in your browser.</p>

<div class="tehtavat">
  <h3>Lentokenttä</h3>

  <p>Jokaisella viikolla on yksi laajempi tehtävä, jossa pääset vapaasti suunnittelemaan ohjelman rakenteen, käyttöliittymän ulkomuoto ja vaaditut komennot on määritelty ennalta. Ohjelmoinnin jatkokurssin ensimmäinen vapaasti suunniteltava tehtävä on <em>Lentokenttä</em>.</p>

<p><b>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. Älä myöskään käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</b></p>

  <p>Lentokenttä-tehtävässä toteutetaan lentokentän hallintasovellus. Lentokentän hallintasovelluksessa hallinnoidaan lentokoneita ja lentoja. Lentokoneista tiedetään aina tunnus ja kapasiteetti. Lennoista tiedetään lennon lentokone, lähtöpaikan tunnus (esim. <a href="http://en.wikipedia.org/wiki/Helsinki_Airport" target="_blank">HEL</a>) ja kohdepaikan tunnus (esim. <a href="http://en.wikipedia.org/wiki/Batman_Airport" target="_blank">BAL</a>).</p>

  <p>Sekä lentokoneita että lentoja voi olla useita. Sama lentokone voi myös lentää useaa eri lentoa (useaa eri reittiä). Sovelluksen tulee toimia kahdessa vaiheessa. Ensin lentokentän työntekijä syöttää lentokoneiden ja lentojen tietoja hallintakäyttöliittymässä.</p>

  <p>Kun käyttäjä poistuu hallintakäyttöliittymässä, avautuu käyttäjälle mahdollisuus lentopalvelun käyttöön. Lentopalvelussa on kolme toimintoa; lentokoneiden tulostaminen, lentojen tulostaminen, ja lentokoneen tietojen tulostaminen. Tämän lisäksi käyttäjä voi poistua ohjelmasta valitsemalla vaihtoehdon <code>x</code>. Jos käyttäjä syöttää epäkelvon komennon, kysytään komentoa uudestaan.</p>


<pre>
Lentokentän hallinta
--------------------

Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">1</font>
Anna lentokoneen tunnus: <font color="red">HA-LOL</font>
Anna lentokoneen kapasiteetti: <font color="red">42</font>
Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">1</font>
Anna lentokoneen tunnus: <font color="red">G-OWAC</font>
Anna lentokoneen kapasiteetti: <font color="red">101</font>
Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">2</font>
Anna lentokoneen tunnus: <font color="red">HA-LOL</font>
Anna lähtöpaikan tunnus: <font color="red">HEL</font>
Anna kohdepaikan tunnus: <font color="red">BAL</font>
Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">2</font>
Anna lentokoneen tunnus: <font color="red">G-OWAC</font>
Anna lähtöpaikan tunnus: <font color="red">JFK</font>
Anna kohdepaikan tunnus: <font color="red">BAL</font>
Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">2</font>
Anna lentokoneen tunnus: <font color="red">HA-LOL</font>
Anna lähtöpaikan tunnus: <font color="red">BAL</font>
Anna kohdepaikan tunnus: <font color="red">HEL</font>
Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">x</font>

Lentopalvelu
------------

Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
> <font color="red">1</font>
G-OWAC (101 henkilöä)
HA-LOL (42 henkilöä)
Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
> <font color="red">2</font>
HA-LOL (42 henkilöä) (HEL-BAL)
HA-LOL (42 henkilöä) (BAL-HEL)
G-OWAC (101 henkilöä) (JFK-BAL)

Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
> <font color="red">3</font>
Mikä kone: <font color="red">G-OWAC</font>
G-OWAC (101 henkilöä)

Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
> <font color="red">x</font>
</pre>

<p><strong>Huom1:</strong> Testien kannalta on oleellista että <em>käyttöliittymä</em> toimii <b>täsmälleen</b> kuten yllä kuvattu. Ohjelman tulostamat menut kannattaneekin copypasteta tästä ohjelmakoodiin. Testit eivät oleta, että ohjelmasi on varautunut epäkelpoihin syötteisiin. Tämä tehtävä on kolmen yksittäisen tehtäväpisteen arvoinen.</p>

<p><strong>Huom2:</strong> älä käytä luokkein nimissä skandeja, ne saattavat aiheuttaa ongelmia testeihin!</p>

<p><em><strong>Ohjelman tulee käynnistyä kun tehtäväpohjassa oleva main-metodi suoritetaan.</strong></em></p>

<p><b>Vielä uudelleen varoitus:</b> jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. Älä myöskään käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</p>
</div>



<div class="tyhja"></div>

<div class="viikkoraja">Week 2</div>

<h2 id="object">Object</h2>

        <p>In our course, we have been using frequently the method <code>public String toString()</code> when we wanted to print an object in the shape of a string. Calling the method without setting it up properly does usually cause an error. We can have a look at the class <code>Book</code>, which does not contain the method <code>public String toString()</code> yet, and see what happens when the program uses the method <code>System.out.println()</code> and tries to print an object of <code>Book</code> class.</p>

<pre class="sh_java">
public class Book {
    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }
}
</pre>

<pre class="sh_java">
Book objectBook = new Book("Object book", 2000);
System.out.println(objectBook);
</pre>

        <p>if we take an object of <code>Book</code> class and use it as the parameter of the method <code>System.out.println()</code>, our program does not print an error message. Our program does not crash, and instead of reading an error message, we notice an interesting print output. The print output contains the name of the lass, <code>Book</code>, plus an indefinite String which follows a @ character. Notice that when we call <code>System.out.println(objectBook)</code> Java calls <code>System.out.println(objectBook.toString())</code>, in fact, but this does not cause an error.</p>

        <p>The explenation is related to the way Java classes are built. Each Java class automatically <em>inherits</em> the <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html" target="_blank">Object</a></code> class, which contains a set of methods that are useful to each Java class. Heritage means that our class has access to the features and functions defined in the inherited class. Among the others, the class <code>Object</code> contains the method <code>toString</code>, which is inherited by the classes we create.</p>

        <p>The <code>toString</code> method inherited from the object class is not usually the one we'd want. That's why we will want to <em>replace</em> it with one we make personally. Let us add the method <code>public String toString()</code> to our <code>Book</code> class. This method will replace the <code>toString</code> method inherited from the <code>Object</code> class.</p>

<pre class="sh_java">
public class Book {
    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    @Override
    public String toString() {
        return this.name + " (" + this.publishingYear + ")";
    }
}
</pre>

        <p>If now we create an object instance, and we set it into the print method, we notice that the <code>toString</code> method of the <code>Book</code> class produces a string.</p>

<pre class="sh_java">
Book objectBook = new Book("Object book", 2000);
System.out.println(objectBook);
</pre>

<pre>
Object book (2000)
</pre>

        <p>Above the <code>toString</code> method of class <code>Book</code> we see the <code>@Override</code> <em>annotation</em>. We use annotations to give guidelines to both the translator and the reader about how to relate to the methods. The <code>@Override</code> annotation tells that the following method replaces the one defined inside the inherited class. If we don't add an annotation to the method we replace, the translator gives us a <em>warning</em>, however avoiding writing annotations is not a mistake.</p>

        <p>There are also other useful methods we inherit from the <code>Object</code> class. Let us now get acquainted with the methods <code>equals</code> and <code>hashCode</code>.</p>

        <h3>Equals Method</h3>

        <p>The <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#equals(java.lang.Object)" target="_blank">equals</a></code> method is used to compare two objects. The method is particularly used when we compare two <code>String</code> objects.</p>

<pre class="sh_java">
Scanner reader = new Scanner(System.in);

System.out.print("Write password: ");
String password = reader.nextLine();

if(password.equals("password")) {
    System.out.println("Right!");
} else {
    System.out.println("Wrong!");
}
</pre>

<pre>
Write password: <font color="red">mightycarrot</font>
Wrong!
</pre>

        <p>The <code>equals</code> method is defined in the <code>Object</code> class, and it makes sure that both the parameter object and the compared object have the same reference. In other words, by default the method makes sure that we are dealing with <em>one</em> unique object. If the reference is the same, the method returns <code>true</code>, otherwise <code>false</code>. The following example should clarify the concept. The class <code>Book</code> doesn't implement its own <code>equals</code> method, and therefore it uses the one created by the <code>Object</code> class.</p>

<pre class="sh_java">
Book objectBook = new Book("Objectbook", 2000);
Book anotherObjectBook = objectBook;

if (objectBook.equals(objectBook)) {
    System.out.println("The books were the same");
} else {
    System.out.println("The books were not the same");
}

// Now we create an object with the same contents, which is however a different, independent object
anotherObjectBook = new Book("Objectbook", 2000);

if (objectBook.equals(anotherObjectBook)) {
    System.out.println("The books were the same");
} else {
    System.out.println("The books were not the same");
}
</pre>

<p>Print output:</p>

<pre>
The books were the same
The books were not the same
</pre>

        <p>Even if the internal structure of both <code>Book</code> objects (i.e. the object variable values) is exactly the same, only the first comparison prints "<code>The books were the same</code>". This depends on the fact that only in the first case also the references were the same, i.e. we were comparing an object with itself. In the second example, we had two different objects even though they both had the same values.</p>

<p>When we use the <code>equals</code> method to compare strings, it works as we want it to: it identifies two strings as equal if the have the same <em>contents</em> even though they are two different objects. In fact, the default <code>equals</code> method is replaced with a new implementation in the String class.</p>

        <p>We want that book comparison happened against name and year. We replace the <code>equals</code> method in the <code>Object</code> class with an implementation in the <code>Book</code> class. The <code>equals</code> method has to make sure whether the object is the same as the one received as parameter. First, we define a method according to which all the objects are the same.</p>

<pre class="sh_java">
    public boolean equals(Object object) {
        return true;
    }
</pre>

        <p>Our method is a little too optimistic, so let us change its functionality slightly. Let us define that the objects are not the same if the parameter object is <em>null</em> or if the the two object types are different. We can find out the type of an object with the method <code>getClass()</code> (which is denifed in the <code>oject</code> class). Otherwise, we expect that the objects are the same.</p>

<pre class="sh_java">
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (this.getClass() != object.getClass()) {
            return false;
        }

        return true;
    }
</pre>

        <p>The <code>equals</code>method finds out the class difference of two objects, but it is not able to distinguish two similar objects from each other. In order to compare our object with the object we received as parameter, and whose reference is <code>Object</code> type, we have to change the type of the Object reference. The reference type can be changed if and only if the object type is really such as we are converting it into. Type casting happens by specifying the desired class within brakets on the right side of the assignment sentence:</p>

<pre class="sh_java">
    WantedType variable = (WantedType) oldVariable;
</pre>

        <p>Type casting is possible because we know two objects are the same type. If they are different type, the above <code>getClass</code> method returns false. Let us change the <code>Object</code> parameter received with the <code>equals</code> method into <code>Book</code> type, and let us identify two different books against their publishing year. The books are otherwise the same.</p>

<pre class="sh_java">
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (getClass() != object.getClass()) {
            return false;
        }

        Book compared = (Book) object;

        if(this.publishingYear != compared.getPublishingYear()) {
            return false;
        }

        return true;
    }
</pre>

        <p>Now, our comparison method is able to distinguish books against their publishing year. Wa want to check still that our book names are the same, and our own book name is not <em>null</em>.</p>

<pre class="sh_java">
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (getClass() != object.getClass()) {
            return false;
        }

        Book compared = (Book) object;

        if (this.publishingYear != compared.getPublishingYear()) {
            return false;
        }

        if (this.name == null || !this.name.equals(compared.getName())) {
            return false;
        }

        return true;
    }
</pre>

        <p>Excellent, we have got a method for comparison which works, finally! Below is our <code>Book</code> class as it looks like at the moment.</p>

<pre class="sh_java">
public class Book {
    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    @Override
    public String toString() {
        return this.name + " (" + this.publishingYear + ")";
    }

    @Override
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (getClass() != object.getClass()) {
            return false;
        }

        Book compared = (Book) object;

        if (this.publishingYear != compared.getPublishingYear()) {
            return false;
        }

        if (this.name == null || !this.name.equals(compared.getName())) {
            return false;
        }

        return true;
    }
}
</pre>

        <p>Now, our book comparison returns <code>true</code>, if the book contents are the same.</p>

<pre class="sh_java">
Book objectBook = new Book("Objectbook", 2000);
Book anotherObjectBook = new Book("Objectbook", 2000);

if (objectBook.equals(anotherObjectBook)) {
    System.out.println("The books are the same");
} else {
    System.out.println("The books are not the same");
}
</pre>

<pre>
The books are the same
</pre>

        <h4>Equals and ArrayList</h4>

        <p>Various different Java made-up methods make use of the <code>equals</code> method to implement their search functionality. For instance, the <code>contains</code> mehod of class <code>ArrayList</code> compares objects through the <code>equals</code> method. Let us continue to use the <code>Book</code> class we defied for our examples. If our objects do not implement the <code>equals</code> method, we can't use the <code>contains</code> method, for instance. Try out the code below in two different <code>book</code> classes. The first class implements the <code>equals</code> method, the other does not.</p>

<pre class="sh_java">
ArrayList&lt;Book&gt; kirjat = new ArrayList&lt;Book&gt;();
Book objectBook = new Book("Objectbook", 2000);
books.add(olioBook);

if (books.contains(objectBook)) {
    System.out.println("The object book was found.");
}

objectBook = new Book("Objectbook", 2000);

if (!books.contains(objectBook)) {
    System.out.println("The object book was not found.");
}
</pre>

        <h3>HashCode Method</h3>

        <p>The <code>hashCode</code> method takes an object and returns a numeric value, i.e. a hash value. We need numeric values for instance when we use and object as HashMap keys. So far, we have been using only String and Integer objects as HashMap keys, and their <code>hashCode</code> method is implemented by default. Let us make an example where it is not so: let us continue with our book examples and let us start to take note of our books on loan. We want to implement our bookkeeping through Hashmap. The key is the book, and the book's value is a string, which tells the loaner's name:</p>

<pre class="sh_java">
        HashMap&lt;Book, String&gt; loaners = new HashMap&lt;Book, String&gt;();
       
        Book objectbook = new Book("Objectbook", 2000);
        loaners.put( objectbook, "Pekka" );
        loaners.put( new Book("Test Driven Development",1999), "Arto" );
        
        System.out.println( loaners.get( objectbook ) );
        System.out.println( loaners.get( new Book("Objectbook", 2000) );
        System.out.println( loaners.get( new Book("Test Driven Development", 1999) );
</pre>

<p>Print output:</p>

<pre>
Pekka
null
null
</pre>

        <p>We can find the loaner by searching against the same object which was given as HashMap key with the <code>put</code> method. However, if our search item is the same book but a different object, we are not able to find its loaner and we are retured with a <em>null</em> reference. This is again due to the default implementation of the <code>hashCode</code> method of <code>Object</code> class. The default implementation creates an index based on the reference; this means that different objects with the same content receive different hashCode method outputs, and therefore it is not possible to find the right place of the object in the HashMap.</p>

        <p>To be sure the HashMap worked in the way we want - i.e. it returned the loaner when the key is an object with the right <em>content</em> (not necessarily the same object as the original value) - the class which works as key must overwrite both the <code>equals</code> method and the <code>hashCode</code> method. The method must be overwritten in such a way, so that it would assign the same numeric value to all objects which have the same content. Some objects with different content may eventually be assigned the same hashCode; however, different content objects should be assigned the same hashCode as rarely as possible, if we want our HashMap to be efficient.</p> 

<p>Previously, we have successfully used <code>String</code> objects as HashMap keys, and we can therefore say that the <code>String</code> class has got a <code>hashCode</code> implementation which works as expected. Let us <em>delegate</em> the calculation to the <code>String</code> object.</p>

<pre class="sh_java">
    public int hashCode() {
        return this.name.hashCode();
    }
</pre>

        <p>The solution above is quite good; but if <code>name</code> is <em>null</em>, we are thrown a <code>NullPointerException</code>. We can fix this by setting the condition: if the value of the <code>name</code> variable is is <em>null</em>, return value 7. Seven is a value chosen casually, thirteen could have done as well.</p>

<pre class="sh_java">
    public int hashCode() {
        if (this.name == null) {
            return 7;
        }

        return this.name.hashCode();
    }
</pre>

<p>We can still improve the <code>hashCode</code> method by taking into consideration the book publishing year, in our calculations:</p>

<pre class="sh_java">
    public int hashCode() {
        if (this.name == null) {
            return 7;
        }

        return this.publishingYear + this.name.hashCode();
    }
</pre>


        <p>An additional remark: the output of the hashCode method of HashMap key objects tells us their value slot in the hash construction, i.e. their index in the HashMap. You may now be wondering: "doesn't this lead to a situation where more than one object ends up with the same index in the HashMap?". The answer is yes and no. Even if the <code>hashCode</code> method gave the same value to two different objects, HashMaps are built in such way that various different obejcts may have the same index. In order to distinguish objects with the same index, the key objects of the HashMap must have implemented the <code>equals</code> method. You will find more information about Hashmap implementation in the course <em>Data Structures and Algorithms</em>.</p>

        <p>The final <code>Book</code> class now.</p>

<pre class="sh_java">
public class Book {

    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    @Override
    public String toString() {
        return this.name + " (" + this.publishingYear + ")";
    }

    @Override
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (getClass() != object.getClass()) {
            return false;
        }

        Book compared = (Book) object;

        if (this.publishingYear != compared.getPublishingYear()) {
            return false;
        }

        if (this.name == null || !this.name.equals(compared.getName())) {
            return false;
        }

        return true;
    }

    public int hashCode() {
        if (this.name == null) {
            return 7;
        }

        return this.publishingYear + this.name.hashCode();
    }
}
</pre>

<p><b>Let us sum up everything again:</b> in order to use a class as HashMap key, we have to define</p>
<ul>
<li>The <code>equals</code> method in a way that objects with the same content will return true when compared, whereas different-content objects shall return false</li>
<li>The <code>hashCode</code> method in a way that it assigns the same value to all the objects whose content is regarded as similar</li>
</ul>

<p>The equals and hashCode methods of our Book class fulfill these two conditions. Now, the problem we faced before is solved, and we can find out the book loaners:</p>

<pre class="sh_java">
        HashMap&lt;Book, String&gt; loaners = new HashMap&lt;Book, String&gt;();
       
        Book objectbook = new Book("Objectbook", 2000);
        loaners.put( objectbook, "Pekka" );
        loaners.put( new Book("Test Driven Development",1999), "Arto" );
        
        System.out.println( loaners.get( objectbook ) );
        System.out.println( loaners.get( new Book("Objectbook", 2000) );
        System.out.println( loaners.get( new Book("Test Driven Development", 1999) );
</pre>

<p>Print output:</p>

<pre>
Pekka
Pekka
Arto
</pre>

        <p><em>NetBeans allows for the authomatic creation of the <code>equals</code> and <code>hashCode</code> methods. You from the menu Source -> Insert Code, you can choose <em>equals() and hashCode()</em>. After this, NetBeans asks which object variables the methods shall use.</em></p>

        <div class="tehtavat" id="viikko8">

<NEXTWEEK></NEXTWEEK>

<h3>Autorekisterikeskus</h3>

<h4>Rekisterinumeron equals ja hashCode</h4>

<p>Eurooppalaiset rekisteritunnukset koostuvat kahdesta osasta: yksi tai kaksikirjaimisesta maatunnuksesta ja maakohtaisesti määrittyvästä rekisterinumerosta, joka taas koostuu numeroista ja merkeistä. Rekisterinumeroita esitetään seuraavanlaisen luokan avulla:</p>

<pre class="sh_java">
public class Rekisterinumero {
    // HUOM: oliomuuttujissa on määre final eli niiden arvoa ei voi muuttaa!
    private final String rekNro;
    private final String maa;

    public Rekisterinumero(String rekNro, String maa) {
       this.rekNro = rekNro;
       this.maa = maa;
    }

    public String toString(){
        return maa+ " "+rekNro;
    }
}
</pre>

<p>Rekisterinumeroja halutaan tallettaa esim. ArrayList:eille ja käyttää HashMap:in avaimina, eli kuten yllä mainittu, tulee niille toteuttaa 
metodit <code>equals</code> ja <code>hashCode</code>, muuten ne eivät toimi halutulla tavalla. </p>

<p><strong>Vihje:</strong> ota equals- ja hashCode-metodeihin mallia yllä olevasta Book-esimerkistä. Rekisterinumeron hashCode voidaan muodostaa esim. maatunnuksen ja rekNro:n hashCodejen summana.</p>

<p>Esimerkkiohjelma:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Rekisterinumero rek1 = new Rekisterinumero("FI", "ABC-123");
        Rekisterinumero rek2 = new Rekisterinumero("FI", "UXE-465");
        Rekisterinumero rek3 = new Rekisterinumero("D", "B WQ-431");

        ArrayList&lt;Rekisterinumero&gt; suomalaiset = new ArrayList&lt;Rekisterinumero&gt;();
        suomalaiset.add(rek1);
        suomalaiset.add(rek2);

        Rekisterinumero uusi = new Rekisterinumero("FI", "ABC-123");
        if (!suomalaiset.contains(uusi)) {
            suomalaiset.add(uusi);
        }
        System.out.println("suomalaiset: " + suomalaiset);
        // jos equals-metodia ei ole ylikirjoitettu, menee sama rekisterinumero toistamiseen listalle

        HashMap&lt;Rekisterinumero, String&gt; omistajat = new HashMap&lt;Rekisterinumero, String&gt;();
        omistajat.put(rek1, "Arto");
        omistajat.put(rek3, "Jürgen");

        System.out.println("omistajat:");
        System.out.println(omistajat.get(new Rekisterinumero("FI", "ABC-123")));
        System.out.println(omistajat.get(new Rekisterinumero("D", "B WQ-431")));
        // jos hashCode ei ole ylikirjoitettu, eivät omistajat löydy
    }
</pre>

<p>Jos equals ja hashCode on toteutettu oikein, tulostus on seuraavanlainen</p>

<pre>
suomalaiset: [FI ABC-123, FI UXE-465]   
omistajat:
Arto
Jürgen

</pre>

<h4>Omistaja rekisterinumeron perusteella</h4>

<p>Toteuta luokka <code>Ajoneuvorekisteri</code> jolla on seuraavat metodit:</p>

<ul>
<li><code>public boolean lisaa(Rekisterinumero rekkari, String omistaja)</code> lisää parametrina olevaa rekisterinumeroa vastaavalle autolle parametrina olevan omistajan, metodi palauttaa true jos omistajaa ei ollut ennestään, jos rekisterinumeroa vastaavalla autolla oli jo omistaja, metodi palauttaa false ja ei tee mitään</li>
<li><code>public String hae(Rekisterinumero rekkari)</code> palauttaa parametrina olevaa rekisterinumeroa vastaavan auton omistajan. Jos auto ei ole rekisterissä, palautetaan <code>null</code></li>
<li><code>public boolean poista(Rekisterinumero rekkari)</code> poistaa parametrina olevaa rekisterinumeroa vastaavat tiedot, metodi palauttaa true jos tiedot poistetiin, ja false jos parametria vastaavia tietoja ei ollut rekisterissä</li>
</ul>

<p><strong>Huom:</strong> Ajoneuvorekisterin täytyy tallettaa omistajatiedot <code>HashMap&lt;Rekisterinumero, String&gt; omistajat</code> -tyyppiseen oliomuuttujaan!</p>

<h4>Ajoneuvorekisteri laajenee</h4>

<p>Lisää Ajoneuvorekisteriin vielä seuraavat metodit:</p>

<ul>
<li><code>public void tulostaRekisterinumerot()</code> tulostaa rekisterissä olevat rekisterinumerot</li>
<li><code>public void tulostaOmistajat()</code> tulostaa rekisterissä olevien autojen omistajat, yhden omistajan nimeä ei saa tulostaa kuin kertaalleen vaikka omistajalla olisikin useampi auto</li>
</ul>

</div>

        <h2 id="rajapinta">Interface</h2>

        <p><em>Interface</em> is an instrument we have to define the functionality our classes should have. Interfaces are defined as normal Java classes, but instead of the definition "<code>public class ...</code>", we write "<code>public interface ...</code>". The interfaces influence class behaviour by defining the method names and return values, but they <em>do not containt method implementation</em>. The access modifier is not specified, because it is always <code>public</code>. Let us have a look at the interface <em>Readable</em>, which defines whether an object can be read.</p>

<pre class="sh_java">
public interface Readable {
    String read();
}
</pre>

        <p>The interface <code>Readable</code> defines the method <code>lue()</code>, which returns a string object. The classes which implement an interface decide <em>in which way</em> the methods defined in the interface have to be implemented, in the end. A class implements an interface by adding the keyword <em>implements</em> between the class and the interface name. Below, we create the class <code>SMS</code> which implements <code>Readable</code> interface.</p>

<pre class="sh_java">
public class SMS implements Readable {
    private String sender;
    private String content;

    public Tekstiviesti(String sender, String content) {
        this.sender = sender;
        this.sisalto = content;
    }

    public String getSender() {
        return this.sender;
    }

    public String read() {
        return this.content;
    }
}
</pre>

        <p>Because the class <code>SMS</code> implements the interface <code>Readable</code> (<code>public class SMS implements Readable</code>), the class <code>SMS</code> <em>must</em> implement the method <code>public String read()</code>. The implementations of methods defined in the interface must always have public access.</p>

        <p><em>An interface is a behavioural agreement. In order to implement the behaviour, the class must implement the methods defined by the interface. The programmer of a class which implements an interface has to define what the behaviour will be like. Implementing an interface means to agree that the class will offer all the actions defined by the interface, i.e. the behaviour defined by the interface. A class which implements an interface but does not implement some of the interface methods can not exist.</em></p>

        <p>Let us implement another class which implements the <code>Readable</code> interface, in addition to our <code>SMS</code> class. The class <code>EBook</code> is the electronic implementation of a book, and it contains the book name and page number. The EBook reads one page at time, and the <code>public String read()</code> method always returns the string of the following page.</p>

<pre class="sh_java">
public class EBook implements Readable {
    private String name;
    private ArrayList&lt;String&gt; pages;
    private int pageNumber;

    public Sahkokirja(String name, ArrayList&lt;String&gt; pages) {
        this.name = name;
        this.pages = pages;
        this.pageNumber = 0;
    }

    public String getName() {
        return this.name;
    }

    public int howManyPages() {
        return this.pages.size();
    }

    public String read() {
        String page = this.pages.get(this.pageNumber);
        nextPage();
        return page;
    }

    private void nextPage() {
        this.pageNumber = this.pageNumber + 1;
        if(this.pageNumber % this.pages.size() == 0) {
            this.pageNumber = 0;
        }
    }
}
</pre>

        <p>Classes which implement interfaces generate objects as well as normal classes, and they can be used as ArrayList types too.</p>

<pre class="sh_java">
    SMS message = new SMS("ope", "Awesome stuff!");
    System.out.println(message.read());

    ArrayList&lt;Tekstiviesti&gt; messages = new ArrayList&lt;Tekstiviesti&gt;();
    messages.add(new SMS("unknown number", "I hid the body.");
</pre>

<pre>Awesome stuff!</pre>

<pre class="sh_java">
    ArrayList&lt;String&gt; pages = new ArrayList&lt;String&gt;();
    sivut.add("Split your method into short clear chunks.");
    sivut.add("Devide the user interface logic from the application logic.");
    sivut.add("At first, always code only a small program which solves only a part of the problem.");
    sivut.add("Practice makes perfect. Make up your own fun project.");

    EBook book = new EBook("Programming Hints.", pages);
    for(int page = 0; page < book.howManyPages(); page++) {
        System.out.println(book.read());
    }
</pre>

<pre>

Split your method into short clear chunks.
Divide the user interface logic from the application logic.
At first, always code only a small program which solves only a part of the problem.
Practice makes perfect. Make up your own fun project.
</pre>

<div class="tehtavat">

<h3>Palvelusvelvollinen</h3>

<p>Tehtäväpohjassa on valmiina rajapinta <code>Palvelusvelvollinen</code>, jossa on seuraavat toiminnot:</p>

  <ul>
    <li> metodi <code>int getTJ()</code> palauttaa jäljellä olevien palveluspäivien määrän</li>
    <li> metodi <code>void palvele()</code> vähentää yhden palveluspäivän. Palveluspäivien määrä ei saa mennä negatiiviseksi.</li>	
  </ul>

<pre class="sh_java">
public interface Palvelusvelvollinen {
    int getTJ();
    void palvele();
}
</pre>

<h4>Sivari</h4>

<p>Tee <code>Palvelusvelvollinen</code>-rajapinnan toteuttava luokka <code>Sivari</code>, jolla parametriton konstruktori. Luokalla on oliomuuttuja TJ, joka alustetaan konstruktorikutsun yhteydessä arvoon 362.</p>

<h4>Asevelvollinen</h4>

<p>Tee <code>Palvelusvelvollinen</code>-rajapinnan toteuttava luokka <code>Asevelvollinen</code>, jolla on parametrillinen konstruktori, jolla määritellään palvelusaika (<code>int tj</code>).</p>
</div>


<h3>An Interface as Variable Type</h3>

        <p>When we create a new variable we always specify its type. There are two types of variable types: primitive-type variables (int, double, ...) and reference-type (all objects). As far as reference-type variables are concerned, their class has also been their type, so far.</p>

<pre class="sh_java">
    String string = "string-object";
    SMS message = new SMS("teacher", "Something crazy is going to happen");
</pre>

        <p>The type of an object can be different from its class. For instance, if a class implements the interface <code>Readable</code>, its type is <code>Readable</code>, too. For instance, since the class <code>SMS</code> implements the interface <code>Readable</code>, it has got two types: <code>SMS</code> and <code>Readable</code>.</p>

<pre class="sh_java">
    SMS message = new SMS("teacher", "Awesome stuff!");
    Readable readable = new SMS("teacher", "The SMS is Readable!");
</pre>

<pre class="sh_java">
    ArrayList&lt;String&gt; pages = new ArrayList&lt;String&gt;();
    pages.add("A method can call itself.");

    Readable book = new EBook("Recursion Principles", pages);
    for(int page = 0; page < book.howManyPages(); page++) {
        System.out.println(book.read());
    }
</pre>

        <p>Because an interface can be used as type, it is possible to create a list containing interface-type objects.</p>

<pre class="sh_java">
    ArrayList&lt;Readable&gt; numberList = new ArrayList&lt;Readable&gt;();

    numberList.add(new SMS("teacher", "never been programming before..."));
    numberList.add(new SMS("teacher", "gonna love it i think!"));
    numberList.add(new SMS("teacher", "give me something more challenging! :)"));
    numberList.add(new SMS("teacher", "you think i can do it?"));
    numberList.add(new SMS("teacher", "up here we send several messages each day"));

    for (Readable readable: numberList) {
        System.out.println(readable.read());
    }
</pre>

        <p>The <code>EBook</code> class implements the interface <code>Readable</code>. However, notice that even though the type of the class <code>EBook</code> is an interface, <code>EBook</code> is not the type of all the classes which implement the <code>Readable</code> interface. It is possible to assign an <code>EBook</code> object to a <code>Readable</code> variable, but the assignment does not work in the opposite way without a particular type change.</p>

<pre class="sh_java">
    Readable readable = new Readable("teacher", "The SMS is Readable!"); // works
    SMS message = readable; // not possible

    SMS transformedMessage = (Message) Readable; // works
</pre>

        <p>Type casting works if and only if the variable's type is really what we try to change it into. Type casting is not usually a best practice; one of the only cases where that is legitimate is in connection with the <code>equals</code> method.</p>

        <h3>An Interface as Method Parameter</h3>

        <p>The real use of interfaces becomes clear when we use them for the type of a method parameter. Because interfaces can be used as variable type, they can be used in method calls as parameter type. For instance, the below method <code>print</code> of class <ode>Printer</code> receives a <code>Readable</code> variable.</p>

<pre class="sh_java">
public class Printer {
    public void print(Readable readable) {
        System.out.println(readable.read());
    }
}
</pre>

        <p>The real value of the <code>print</code> method of class <code>Printer</code> is that it's parameter can be <em>whatever</em> class instance which implements our <code>Readable</code> interface. When we call the method of an object, the method will work regardless of the class of this object, as long as the object implements Readable.</p>

<pre class="sh_java">
    SMS message = new SMS("teacher", "Huhhuh, this printer is able to print them, actually!");
    ArrayList&lt;String&gt; pages = new ArrayList&lt;String&gt;();
    pages.add("{3, 5} are the numbers in common between {1, 3, 5} and {2, 3, 4, 5}.");

    EBook book = new EBook("Introduction to University Mathematics.", pages);

    Printer printer = new Printer();
    printer.print(SMS);
    printer.print(book);
</pre>

<pre>
Huhhuh, this printer is able to print them, actually!
{3, 5} are the numbers in common between {1, 3, 5} and {2, 3, 4, 5}.
</pre>

        <p>Let us implement another <code>numberList</code> class, where we can add interesting readable stuff. The class has got an <code>ArrayList</code> instance as object variable where we save things to read. We add items to our number list through the <code>add</code> method which receives a <code>Readable</code> variable as parameter.</p>

<pre class="sh_java">
public class NumberList {
    private ArrayList&lt;Readable&gt; readables;

    public NumberList() {
        this.readables = new ArrayList&lt;Readable&gt;();
    }

    public void add(Readable readable) {
        this.readables.add(readable);
    }

    public int howManyReadables() {
        return this.readables.size();
    }
}
</pre>

        <p>Number lists are usually readable, so we can implement the <code>Readable</code> interface to the <code>NumberList</code> class. The number list <code>read</code> method reads all the objects of the <code>readables</code> list, and it adds them one by one to a string which is returned by the <code>read()</code> method.</p>

<pre class="sh_java">
public class NumberList implements Readable {
    private ArrayList&lt;Readable&gt; readables;

    public NumberList() {
        this.readables = new ArrayList&lt;Readable&gt;();
    }

    public void add(Readable readable) {
        this.readables.add(readable);
    }

    public int howManyReadables() {
        return this.readables.size();
    }

    public String read() {
        String read = "";
        for(Readable readable: this.readables) {
            read += readable.read() + "\n";
        }

        this.readables.clear();
        return read;
    }
}
</pre>

<pre class="sh_java">
    NumberList myList = new NumberList();
    joelList.lisaa(new SMS("matti", "have you already written the tests?"));
    joelList.lisaa(new SMS("matti", "did you have a look at the submissions?"));

    System.out.println("Joel has got " + joelList.howManyReadables() + " messages to read");
</pre>

<pre>
Joel has got got 2 messages to read
</pre>

        <p>Because the type of <code>NumerList</code> is <code>Readable</code>, we can add <code>NumerList</code> objects to our number list, too. In the example below, Joel has got a lot of messages to read, luckily Mikael deals with it and reads the messages on behalf of Joel.</p>

<pre class="sh_java">
    NumberList joelList = new NumberList();
    for (int i = 0; i < 1000; i++) {
        joelList.lisaa(new SMS("matti", "have you already written the tests?"));
    }

    System.out.println("Joel has got " + joelList.howManyReadables() + " messages to read");
    System.out.println("Let's delegate some reading to Mikael");

    NumberList mikaelList = new NumberList();
    mikaelList.add(joelList);
    mikaelList.read();

    System.out.println();
    System.out.println("Joel has got " + joelList.howManyReadables() + " messages to read");
</pre>

<pre>
Joel has got 1000 messages to read
Delegoidaan lukeminen Mikaelille

Joel has got 0 messages to read
</pre>

        <p>The <cide>read</code> method which is called in connection to Mikael's list parses all the <code>Readable</code> objects contained in the list, and calls their <code>read</code> method. At the end of each <code>read</code> method call the list is cleared. In other words, Joel's number list is cleared as soon as Mikael reads it.</p>

        <p><em>At this point, there are a lot of references; it would be good to draw down the objects and try to grasp how the <code>read</code> method call connected to <code>mikaelList</code> works!</em></p>

<div class="tehtavat">

  <h3>Tavaroita ja laatikoita</h3>

  <h4 class="req">Talletettavia</h4>

  <p>Muuton yhteydessa tarvitaan muuttolaatikoita. Laatikoihin talletetaan erilaisia esineitä. Kaikkien laatikoihin talletettavien esineiden on toteutettava seuraava rajapinta:</p>

<pre class="sh_java">
public interface Talletettava {
    double paino();
}
</pre>

  <p>Lisää rajapinta ohjelmaasi. Rajapinta lisätään melkein samalla tavalla kuin luokka, <i>new Java class</i> sijaan valitaan <i>new Java interface</i>.</p>

  <p>Tee rajapinnan toteuttavat luokat <code>Book</code> ja <code>CDLevy</code>. Book saa konstruktorin parametreina kirjan kirjoittajan (String), kirjan nimen (String), ja kirjan painon (double). CD-Levyn konstruktorin parametreina annetaan artisti (String), levyn nimi (String), ja julkaisuvuosi (int). Kaikkien CD-levyjen paino on 0.1 kg.</p>

  <p>Muista toteuttaa luokilla myös rajapinta <code>Talletettava</code>. Luokkien tulee toimia seuraavasti:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Book kirja1 = new Book("Fedor Dostojevski", "Rikos ja Rangaistus", 2);
        Book kirja2 = new Book("Robert Martin", "Clean Code", 1);
        Book kirja3 = new Book("Kent Beck", "Test Driven Development", 0.5);

        CDLevy cd1 = new CDLevy("Pink Floyd", "Dark Side of the Moon", 1973);
        CDLevy cd2 = new CDLevy("Wigwam", "Nuclear Nightclub", 1975);
        CDLevy cd3 = new CDLevy("Rendezvous Park", "Closer to Being Here", 2012);

        System.out.println(kirja1);
        System.out.println(kirja2);
        System.out.println(kirja3);
        System.out.println(cd1);
        System.out.println(cd2);
        System.out.println(cd3);
    }
</pre>

  <p>Tulostus:</p>

<pre>
Fedor Dostojevski: Rikos ja Rangaistus
Robert Martin: Clean Code
Kent Beck: Test Driven Development
Pink Floyd: Dark Side of the Moon (1973)
Wigwam: Nuclear Nightclub (1975)
Rendezvous Park: Closer to Being Here (2012)
</pre>

  <p>Huom! Painoa ei ilmoiteta tulostuksessa.</p>

<h4 class="req">Laatikko</h4>

  <p>Tee luokka laatikko, jonka sisälle voidaan tallettaa <code>Talletettava</code>-rajapinnan toteuttavia tavaroita. Laatikko saa konstruktorissaan parametrina laatikon maksimikapasiteetin kiloina. Laatikkoon ei saa lisätä enempää tavaraa kuin sen maksimikapasiteetti määrää. Laatikon sisältämien tavaroiden paino ei siis koskaan saa olla yli laatikon maksimikapasiteetin.</p>

  <p>Seuraavassa esimerkki laatikon käytöstä:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Laatikko laatikko = new Laatikko(10);

        laatikko.lisaa( new Book("Fedor Dostojevski", "Rikos ja Rangaistus", 2) ) ;
        laatikko.lisaa( new Book("Robert Martin", "Clean Code", 1) );
        laatikko.lisaa( new Book("Kent Beck", "Test Driven Development", 0.7) );

        laatikko.lisaa( new CDLevy("Pink Floyd", "Dark Side of the Moon", 1973) );
        laatikko.lisaa( new CDLevy("Wigwam", "Nuclear Nightclub", 1975) );
        laatikko.lisaa( new CDLevy("Rendezvous Park", "Closer to Being Here", 2012) );

        System.out.println( laatikko );
    }
</pre>

  <p>Tulostuu</p>

<pre>
Laatikko: 6 esinettä, paino yhteensä 4.0 kiloa
</pre>

<p>Huom: koska painot esitetään doubleina, saattaa laskutoimituksissa tulla pieniä pyöristysvirheitä. Tehtävässä ei tarvitse välittää niistä.</p>

<h4 class="req">Laatikon paino</h4>

  <p>Jos teit laatikon sisälle oliomuuttujan <code>double paino</code>, joka muistaa laatikossa olevien esineiden painon, korvaa se metodilla, joka laskee painon:</p>

<pre class="sh_java">
public class Laatikko {
    //...

    public double paino() {
        double paino = 0;
        // laske laatikkoon talletettujen tavaroiden yhteispaino
        return paino;
    }
}
</pre>

  <p>Kun tarvitset laatikon sisällä painoa esim. uuden tavaran lisäyksen yhteydessä, riittää siis kutsua laatikon painon laskevaa metodia.</p>

  <p>Metodi toki voisi palauttaa myös oliomuuttujan arvon. Harjoittelemme tässä kuitenkin tilannetta, jossa oliomuuttujaa ei tarvitse eksplisiittisesti ylläpitää vaan se voidaan tarpeentullen laskea. Seuraavan tehtävän jälkeen laatikossa olevaan oliomuuttujaan talletettu painotieto ei kuitenkaan välttämättä enää toimisi. Miksi? </p>

  <h4 class="req">Laatikkokin on talletettava!</h4>

  <p>Rajapinnan <code>Talletettava</code> toteuttaminen siis edellyttää että luokalla on metodi <code>double paino()</code>. Laatikollehan lisättiin juuri tämä metodi. Laatikosta voidaan siis tehdä talletettava!</p>

  <p>Laatikot ovat oliota joihin voidaan laittaa <code>Talletettava</code>-rajapinnan toteuttavia olioita. Laatikot toteuttavat itsekin rajapinnan. Eli <b>laatikon sisällä voi olla myös laatikoita!</b></p>

  <p>Kokeile että näin varmasti on, eli tee ohjelmassasi muutama laatikko, laita laatikoihin tavaroita ja laita pienempiä laatikoita isompien laatikoiden sisään. Kokeile myös mitä tapahtuu kun laitat laatikon itsensä sisälle. Miksi näin käy?</p>
</div>

<h3>An Interface as Method Return Value</h3>

        <p>As well as any other variable type, an interface can also be used as method return value. Below you find <code>Factory</code>, which can be used to produce different objects that implement the interface <code>Item</code>. In the beginning, Factory produces books and disks at random.</p>

<pre class="sh_java">
   public class Factory {
      public Factory(){
          // Attention: it is not necessary to write an empty constructor if there are no other constructors in the class. 
	  // In such cases, Java creates a default constructor, i.e a constructor without parameter 
      }

       public Item produceNew(){
           Random random = new Random();
           int num = random.nextInt(4);
           if ( num==0 ) {
               return new CD("Pink Floyd", "Dark Side of the Moon", 1973);
           } else if ( num==1 ) {
               return new CD("Wigwam", "Nuclear Nightclub", 1975);
           } else if ( num==2 ) {
               return new Book("Robert Martin", "Clean Code", 1 );
           } else {
               return new Book("Kent Beck", "Test Driven Development", 0.7);
           }      
       }
   }
</pre>

<p>It is possible to use our Fabric without knowing precisely what kind of classes are present in it, as long as they all implement Item. Below you find the class <code>Packer</code> which can be used to get a boxful of items. The Packer knows the fabric which produces its Items:</p>

<pre class="sh_java">
   public class Packer {
       private Fabric fabric; 

       public Packer(){
            fabric = new Fabric();
       }

       public Box giveABoxful() {
            Box box = new Box(100);
             
            for ( int i=0; i &lt; 10; i++ ) {
                Iteam newItem = fabric.produceNew();
                box.add(newItem);
            }
  
            return box;
       }
   }
</pre>

<p>Because the packer doesn't know the classes which implement the Item interface, it is possble to add new classes which implement the interface without having to modify the packer. Below, we create a new class which implements our Item interface - <code>ChocolateBar</code>. Our Fabric was modified to produce chocolate bars in addition to books and CDs. The class <code>Packer</code> works fine with the extended fabric version, without having to change it.</p>

<pre class="sh_java">
   public class ChocolateBar implements Item {
      // we don't need a constructor because Java is able to generate a default one! 

      public double weight(){
         return 0.2;
      }
   }

   public class Fabric {
      // we don't need a constructor because Java is able to generate a default one! 

       public Item produceNew(){
           Random random = new Random();
           int num = random.nextInt(5);
           if ( num==0 ) {
               return new CD("Pink Floyd", "Dark Side of the Moon", 1973);
           } else if ( num==1 ) {
               return new CD("Wigwam", "Nuclear Nightclub", 1975);
           } else if ( num==2 ) {
               return new Book("Robert Martin", "Clean Code", 1 );
           } else if ( num==3 ) {
               return new Book("Kent Beck", "Test Driven Development", 0.7);
           } else {
               return new ChocolateBar();
           }     
       }
   }
</pre>


  <p><em>Using interfaces while programming permits us to reduce the number of dependences among our classes. In our example, Packer is not dependent on the classes which implement Item interface, it is only dependent on the interface itself. This allows us to add classes wihout having to change the class Packer, as long as they implement our interface. We can even add classes that implement the interface to the methods which make use of our packer without compromising the process. In fact, less dependences make it easy to extend a program.</em></p>



<p>We can imlement now the classes <code>PieceOfNews</code> and <code>NewsService</code>; the first reports a singular piece of news, and the second produces the news to be read. The code which makes use of our news service does not have to know the actual news implementation, and that is not even sensible. The only essencial thing is that the program is able to read the news. In fact, the news service can submit its news through the <code>Readable</code> interface.</p>

<pre class="sh_java">
public class PieceOfNews implements Readable {
    private String text;

    public PieceOfNews(String text) {
        this.text = text;
    }

    public String read() {
        return this.text;
    }
}
</pre>

<pre class="sh_java">
public class NewsService {

    public Luettava getLatestNews() {
        return new PieceOfNews("Latest Hot Topics!");
    }
}
</pre>

        <p>The news service always submits a <code>Readable</code> interface object. At this point, people often wonder a simple question: "<code>Why shouldn't we simply use the class PieceOfNews?</code>". The answer is quite long but hopefully it will clear the idea behind this.</p>

        <p>Let us think about a situation where we have a <code>Publisher</code> which publishes news. The publisher has to read the news from the NewsService regularly, and print out the messages (the Publisher could send the message to different media, but let's stick to a basic example). Let us suppose that NewsService returns PieceOfNews objects.</p>

<pre class="sh_java">
public class NewsService {

    public Luettava getLatestNews() {
        return new PieceOfNews("Latest Hot News!");
    }
}
</pre>

        <p>Publisher's essential functionality is a loop, which calls the method <code>getLatestNews</code> with regular intermissions.</p>

<pre class="sh_java">
public class Publisher {
    private NewsService newsService;

    public Publisher() {
        this.newsService = new NewsService();
    }

    public void start() {
        while (true) {
            PieceOfNews news = newsService.getLatestNews();
            System.out.println(news.read());

            try {
                Thread.sleep(10000);
            } catch (Exception e) {
            }
        }
    }
}
</pre>

        <p>So far, everything works well. We can now suppose our CEO notices that they need a new format for graphic news. Thus, we create a different class called <code>GraphicPieceOfNews</code>. GraphicPieceOfNews is readable so our NewsService programmer make it implement our Readable interface.</p>

<pre class="sh_java">
public class GraphicPieceOfNews implements Readable {
    private String imageAddress;
    private String text;

    public GraphicPieceOfNews(String text, String imageAddress) {
        this.text = text;
        this.imageAddress = imageAddress;
    }

    public String read() {
        return this.text + " (image address: " + this.imageAddress + ")";
    }
}
</pre>

        <p>Meanwhile, they also have to modify NewsService class, because it doesn't support the new news format: </p>

<pre class="sh_java">
public class NewsService {

    public GraphicPieceOfNews getLatestNews() {
        return new GraphicPieceOfNews("Latest Hot News!", "image address");
    }
}
</pre>

        <p>Now <em>we have to</em> modify our Publisher. In fact, it does not work any more because it returns an instance of the class <code>GraphicPieceOfNews<code>. How many classes we would have to modify if the news service used ten services, and what about one thousand? At this point <em>each</em> implementation which used our news service should change its own functionality.</p>

        <p>And what about if not all the pieces of news contained photos, and sometimes we wanted to return a <code>PieceOfNews</code> class instance? The method above, <code>getLatestNews</code>, may not be enough.</p>

        <p>Let's go back to our news format change, where the return type of the news service method <code>getLatestNews</code> is <code>Readable</code>.</p>


<pre class="sh_java">
public class NewsService {

    public Readable getLatestNews() {
        return new PieceOfNews("The Latest Hot News!");
    }
}
</pre>

        <p>If the news service CEO wanted to get a new image format, we would not need to modify the <code>getLatestNews</code> method at all.</p>

<pre class="sh_java">
public class NewsService {

    public Readable getLatestNews() {
        return new GraphicPieceOfNews("THe Latest Hot News!", "Photo's address");
    }
}
</pre>

        <p>Not even the Publisher would need any modification.</p>

<pre class="sh_java">
public class Publisher {
    private NewsService newsService;

    public Publisher() {
        this.newsService = new NewsService();
    }

    public void start() {
        while (true) {
            Readable readable = newsService.GraphicPieceOfNews();
            System.out.println(readable.read());

            try {
                Thread.sleep(10000);
            } catch (Exception e) {
            }
        }
    }
}
</pre>

        <p>How many classes should we have modified if our news service offered ten services, and what about one thousand? Zero. And what about if our news service wanted to send sometimes normal news and sometimes graphic news? Easy! We only need to change our news service.</p>

<pre class="sh_java">
public class NewsService {

    public Readable getLatestNews() {
        Random random = new Random();

        if(random.nextDouble() > 0.5) {
            return new PieceOfNews("The Latest Hot News!");
        }

        return new GraphicPieceOfNews("The Latest Hot News!", "photo's address");
    }
}
</pre>

    <p>Even in this case we don't need to change the implementations which make use of our NewsService.</p>


    <p><em>Coding to interface allows for reducing the dependences. If all the services which make use of our news service were coded to the interface Readable, they would not be dependent on any particular class which implements the Readable interface. In the wxamples above, the internal implementation of the news service can be modified so that the modifications would not affect the objects which make use of the news service, in any way.</em></p>



    <h3>Made-Up Interfaces</h3>

    <p>Java API offers a sensible number of made-up interfaces. Below, we get to know some of Java's most used interfaces: <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html" target="_blank">List</a></code>, <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Map.html" target="_blank">Map</a></code>, <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a></code> and <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Collection.html" target="_blank">Collection</a></code>.</p>

    <h4>List</h4>

    <p>The <a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html">List</a> interface defines lists basic functionality. Because the class ArrayList implements the <code>List</code> interface, it can also be initialized through the <code>List</code> interface.</p>

<pre class="sh_java">
List&lt;String&gt; strings = new ArrayList&lt;String&gt;();
strings.add("A String object within an ArrayList object!");
</pre>

    <p>As we notice from the <a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html">List interface Java API</a>, there are a lot of classes which implement the interface <code>List</code>. A list construction which is familiar to hakers like us is the <a href="http://docs.oracle.com/javase/6/docs/api/java/util/LinkedList.html" target="_blank">linked list</a>. A linked list can be used through the List interface in the same way as the objects created from ArrayList.</p>

<pre class="sh_java">
List&lt;String&gt; strings = new LinkedList&lt;String&gt;();
strings.add("A string object within a LinkedList object!");
</pre>

    <p>Both implementations of the <code>List</code> interface work in the same way, in the user point of view. In fact, the interface <em>abstracts</em> their internal functionality. ArrayList and linkedList internal construction is evidently different, anyway. ArrayList saves the objects into a table, and the search is quick with a specific index. Differently, LinkedList builds up a list where each item has got a reference to the following item. When we search for an item in a linked list, we have to go through all the list items till we reach the index.</p>

    <p>When it comes to bigger lists, we can point out more than evident performance differences. LinkedList's strength is that adding new items is always fast. Differently, behind ArrayList there is a table which grows as it fills up. Increasing the size of the table means creating a new one and copying there the information of the old. However, searching against an index is extremely fast with an ArrayList, whereas we have to go thourgh all the list elements one by one before reaching the one we want, with a LinkedList. More information about data structures such as ArrayList and LinkedList internal implementation comes with the course <em>Data structures and algorithms</em>.</p>

    <p>In our programming course you will rather want to choose ArrayList, in fact. Programming to interface is worth of it, anyway: implement your program so that you'll use data structures via interfaces.</p>

    <h4>Map</h4>

    <p>The <a href="http://download.oracle.com/javase/6/docs/api/java/util/Map.html">Map</a> Interface defines HashMap basic fuctionality. Because HashMaps implement the <code>Map</code> interface, it is possible to initialize them trough the <code>Map</code> interface.</p>

<pre class="sh_java">
Map&lt;String, String&gt; translations = new HashMap&lt;String, String&gt;();
kaannokset.put("gambatte", "tsemppiä");
kaannokset.put("hai", "kyllä");
</pre>

    <p>You get HashMap keys thourgh the method <code>keySet</code>.</p>

<pre class="sh_java">
Map&lt;String, String&gt; translations = new HashMap&lt;String, String&gt;();
translations.put("gambatte", "good luck");
translations.put("hai", "yes");

for(String key: translations.keySet()) {
    System.out.println(key + ": " + translations.get(key));
}
</pre>

<pre>
gambatte: good luck
hai: yes
</pre>

    <p>The <code>keySet</code> method returns a set made of keys which implement <code>Set</code> interface. The set which implement the <code>Set</code> interface can be parsed with a for-each loop. HashMap values are retrieved through the <code>values</code> method, which returns a set of values which implement the <code>Collection</code> interface. We should now focus on Set and Collection interfaces.</p>

    <h4>Set</h4>

    <p>The <a href="http://download.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a> interface defines the functionality of Java's sets. Java's sets always contain 0 or 1 element of a certain type. Among the others, <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html" target="_blank">HashSet</a></code> is one of the classes which implement the Set interface. We can parse a key set through a for-each loop, in the following way</p>

<pre class="sh_java">
Set&lt;String&gt; set = new HashSet&lt;String&gt;();
set.add("one");
set.add("one");
set.add("two");

for (String key: set) {
    System.out.println(key);
}
</pre>

<pre>
one
two
</pre>

    <p>Notice that HashSet is not concerned on the order of its keys.</p>

    <h4>Collection</h4>

    <p>The <a href="http://download.oracle.com/javase/6/docs/api/java/util/Collection.html" target="_blank">Collection</a> interface defines the functionality of collections. Among the others, Java's lists and sets are collections -- that is, List and Set interfaces implement the Collection interface. Collection interface provides methods to check object existence (the <code>contains</code> method) and to check the collection size (<code>size</code> method). We can parse any class which implements the Collection interface with a <code>for-each</code> loop. </p>

    <p>We now create a HashMap and parse first its keys, and then its values.</p>

<pre class="sh_java">
Map&lt;String, String&gt; translations = new HashMap&lt;String, String&gt;();
translations.put("gambatte", "good luck");
translations.put("hai", "yes");

Set&lt;String&gt; keys = translations.keySet();
Collection&lt;String&gt; keySet = keys;

System.out.println("Keys:");
for(String key: keySet) {
    System.out.println(key);
}

System.out.println();
System.out.println("Values:");
Collection&lt;String&gt; values = translations.values();
for(String value: values) {
    System.out.println(value);
}
</pre>

<pre>
Keys:
gambatte
hai

Values:
yes
good luck
</pre>


    <p>The following example would have produced the same output, too.</p>

<pre class="sh_java">
Map&lt;String, String&gt; translations = new HashMap&lt;String, String&gt;();
translations.put("gambatte", "good luck");
translations.put("hai", "yes");

System.out.println("Keys:");
for(String key: translations.keySet()) {
    System.out.println(key);
}

System.out.println();
System.out.println("Values:");
for(String value: translations.values()) {
    System.out.println(value);
}
</pre>

    <p>In the following excercise we build an online shop, and we train to use classes through their interfaces.</p>

<div class="tehtavat">
  <h3>Verkkokauppa</h3>

  <p>Teemme tehtävässä muutamia verkkokaupan hallinnointiin soveltuvia ohjelmakomponentteja.</p>

  <h4>Varasto</h4>

  <p>Tee luokka Varasto jolla on seuraavat metodit:</p>

  <ul>
    <li><code>public void lisaaTuote(String tuote, int hinta, int saldo)</code> lisää varastoon tuotteen jonka hinta ja varastosaldo ovat parametrina annetut values</li>
    <li><code>public int hinta(String tuote)</code> palauttaa parametrina olevan tuotteen hinnan, jos tuotetta ei ole varastossa, palauttaa metodi -99</li>
  </ul>


  <p>Varaston sisällä tuotteiden hinnat (ja seuraavassa kohdassa saldot) tulee tallettaa <code>Map&lt;String, Integer&gt;</code>-tyyppiseksi määriteltyyn muuttujaan! Luotava olio voi olla tyypiltään <code>HashMap</code>, muuttujan tyyppinä on kuitenkin käytettävä <code>Map</code>-rajapintaa (ks. <a href="#46.4.2">46.4.2.</a>)</p>

  <p>Seuraavassa esimerkki varaston käytöstä:</p>

<pre class="sh_java">
        Varasto varasto = new Varasto();
        varasto.lisaaTuote("maito", 3, 10);
        varasto.lisaaTuote("kahvi", 5, 7);

        System.out.println("hinnat:");
        System.out.println("maito:  " + varasto.hinta("maito"));
        System.out.println("kahvi:  " + varasto.hinta("kahvi"));
        System.out.println("sokeri: " + varasto.hinta("sokeri"));
</pre>

<p>Tulostuu:</p>

<pre>
hinnat:
maito:  3
kahvi:  5
sokeri: -99
</pre>

<h4>Tuotteen varastosaldo</h4>

  <p>Talleta tuotteiden varastosaldot samaan tapaan <code>Map&lt;String, Integer&gt;</code>-tyyppiseen muuttujaan kuin talletit hinnat. Täydennä varastoa seuraavilla metodeilla:</p>

  <ul>
    <li><code>public int saldo(String tuote)</code> palauttaa parametrina olevan tuotteen varastosaldon.</li>
    <li><code>public boolean ota(String tuote)</code> vähentää parametrina olevan tuotteen saldoa yhdellä ja palauuttaa <em>true</em> jos tuotetta oli varastossa. Jos tuotetta ei ole varastossa, palauttaa metodi <em>false</em>, tuotteen saldo ei saa laskea alle nollan.</li>
  </ul>


  <p>Esimerkki varaston käytöstä:</p>

<pre class="sh_java">
        Varasto varasto = new Varasto();
        varasto.lisaaTuote("kahvi", 5, 1);

        System.out.println("saldot:");
        System.out.println("kahvi:  " + varasto.saldo("kahvi"));
        System.out.println("sokeri: " + varasto.saldo("sokeri"));

        System.out.println("otetaan kahvi " + varasto.ota("kahvi"));
        System.out.println("otetaan kahvi " + varasto.ota("kahvi"));
        System.out.println("otetaan sokeri " + varasto.ota("sokeri"));

        System.out.println("saldot:");
        System.out.println("kahvi:  " + varasto.saldo("kahvi"));
        System.out.println("sokeri: " + varasto.saldo("sokeri"));
</pre>

<p>Tulostuu:</p>

<pre>
saldot:
kahvi:  1
sokeri: 0
otetaan kahvi true
otetaan kahvi false
otetaan sokeri false
saldot:
kahvi:  0
sokeri: 0
</pre>

<h4>Tuotteiden listaus</h4>

  <p>Listätään varastolle vielä yksi metodi:</p>

  <ul>
    <li><code>public Set&lt;String&gt; tuotteet()</code> palauttaa <em>joukkona</em> varastossa olevien tuotteiden nimet</li>
  </ul>

  <p>Metodi on helppo toteuttaa. Saat tietoon varastossa olevat tuotteet kysymällä ne joko hinnat tai saldot muistavalta Map:iltä metodin <code>keySet</code> avulla.</p>

<p>Esimerkki varaston käytöstä:</p>

<pre class="sh_java">
        Varasto varasto = new Varasto();
        varasto.lisaaTuote("maito", 3, 10);
        varasto.lisaaTuote("kahvi", 5, 6);
        varasto.lisaaTuote("piimä", 2, 20);
        varasto.lisaaTuote("jugurtti", 2, 20);

        System.out.println("tuotteet:");
        for (String tuote : varasto.tuotteet()) {
            System.out.println(tuote);
        }
</pre>

<p>Tulostuu:</p>

<pre>
tuotteet:
piimä
jugurtti
kahvi
maito
</pre>

<h4>Ostos</h4>

  <p>Ostoskoriin lisätään <em>ostoksia</em>. Ostoksella tarkoitetaan tiettyä määrää tiettyjä tuotteita. Koriin voidaan laittaa esim. ostos joka vastaa yhtä leipää tai ostos joka vastaa 24:ää kahvia.</p>

  <p>Tee luokka <code>Ostos</code> jolla on seuraavat toiminnot:</p>

  <ul>
    <li><code>public Ostos(String tuote, int kpl, int yksikkohinta)</code> konstruktori joka luo ostoksen joka vastaa parametrina annettua tuotetta. Tuotteita ostoksessa on <em>kpl</em> kappaletta ja yhden tuotteen hinta on kolmantena parametrina annettu <em>yksikkohinta</em></li>
    <li><code>public int hinta()</code> palauttaa ostoksen hinnan. Hinta saadaan kertomalla kappalemäärä yksikköhinnalla</li>
    <li><code>public void kasvataMaaraa()</code> kasvattaa ostoksen kappalemäärää yhdellä</li>
    <li><code>public String toString()</code> palauttaa ostoksen characterStringmuodossa, joka on alla olevan esimerkin mukainen</li>
  </ul>

  <p>Esimerkki ostoksen käytöstä</p>

<pre class="sh_java">
        Ostos ostos = new Ostos("maito", 4, 2);
        System.out.println( "ostoksen joka sisältää 4 maitoa yhteishinta on " + ostos.hinta() );
        System.out.println( ostos );
        ostos.kasvataMaaraa();
        System.out.println( ostos );
</pre>

<p>Tulostuu:</p>

<pre>
ostoksen joka sisältää 4 maitoa yhteishinta on 8
maito: 4
maito: 5
</pre>

  <p>Huom: <em>toString</em> on siis muotoa <em>tuote: kpl</em> hintaa ei characterStringesitykseen tule!</p>

<h4>Ostoskori</h4>

  <p>Vihdoin pääsemme toteuttamaan luokan ostoskori!</p>

  <p>Ostoskori tallettaa sisäisesti koriin lisätyt tuotteet <em>Ostos-olioina</em>. Ostoskorilla tulee olla oliomuuttuja jonka tyyppi on joko <code>Map&lt;String, Ostos&gt;</code> tai <code>List&lt;Ostos&gt;</code>. Älä laita mitään muita oliomuuttujia ostoskorille kuin ostosten talletukseen tarvittava Map tai List.</p>

  <p>Huom: jos talletat Ostos-oliot Map-tyyppiseen apumuuttujaan, on tässä ja seuraavassa tehtävässä hyötyä Map:in metodista values(), jonka avulla on helppo käydä läpi kaikki talletetut ostos-oliot.</p>

  <p>Tehdään aluksi ostoskorille parametriton konstruktori ja metodit:</p>

  <ul>
    <li><code>public void lisaa(String tuote, int hinta)</code> lisää ostoskoriin ostoksen joka vastaa parametrina olevaa tuotetta ja jolla on parametrina annettu hinta.</li>
    <li><code>public int hinta()</code> palauttaa ostoskorin kokonaishinnan</li>
</ul>

<p>Esimerkki ostoksen käytöstä</p>

<pre class="sh_java">
        Ostoskori kori = new Ostoskori();
        kori.lisaa("maito", 3);
        kori.lisaa("piimä", 2);
        kori.lisaa("juusto", 5);
        System.out.println("korin hinta: " + kori.hinta());
        kori.lisaa("tietokone", 899);
        System.out.println("korin hinta: " + kori.hinta());
</pre>

<p>Tulostuu:</p>

<pre>
korin hinta: 10
korin hinta: 909
</pre>

<h4>Ostoskorin tulostus</h4>

  <p>Tehdään ostoskorille metodi <code>public void tulosta()</code> joka tulostaa korin sisältämät <em>Ostos</em>-oliot. Tulostusjärjestyksessä ei ole merkitystä. Edellisen esimerkin ostoskori tulostetuna olisi:</p>

<pre>
piimä: 1
juusto: 1
tietokone: 1
maito: 1
</pre>

  <p>Huomaa, että tulostuva numero on siis tuotteen korissa oleva kappalemäärä, ei hinta!</p>

<h4>yhtä tuotetta kohti vain yksi Ostos-olio</h4>

  <p>Täydennetään Ostoskoria siten, että jos korissa on jo tuote joka sinne lisätään, ei koriin luoda uutta Ostos-olioa vaan päivitetään jo korissa olevaa tuotetta vastaavaa ostosolioa kutsumalla sen metodia <em>kasvataMaaraa()</em>.</p>

<p>Esimerkki:</p>

<pre class="sh_java">
        Ostoskori kori = new Ostoskori();
        kori.lisaa("maito", 3);
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta() +"\n");

        kori.lisaa("piimä", 2);
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta() +"\n");

        kori.lisaa("maito", 3);
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta() +"\n");

        kori.lisaa("maito", 3);
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta() +"\n");
</pre>

<p>Tulostuu:</p>

<pre>
maito: 1
korin hinta: 3

piimä: 1
maito: 1
korin hinta: 5

piimä: 1
maito: 2
korin hinta: 8

piimä: 1
maito: 3
korin hinta: 11
</pre>

  <p>Eli ensin koriin lisätään maito ja piimä ja niille omat ostos-oliot. Kun koriin lisätään lisää maitoa, ei luoda uusille maidoille omaa ostosolioa, vaan päivitetään jo korissa olevan maitoa kuvaavan ostosolion kappalemäärää.</p>

<h4>Kauppa</h4>

  <p>Nyt meillä on valmiina kaikki osat "verkkokauppaa" varten. Verkkokaupassa on varasto joka sisältää kaikki tuotteet. Jokaista asiakkaan asiointia varten on oma ostoskori. Aina kun asiakas valitsee ostoksen, lisätään se asiakkaan ostoskoriin jos tuotetta on varastossa. Samalla varastosaldoa pienennetään yhdellä.</p>

  <p>Seuraavassa on valmiina verkkokaupan koodin runko. Tee projektiin luokka <code>Kauppa</code> ja kopioi alla oleva koodi luokkaan.</p>

<pre class="sh_java">
import java.util.Scanner;

public class Kauppa {

    private Varasto varasto;
    private Scanner lukija;

    public Kauppa(Varasto varasto, Scanner lukija) {
        this.varasto = varasto;
        this.lukija = lukija;
    }

    // metodi jolla hoidetaan yhden asiakkaan asiointi kaupassa
    public void asioi(String asiakas) {
        Ostoskori kori = new Ostoskori();
        System.out.println("Tervetuloa kauppaan " + asiakas);
        System.out.println("valikoimamme:");

        for (String tuote : varasto.tuotteet()) {
            System.out.println( tuote );
        }

        while (true) {
            System.out.print("mitä laitetaan ostoskoriin (pelkkä enter vie kassalle):");
            String tuote = reader.nextLine();
            if (tuote.isEmpty()) {
                break;
            }

            // tee tänne koodi joka lisää tuotteen ostoskoriin jos sitä on varastossa
            // ja vähentää varastosaldoa
            // älä koske muuhun koodiin!

        }

        System.out.println("ostoskorissasi on:");
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta());
    }
}
</pre>

<p>Seuraavassa pääohjelma joka täyttää kaupan varaston ja laittaa Pekan asioimaan kaupassa:</p>

<pre class="sh_java">
    Varasto varasto = new Varasto();
    varasto.lisaaTuote("kahvi", 5, 10);
    varasto.lisaaTuote("maito", 3, 20);
    varasto.lisaaTuote("piimä", 2, 55);
    varasto.lisaaTuote("leipä", 7, 8);

    Kauppa kauppa = new Kauppa(varasto, new Scanner(System.in));
    kauppa.asioi("Pekka");
</pre>

  <p>Kauppa on melkein valmiina. Yhden asiakkaan asioinnin hoitavan metodin <code>public void asioi(String asiakas)</code> on kommenteilla merkitty kohta jonka joudut täydentämään. Lisää kohtaan koodi joka tarkastaa onko asiakkaan haluamaa tuotetta varastossa. Jos on, vähennä tuotteen varastosaldoa ja lisää tuote ostoskoriin.</p>

  <p><em>Vapise, verkkokauppa.com!</em></p>
</div>

<h2>Generics</h2>

    <p>We speak about <em>Generics</em> in connection to the way classes can conserve objects of genric type. Generics is based on the generic type parameter which is used when we define a class, and which helps us to define the types that have to be chosen when an <em>object is created</em>. A class generics can be defined by setting up the number of type parameters we want. This number is written after the class name and between the greater-than and less-than signs. We now implement our own generic class <code>Slot</code> which be assigned whatever object.</p>

<pre class="sh_java">
public class Slot&lt;T&gt; {
    private T key;

    public void setValue(T key) {
        this.key = key;
    }

    public T getValue() {
        return key;
    }
}
</pre>

    <p>The definition <code>public class Slot&lt;T&gt;</code> tells us that we have to give a type parameter to the constructor of the class <code>Slot</code>. After the constructor call the object variables have to be the same type as what established with the call. We now create a slot which memorizes strings.</p>

<pre class="sh_java">
    Slot&lt;String&gt; string = new Slot&lt;String&gt;();
    string.setValue(":)");

    System.out.println(string.getValue());
</pre>

<pre>
:)
</pre>

    <p>If we change the type parameter we can create different kinds of <code>Slot</code> ojects, whose purpose is to memorize objects. For instance, we can memorize an integer in the following way:</p>

<pre class="sh_java">
    Slot&lt;Integer&gt; num = new Slot&lt;Integer&gt;();
    num.setValue(5);

    System.out.println(slot.getValue());
</pre>


<pre>
5
</pre>

    <p>An important part of Java data structures are programmed to be generic. For instance, ArrayList receives one parameter, HashMap two.</p>

<pre class="sh_java">
    List&lt;String&gt; string = new ArrayList&lt;String&gt;();
    Map&lt;String, String&gt; keyCouples = new HashMap&lt;String, String&gt;();
</pre>

    <p>In the future, when you see the type <code>ArrayList&lt;String&gt;</code>, for instance, you know that its internal structure makes use of a generic type parameter.</p>

    <h3>The Interface which Makes Use of Generics: Comparable</h3>

    <p>In addition to normal interfaces, Java has got interfaces which make use of generics. The internal value types of generic interfaces are defined in the same way as for generic classes. Let us have a look at Java made-up <code><a href="http://java.sun.com/javase/6/docs/api/java/lang/Comparable.html">Comparable</a></code> interface. The <code>Comparable</code> interface defines the <code>compareTo</code> method, which returns the place of <code>this</code> object, in relation to the parameter obect (a negative number, 0, or a positive number). If <code>this</code> object is placed before the parameter object in the comparison order, the method returns a negative value, whereas it returns a positive value if it is placed after the parameter object. If the objects are placed at the same place in the comparison order, the method returns 0. With comparison order we mean the object order of magnitude defined by the programmer, i.e. the object order, when they are sorted with the sort method.</p>

    <p>One of the advantages of the <code>Comparable</code> interface is that it allows us to sort a list of Comparable type keys by using the standard library method <code>Collections.sort</code>, for instance. <code>Collections.sort</code> uses the <code>compareTo</code> method of a key list to define in which order these keys should be. We call <em>Natural Ordering</em> this ordering technique which makes use of the <code>compareTo</code> method.

    <p>We create the class <code>ClubMember</code>, which depicts the young people and children who belong to the club. The members have to eat in order of height, so the club members will implement the interface <code>Comparable</code>. The interface <code>Comparable</code> also takes as type parameter the class which it is compared to. As type parameter, we use the <code>ClubMember</code> class.</p>

<pre class="sh_java">
public class ClubMember implements Comparable&lt;ClubMember&gt; {
    private String name;
    private int height;

    public Kerholainen(String name, int height) {
        this.name = name;
        this.height = height;
    }

    public String getName() {
        return this.name;
    }

    public int getHeigth() {
        return this.height;
    }

    @Override
    public String toString() {
        return this.getName() + " (" + this.getHeigth() + ")";
    }

    @Override
    public int compareTo(ClubMember clubMember) {
        if(this.heigth == clubMember.getHeight()) {
            return 0;
        } else if (this.height &gt; clubMember.getHeight()) {
            return 1;
        } else {
            return -1;
        }
    }
}
</pre>

    <p>The interface requires the method <code>compareTo</code>, which returns an integer that tells us the comparison order. Our <code>compareTo()</code> method has to return a negative number if <code>this</code> object is smaller than its parameter object, or zero, if the two members are equally tall. Therefore, we can implement the above <code>compareTo</code> method, in the following way:</p>

<pre class="sh_java">
    @Override
    public int compareTo(ClubMember clubMember) {
        return this.height - clubMember.getHeight();
    }
</pre>

    <p>Sorting club members is easy, now.</p>

<pre class="sh_java">
    List&lt;Kerholainen&gt; clubMembers = new ArrayList&lt;ClubMember&gt;();
    clubMembers.add(new ClubMember("mikael", 182));
    clubMembers.add(new ClubMember("matti", 187));
    clubMembers.add(new ClubMember("joel", 184));

    System.out.println(clubMembers);
    Collections.sort(clubMembers);
    System.out.println(clubMembers);
</pre>

<pre>
[mikael (182), matti (187), joel (184)]
[mikael (182), joel (184), matti (187)]
</pre>

    <p>If we want to sort the members in descending order, we only have to switch the variable order in our <code>compareTo</code> method.</p>


<div class="tehtavat">

  <h3>Köyhät kyykkyyn</h3>

  <p>Saat valmiin luokan Ihminen. Ihmisellä on nimi- ja palkkatiedot. Muokkaa Ihminen-luokasta <code>Comparable</code>-rajapinnan toteuttava niin, että <code>compareTo</code>-metodi lajittelee ihmiset palkan mukaan järjestykseen - suuripalkkaiset ensin, köyhät kyykkyyn listan loppuun.</p>


  <h3>Opiskelijat nimijärjestykseen</h3>

  <p>Saat valmiin luokan Opiskelija. Opiskelijalla on nimi. Muokkaa Opiskelija-luokasta <code>Comparable</code>-rajapinnan toteuttava niin, että <code>compareTo</code>-metodi lajittelee opiskelijat nimen mukaan aakkosjärjestykseen.</p>

  <p><b>Vinkki:</b> Opiskelijan nimi on String, ja String-luokka on itsessään <code>Comparable</code>. Voit hyödyntää String-luokan <code>compareTo</code>-metodia Opiskelija-luokan metodia toteuttaessasi. <code>String.compareTo</code> kohtelee kirjaimia eriarvoisesti kirjainkoon mukaan, ja tätä varten String-luokalla on myös metodi <code>compareToIgnoreCase</code> joka nimensä mukaisesti jättää kirjainkoon huomioimatta. Voit käyttää opiskelijoiden järjestämiseen kumpaa näistä haluat.</p>


  <h3>Kortit ojennukseen</h3>

<p>Tehtäväpohjan mukana on luokka, jonka oliot kuvaavat pelikortteja. Kortilla on arvo ja maa. Kortin arvo on <em>2, 3, ..., 10, J, Q, K </em> tai <em>A</em> ja maa <em>Risti, Ruutu, Hertta</em> tai <em>Pata</em>. Arvo ja maa kuitenkin esitetään olioiden sisällä kokonaislukuina. Kortilla on myös metodi toString, jota käyttäen kortin arvo ja maa tulostuvat "ihmisystävällisesti". </p>

<p>Jotta korttien käyttäjän ei tarvitsisi käsitellä korttien maita numeroina, on luokkaan määritelty neljä <strong>vakioa</strong> eli <code>public static final</code> -muuttujaa: </p>

<pre class="sh_java">
public class Kortti {
    public static final int RISTI  = 0;
    public static final int RUUTU  = 1;
    public static final int HERTTA = 2;
    public static final int PATA   = 3;

    // ...
}
</pre>

<p>Nyt ohjelmassa voidaan luvun 1 sijaan käyttää vakioa <code>Kortti.RUUTU</code>. Seuraavassa esimerkissä luodaan kolme korttia ja tulostetaan ne:</p>

<pre class="sh_java">
  Kortti eka = new Kortti(2, Kortti.RUUTU);
  Kortti toka = new Kortti(14, Kortti.PATA);  
  Kortti kolmas = new Kortti(12, Kortti.HERTTA);

  System.out.println(eka);
  System.out.println(toka);
  System.out.println(kolmas);
</pre>

<p>Tulostuu:</p>

<pre>
Ruutu 2
Pata A
Hertta Q
</pre>

<p><b>HUOM:</b> vaikioiden käyttö ylläolevaan tapaan ei ole tyylikkäin tapa asian hoitamiseen. Myöhemmin kurssilla opimme oikeaoppisen tyylin maan esittämiseen!</p>

  <h4>Kortti-luokasta Comparable</h4>

  <p>Tee Kortti-luokasta Comparable. Toteuta <code>compareTo</code>-metodi niin, että korttien järjestys on arvon mukaan nouseva. Jos verrattavien Korttien arvot ovat samat, verrataan niitä maan perusteella nousevassa järjestyksessä: <em>risti ensin, ruutu toiseksi, hertta kolmanneksi, pata viimeiseksi.</em> </p> 

<p>Järjestyksessä pienin kortti siis olisi risti kakkonen ja suurin pataässä.</p>

<h4>Käsi</h4>

<p>Tehdään seuraavaksi luokka <code>Kasi</code> joka edustaa pelaajan kädessään pitämää korttien joukkoa. Tee kädelle seuraavat metodit:</p>

<ul>
<li><code>public void lisaa(Kortti kortti)</code> lisää käteen kortin</li>
<li><code>public void tulosta()</code> tulostaa kädessä olevat kortit alla olevan esimerkin tyylillä</li>
</ul>

<pre class="sh_java">
  Kasi kasi = new Kasi();

  kasi.lisaa( new Kortti(2, Kortti.RUUTU) );
  kasi.lisaa( new Kortti(14, Kortti.PATA) );
  kasi.lisaa( new Kortti(12, Kortti.HERTTA) );
  kasi.lisaa( new Kortti(2, Kortti.PATA) );

  kasi.tulosta();
</pre>

<p>Tulostuu:</p>

<pre>
Ruutu 2
Pata A
Hertta Q
Pata 2
</pre>

<p>Talleta käden sisällä olevat kortit ArrayListiin.</p>

<h4>Käden järjestäminen</h4>

<p>Tee kädelle metodi <code>public void jarjesta()</code> jota kutsumalla käden sisällä olevat kortit menevät suuruusjärjestykseen. Järjestämisen jälkeen kortit tulostuvat järjestyksessä:</p>

<pre class="sh_java">
  Kasi kasi = new Kasi();

  kasi.lisaa( new Kortti(2, Kortti.RUUTU) );
  kasi.lisaa( new Kortti(14, Kortti.PATA) );
  kasi.lisaa( new Kortti(12, Kortti.HERTTA) );
  kasi.lisaa( new Kortti(2, Kortti.PATA) );

  kasi.jarjesta(); 

  kasi.tulosta();
</pre>

<p>Tulostuu:</p>

<pre>
Ruutu 2
Pata 2
Hertta Q
Pata A
</pre>

<h4>Käsien vertailu</h4>

<p>Eräässä korttipelissä kahdesta korttikädestä arvokkaampi on se, jonka sisältämien korttien arvon summa on suurempi. Tee luokasta <code>Kasi</code> vertailtava tämän kriteerin mukaan, eli laita luokka toteuttamaan rajapinta <code>Comparable&lt;Kasi&gt;</code>.</p>

<p>Esimerkkiohjelma, jossa vertaillaan käsiä:</p>

<pre class="sh_java">
  Kasi kasi1 = new Kasi();

  kasi1.lisaa( new Kortti(2, Kortti.RUUTU) );
  kasi1.lisaa( new Kortti(14, Kortti.PATA) );
  kasi1.lisaa( new Kortti(12, Kortti.HERTTA) );
  kasi1.lisaa( new Kortti(2, Kortti.PATA) );

  Kasi kasi2 = new Kasi();

  kasi2.lisaa( new Kortti(11, Kortti.RUUTU) );
  kasi2.lisaa( new Kortti(11, Kortti.PATA) );
  kasi2.lisaa( new Kortti(11, Kortti.HERTTA) );

  int vertailu = kasi1.compareTo(kasi2);

  if ( vertailu &lt; 0 ) {
    System.out.println("arvokkaampi käsi sisältää kortit");
    kasi2.tulosta();
  } else if ( vertailu &gt; 0 ){
    System.out.println("arvokkaampi käsi sisältää kortit");
    kasi1.tulosta(); 
  } else {
    System.out.println("kädet yhtä arvokkaat");
  }
</pre>

<p>Tulostuu</p>

<pre>
arvokkaampi käsi sisältää kortit
Ruutu J
Pata J
Hertta J
</pre>

<h4>Korttien järjestäminen eri kriteerein</h4>

<p>Entä jos haluaisimme välillä järjestää kortit hieman eri tavalla, esim. kaikki saman maan kortit peräkkäin? 
Luokalla voi olla vain yksi compareTo-metodi, joten joudumme muunlaisia järjestyksiä saadaksemme turvautumaan muihin keinoihin.</p>

<p>
Vaihtoehtoiset järjestämistavat toteutetaan erillisten vertailun suorittavien luokkien avulla. Korttien vaihtoehtoisten järjestyksen määräävän luokkien tulee toteuttaa <code>Comparator&lt;Kortti&gt;</code>-rajapinta. Järjestyksen määräävän luokan olio vertailee kahta parametrina saamaansa korttia. Metodeja on ainoastaan yksi compare(Kortti k1, Kortti k2), jonka tulee palauttaa negatiivinen arvo, jos kortti k1 on järjestyksessä ennen korttia k2, positiivinen arvo jos k2 on järjestyksessä ennen k1:stä ja 0 muuten.

<p>
Periaatteena on luoda jokaista järjestämistapaa varten oma vertailuluokka, esim. saman maan kortit vierekkäin vievän järjestyksen määrittelevä luokka:</p>

<pre class="sh_java">
import java.util.Comparator;

public class SamatMaatVierekkain implements Comparator&lt;Kortti&gt; {
    public int compare(Kortti k1, Kortti k2) {
        return k1.getMaa()-k2.getMaa();
    }
}
</pre>

<p>Maittainen järjestys on sama kuin kortin metodin <code>compareTo</code> maille määrittelemä järjestys eli <em>ristit ensin, ruudut toiseksi, hertat kolmanneksi, padat viimeiseksi.</em></p>

<p>Järjestäminen tapahtuu edelleen luokan Collections metodin sort avulla. Metodi saa nyt toiseksi parametrikseen järjestyksen määräävän luokan olion:</p>

<pre class="sh_java">
  ArrayList&lt;Kortti&gt; kortit = new ArrayList&lt;Kortti&gt;(); 

  kortit.add( new Kortti(3, Kortti.PATA) );
  kortit.add( new Kortti(2, Kortti.RUUTU) );
  kortit.add( new Kortti(14, Kortti.PATA) );
  kortit.add( new Kortti(12, Kortti.HERTTA) );
  kortit.add( new Kortti(2, Kortti.PATA) );

  SamatMaatVierekkain samatMaatVierekkainJarjestaja = new SamatMaatVierekkain();
  Collections.sort(kortit, samatMaatVierekkainJarjestaja ); 
  
  for (Kortti k : kortit) {
    System.out.println( k );
  }
</pre>

<p>Tulostuu:</p>

<pre>
Ruutu 2
Hertta Q
Pata 3
Pata A
Pata 2
</pre>

<p>Järjestyksen määrittelevä olio voidaan myös luoda suoraan sort-kutsun yhteydessä:</p>

<pre class="sh_java">
  Collections.sort(kortit, new SamatMaatVierekkain() ); 
</pre>
<p>

  <p>Tarkempia ohjeita vertailuluokkien tekemiseen <a href="http://leepoint.net/notes-java/data/collections/comparators.html">täällä</a></p>

<p>Tee nyt luokka Comparator-rajapinnan toteuttava luokka <code>SamatMaatVierekkainArvojarjestykseen</code>
jonka avulla saat kortit muuten samanlaiseen järjestykseen kuin edellisessä esimerkissä paitsi, että saman maan kortit järjestyvät arvon mukaiseesti.
</p>

<h4>Käden järjestäminen maittain</h4>

<p>Lisää luokalle <code>Kasi</code> metodi <code>public void jarjestaMaittain()</code> jota kutsumalla käden sisällä olevat kortit menevät edellisen tehtävän vertailijan määrittelemään järjestykseen. Järjestämisen jälkeen kortit tulostuvat järjestyksessä:</p>

<pre class="sh_java">
  Kasi kasi = new Kasi();

  kasi.lisaa( new Kortti(12, Kortti.HERTTA) );
  kasi.lisaa( new Kortti(4, Kortti.PATA) );
  kasi.lisaa( new Kortti(2, Kortti.RUUTU) );
  kasi.lisaa( new Kortti(14, Kortti.PATA) );
  kasi.lisaa( new Kortti(7, Kortti.HERTTA) );
  kasi.lisaa( new Kortti(2, Kortti.PATA) );

  kasi.jarjestaMaittain(); 

  kasi.tulosta();
</pre>

<p>Tulostuu:</p>

<pre>
Ruutu 2
Hertta 7
Hertta Q
Pata 2
Pata 4
Pata A
</pre>

</div>

<h2>Collections</h2>

    <p>The class library <code><a href="http://java.sun.com/javase/6/docs/api/java/util/Collections.html" target="_blank">Collections</a></code> is Java's general-purpose library for collection classes. As we can see, <code>Collections</code> provides methods to sort objects either through the interface <code>Comparable</code> or <code>Comparator</code>. In addition to sorting, we can use this class library to retrieve the minimum and maximum values (through the methods <code>min</code> and <code>max</code>, respectively), retrieve a specific value (<code>binarySearch</code> method), or reverse the list (<code>reverse</code> method).</p>

    <h3>Search</h3>

    <p>The Collections class library provides a made-up binary search functionality. The method <code>binarySearch()</code> returns the index of our searched key, if this is found. If the key is not found, the search algorithm returns a negative value. The method <code>binarySearch()</code> makes use of the Comparable interface to retieve objects. If the object's <code>compareTo()</code> method returns the value 0, i.e. if it is the same object, the key is considered found.</p>

    <p>Our ClubMember class compares people's heights in its <code>compareTo()</code> method, i.e. we look for club members whose height is the same while we parse our list.</p>

<pre class="sh_java">
    List&lt;ClubMember&gt; clubMembers = new ArrayList&lt;ClubMember&gt;();
    clubMembers.add(new ClubMember("mikael", 182));
    clubMembers.add(new ClubMember("matti", 187));
    clubMembers.add(new ClubMember("joel", 184));

    Collections.sort(clubMembers);

    ClubMember wanted = new ClubMember("Name", 180);
    int index = Collections.binarySearch(clubMembers, wanted);
    if(index &gt;= 0) {
        System.out.println("A person who is 180 centimiters tall was found at index " + index);
        System.out.println("name: " + clubMembers.get(index).getName());
    }

    wanted = new ClubMember("Name", 187);
    int index = Collections.binarySearch(clubMembers, wanted);
    if(indeksi &gt;= 0) {
        System.out.println("A person who is 187 centimiters tall was found at index " + index);
        System.out.println("name: " + clubMembers.get(index).getName());
    }
</pre>

    <p>The print output is the following:</p>

<pre>
A person who is 187 centimiters tall was found at index 2
name: matti
</pre>

    <p>Notice that we also called the method <code>Collections.sort()</code>, in our example. This is because binary search cannot be done if our table or list are not already sorted up.</p>







<div class="tehtavat">

<h3>Mäkihyppy</h3>

        <p>Harjoitellaan taas ohjelman rakenteen omatoimista suunnittelua. Käyttöliittymän ulkomuoto ja vaadittu toiminnallisuus on määritelty ennalta, rakenteen saat toteuttaa vapaasti.</p>

<p><b>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. Älä myöskään käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</b></p>

        <p>Mäkihyppy on suomalaisille erittäin rakas laji, jossa pyritään hyppäämään hyppyrimäestä mahdollisimman pitkälle mahdollisimman tyylikkäästi. Tässä tehtävässä tulee toteuttaa simulaattori mäkihyppykilpailulle.</p>

        <p>Simulaattori kysyy ensin käyttäjältä hyppääjien nimiä. Kun käyttäjä antaa tyhjän characterStringn (eli painaa enteriä) hyppääjän nimeksi siirrytään hyppyvaiheeseen. Hyppyvaiheessa hyppääjät hyppäävät yksitellen käänteisessä pistejärjestyksessä. Hyppääjä jolla on vähiten pisteitä kerättynä hyppää aina kierroksen ensimmäisenä, toiseksi vähiten pisteitä omaava toisena jne, ..., eniten pisteitä kerännyt viimeisenä.</p>

        <p>Hyppääjän yhteispisteet lasketaan yksittäisten hyppyjen pisteiden summana. Yksittäisen hypyn pisteytys lasketaan hypyn pituudesta (käytä satunnaista kokonaisluku väliltä 60-120) ja tuomariäänistä. Jokaista hyppyä kohden annetaan 5 tuomariääntä (satunnainen luku väliltä 10-20). Tuomariääniä laskettaessa otetaan huomioon vain kolme keskimmäistä ääntä: pienintä ja suurinta ääntä ei oteta huomioon. Esimerkiksi jos Mikael hyppää 61 metriä ja saa tuomariäänet 11, 12, 13, 14 ja 15, on hänen hyppynsä yhteispisteet 100.</p>

        <p>Kierroksia hypätään niin monta kuin ohjelman käyttäjä haluaa. Kun käyttäjä haluaa lopettaa tulostetaan lopuksi kilpailun lopputulokset. Lopputuloksissa tulostetaan hyppääjät, hyppääjien yhteispisteet ja hyppääjien hyppäämien hyppyjen pituudet. Lopputulokset on järjestetty hyppääjien yhteispisteiden mukaan siten, että eniten pisteitä kerännyt on ensimmäinen.</p>

        <p>Tehtävän tekemisessä on hyötyä <em>muun muassa</em> metodeista <code>Collections.sort</code> ja <code>Collections.reverse</code>. Kannattaa aluksi hahmotella minkälaisia luokkia ja olioita ohjelmassa voisi olla. On myös hyvä pyrkiä tilanteeseen, jossa käyttöliittymäluokka on ainut luokka joka kutsuu tulostuskomentoa.</p>

<pre>
Kumpulan mäkiviikot

Syötä kilpailun osallistujat yksi kerrallaan, tyhjällä characterStringlla siirtyy hyppyvaiheeseen.
  Osallistujan nimi: <font color="red">Mikael</font>
  Osallistujan nimi: <font color="red">Mika</font>
  Osallistujan nimi:

Kilpailu alkaa!

Kirjoita "hyppaa" niin hypätään, muuten lopetetaan: <font color="red">hyppaa</font>

1. kierros

Hyppyjärjestys:
  1. Mikael (0 pistettä)
  2. Mika (0 pistettä)

Kierroksen 1 tulokset
  Mikael
    pituus: 95
    tuomaripisteet: [15, 11, 10, 14, 14]
  Mika
    pituus: 112
    tuomaripisteet: [14, 12, 18, 18, 17]

Kirjoita "hyppaa" niin hypätään, muuten lopetetaan: <font color="red">hyppaa</font>

2. kierros

Hyppyjärjestys:
  1. Mikael (134 pistettä)
  2. Mika (161 pistettä)

Kierroksen 2 tulokset
  Mikael
    pituus: 96
    tuomaripisteet: [20, 19, 15, 13, 18]
  Mika
    pituus: 61
    tuomaripisteet: [12, 11, 15, 17, 11]

Kirjoita "hyppaa" niin hypätään, muuten lopetetaan: <font color="red">hyppaa</font>

3. kierros

Hyppyjärjestys:
  1. Mika (260 pistettä)
  2. Mikael (282 pistettä)

Kierroksen 3 tulokset
  Mika
    pituus: 88
    tuomaripisteet: [11, 19, 13, 10, 15]
  Mikael
    pituus: 63
    tuomaripisteet: [12, 19, 19, 12, 12]

Kirjoita "hyppaa" niin hypätään, muuten lopetetaan: <font color="red">lopeta</font>

Kiitos!

Kilpailun lopputulokset:
Sija    Nimi
1       Mikael (388 pistettä)
          hyppyjen pituudet: 95 m, 96 m, 63 m
2       Mika (387 pistettä)
          hyppyjen pituudet: 112 m, 61 m, 88 m
</pre>



  <p><strong>Huom1:</strong> Testien kannalta on oleellista että <em>käyttöliittymä</em> toimii kuten yllä kuvattu, esim. rivien alussa olevien välilyöntien määrän on oltava oikea. <strong>Rivien alussa oleva tyhjä pitää tehdä välilyönneillä</strong>, testit eivät toimi jos tyhjä on tehty tabulaattoreilla. Ohjelman tulostamat tekstit kannattaneekin copypasteta ohjelmakoodiin joko tehtävänannosta tai testien virheilmoituksista. <em>Tehtävä on neljän yksittäisen tehtäväpisteen arvoinen.</em></p>

<p><strong>Huom2:</strong> älä käytä luokkein nimissä skandeja, ne saattavat aiheuttaa ongelmia testeihin!</p>

  <p><strong>Ohjelman tulee käynnistyä kun tehtäväpohjassa oleva main-metodi suoritetaan, muistutuksena vieltä, että tehtävässä saa luoda vain yhden Scanner-olion.</strong></p>

</div>

    <p>Screencast jossa tehdään viikon 1 ja 2 ydinasioita hyödyntävä hieman isompi sovellus:</p>

<a href="http://www.youtube.com/watch?feature=player_embedded&v=LFxtwce8chM" height="300" target="_blank"><img src="img/youtube.jpg"/></a>

<!--
    <p><iframe allowfullscreen="" frameborder="0"  height="450" width="700" src="http://www.youtube.com/embed/LFxtwce8chM"></iframe></p>
-->



<div class="tyhja"></div>

<div class="viikkoraja">Viikko 3</div>

<h2>Single Responsibility Principle</h2>

    <p>When we design bigger programs, we often reason about what class has do deal with what task. If we delegate the implementation of the whole program to one class, the result is inevitably chaos. A sector of software design, <em>object-oriented design</em>, includes the <em>Single Responsibility Principle</em>, which we should follow.</p>

    <p>The Single Responsibility Principle states that each class should have only one clear role. If the class has got one clear role, modifying that role is easy, and only one class will have to be modified. <em>Each class should have only one reason to be modified.</em>.</p>

    <p>Let us focus on the following class <code>Worker</code>, which has got methods to calculate his salary and to report his working hours.</p>

<pre class="sh_java">
public class Worker {
    // object variables

    // worker's constructor and methods

    public double calculateSalary() {
        // the logic concerning salary count
    }

    public String reportHours() {
        // the logic concerning working hours bookkeeping
    }
}
</pre>

    <p>Even if the examples above do not show the concrete implementations, an alarm should go off. Our <code>Worker</code> class has got at least three different responsibilities. It represents a worker, it performes the role of a salary calculator, and the role of a working hour bookkeping system by reporting working hours. The class above should be split into three: one should represent the worker, another should represent the salary calculator, and the third should deal with time bookkeeping.</p>

<pre class="sh_java">
public class Woker {
    // object variables

    // worker's constructor and methods
}
</pre>

<pre class="sh_java">
public class SalaryCalculator {
    // object variables

    // methods for salary count

    public double calculateSalary(Person person) {
        // salary calculation logic
    }
}
</pre>


<pre class="sh_java">
public class TimeBookkeeping {
    // object variables

    // methods concerning time bookkeeping

    public String createHourReport(Person person) {
        // working hours bookeeping logic
    }
}
</pre>

    <p><em>Each variable, each code raw, each method, each class, and each program should have only one responsibility. Often a "better" program stucture is clear to the programmer only once the program is implemented. This is completely acceptable: even more important it is that we always try to change a program to make it clearer. <strong>Always refactor -- i.e. always improve your program when it is needed!</strong></em></p>


<h2>Organising Classes into Packages</h2>

    <p>When we design and implement bigger programs, the number of classes rapidly grows. When the number of classes grows, remembering their functionality and methods becomes more difficult. Giving sensible names to classes helps to remember their funcitonality. In addition to giving sensible names, it is good to split the source code files into packages according to their functionality, use, and other logical reasons. In fact, the <em>packages</em> are but folders we use to organise our source code files. Directories are often called folders, both in windows and colloqually. We will use the term directory, anyway.</p>

    <p>Programming environments provide made-up tools for package management. So far, we have been creating classes and interfaces only in the <code>default package</code> of the <code>Source Packages</code> partition. In NetBeans, we can create a new package by clicking on <code>Source Packages</code>, and choosing <code>New -&gt; Java Package...</code>. In the created package, we can create classes in the same way as we do in the <code>default package</code>.</p>

  <p>You can read the name of the package that contains a certain class is visible at the beginning of the source code files in the sentence <code>package <em>packageName</em></code> before the other statements. For instance, the below class <code>Implementation</code> is contained in the package <code>library</code>.</p>

<pre class="sh_java">
package library;

public class Implementation {

    public static void main(String[] args) {
        System.out.println("Hello packageworld!");
    }
}
</pre>

  <p>Packages can contain other packages. For instance, the package definition <code>package library.domain</code> means that the package <code>domain</code> is contained in the package <code>library</code>. By placing packages into other packages, we design the hierachy of classes and interfaces. For instance, all Java's classes are located in packages that are contained in the package <code>java</code>. The package name <code>domain</code> is often used to represent the storage location of the classes which deal with concepts specific for the domain. For instance, the class <code>Book</code> could be stored in the package <code>library.domain</code> because it represents a concept specific of the library.</p>

<pre class="sh_java">
package library.domain;

public class Book {
    private String name;

    public Book(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}
</pre>

  <p>We can uses the classes stored in our packages through the <code>import</code> statement. For instance, the class <code>Implementation</code>, which is contained in the package <code>library</code> could make use of a class stored in <code>library.domain</code> through the assignment <code>import kirjasto.domain.Book</code>.</p>


<pre class="sh_java">
package librart;

import library.domain.Book;

public class Implementation {

    public static void main(String[] args) {
        Book book = new Book("The ABC of Packages!");
        System.out.println("Hello packageworld: " + book.getName());
    }
}
</pre>

<pre>
Hello packageworld: The ABC of Packages!
</pre>

    <p>The import statements are defined in our source code file after the package statement but before the class statement. There can be many of them -- for instance, when we want to use different classes. Java's made-up classes are usually stored in <code>java</code> package child packages. Hopefully, the statements which appear at the beginning of our classes -- such as <code>import java.util.ArrayList</code> and <code>import java.util.Scanner;</code> -- are starting to look more meaningful now.</p>

    <p>From now on, in <em>all</em> our excercises we will use packages. Next, we will create our first packages ourselves.</p>

<div class="tehtavat" id="viikko9">

<NEXTWEEK></NEXTWEEK>

  <h3>Ensimmäisiä pakkauksia</h3>

  <h4>Käyttöliittymä-rajapinta</h4>

  <p>Luo projektipohjaan pakkaus <code>mooc</code>. Rakennetaan tämän pakkauksen sisälle sovelluksen toiminta. Lisää sovellukseen pakkaus <code>ui</code> (tämän jälkeen pitäisi olla käytössä pakkaus <code>mooc.ui</code>), ja lisää sinne rajapinta <code>Kayttoliittyma</code>.</p>

  <p>Rajapinnan <code>Kayttoliittyma</code> tulee määritellä metodi <code>void paivita()</code>. </p>

 <h4>Tekstikäyttöliittymä</h4>

<p>
Luo samaan pakkaukseen luokka <code>Tekstikayttoliittyma</code>, joka toteuttaa rajapinnan <code>Kayttoliittyma</code>. Toteuta luokassa <code>Tekstikayttoliittyma</code> rajapinnan <code>Kayttoliittyma</code> vaatima metodi <code>public void paivita()</code> siten, että sen ainut tehtävä on characterStringn "<code>Päivitetään käyttöliittymää</code>"-tulostaminen <code>System.out.println</code>-metodikutsulla.</p>

  <h4>Sovelluslogiikka</h4>

  <p>Luo tämän jälkeen pakkaus <code>mooc.logiikka</code>, ja lisää sinne luokka <code>Sovelluslogiikka</code>. Sovelluslogiikan APIn tulee olla seuraavanlainen.</p>

<p>
  <ul>
    <li><code>public Sovelluslogiikka(Kayttoliittyma kayttoliittyma)</code></li>Sovelluslogiikka-luokan konstruktori. Saa parametrina Kayttoliittyma-rajapinnan toteuttavan luokan. Huom: jotta sovelluslogiikka näkisi rajapinnan, on sen "importoitava" se, eli tarvitset tiedoston alkuun rivin <code>import mooc.ui.Kayttoliittyma;</code> <br/>
    <li><code>public void suorita(int montaKertaa)</code></li> Tulostaa <code>montaKertaa</code>-muuttujan määrittelemän määrän characterStringa "Sovelluslogiikka toimii". Jokaisen "Sovelluslogiikka toimii"-tulostuksen jälkeen tulee kutsua konstruktorin parametrina saadun rajapinnan <code>Kayttoliittyma</code>-toteuttaman olion määrittelemää <code>paivita()</code>-metodia.<br/>
  </ul>
</p>

  <p>Voit testata sovelluksen toimintaa seuraavalla pääohjelmaluokalla.</p>

<pre class="sh_java">
import mooc.logiikka.Sovelluslogiikka;
import mooc.ui.Kayttoliittyma;
import mooc.ui.Tekstikayttoliittyma;

public class Main {

    public static void main(String[] args) {
        Kayttoliittyma kayttoliittyma = new Tekstikayttoliittyma();
        new Sovelluslogiikka(kayttoliittyma).suorita(3);
    }
}
</pre>

  <p>Ohjelman tulostuksen tulee olla seuraava:</p>

<pre>
Sovelluslogiikka toimii
Päivitetään käyttöliittymää
Sovelluslogiikka toimii
Päivitetään käyttöliittymää
Sovelluslogiikka toimii
Päivitetään käyttöliittymää
</pre>

</div>

    <h3>A Concrete Directory Construction</h3>

    <p>All the projects which are can be seen are stored in your computer <em><a href="http://en.wikipedia.org/wiki/File_system" target="_blank">file system</a></em>. Each project has got its own directory (folder) which contains the directories and files of the project.</p>

    <p>In the project directory <code>src</code> there is the program source code. If a class package is a library, it is located in the directory <code>library</code> of the project source code directory <code>src</code>. If you are interested in it, it is possible to have a look at the concrete project structure in NetBeans, by reaching the <em>Files</em> tab which is next to the <em>Projects</em> tab. If you can't see the <em>Files</em> tab, you can display it by choosing <em>Files</em> from the <em>Window</em> menu.</p>

    <p>Application development is usually done through the <em>Projects</em> tab, where NetBeans has hidden the project files which the programmer doesn't have to care about.</p>

    <h3>Visibility Definitions and Packages</h3>

    <p>We have already managed to know two visibility definitions. The method and variables with the visibility definition <code>private</code> are visible only inside the class that defines them. They cannot be used outside the class. Differently, the method and variables visibility definition <code>public</code> are available to any class.</p>

<pre class="sh_java">
package library.ui;

public class UserInterface {
    private Scanner reader;

    public Kayttoliittyma(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        printTitle();

        // more functionality
    }

    private void printTitle() {
        System.out.println("***********");
        System.out.println("* LIBRARY *");
        System.out.println("***********");
    }
}
</pre>

    <p>The object constructor and <code>start</code> method of the above class <code>UserInterface</code> can be called from whatever program. The method <code>printTitle</code> and the variable <code>reader</code> can be used only inside their class.</p>

    <p>When want to assign package visibility to a variable or a method, we do not need to use any prefix. We can modify the example above assigning package visibility to the method <code>printTitle</code>.</p>

<pre class="sh_java">
package library.ui;

public class UserInterface {
    private Scanner reader;

    public Kayttoliittyma(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        printTitle();

        // more functionality
    }

    void printTitle() {
        System.out.println("***********");
        System.out.println("* Library *");
        System.out.println("***********");
    }
}
</pre>

    <p>Now, the classes <em>inside the same package</em> can use the method <code>printTitle</code>.

<pre class="sh_java">
package library.ui;

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner reader = new Scanner(System.in);
        UserInterface userInterface = new UserInterface(reader);

        userInterface.printTitle(); // it works!
    }
}
</pre>

    <p>If the class is in a different package, the method <code>printTitle</code> can't be used.</p>

<pre class="sh_java">
package library;

import java.util.Scanner;
import library.ui.UserInterface;

public class Main {

    public static void main(String[] args) {
        Scanner reader = new Scanner(System.in);
        UserInterface userInterface = new UserInterface(reader);

        userInterface.printTitle(); // it doesn't work	!
    }
}
</pre>

<h2>Many Interfaces, and Interface Flexibility</h2>

    <p>Last week we were introduced to interfaces. An interface defines one or more methods which have to be implemented by the class which implement the interface. The interfaces can be stored into packages like any other class. For instance, the interface <code>Identifiable</code> below is located in the package <code>application.domain</code>, and it defines that the classes which implement it have to implement the method <code>public String getID()</code>.</p>

<pre class="sh_java">
package application.domain;

public interface Identifiable {
    String getID();
}
</pre>

    <p>The class makes use of the interface through the keyword <code>implements</code>. The class <code>Person</code>, which implements the <code>Idenfifiable</code> interface. The <code>getID</code>of Person class always returns the person ID.</p>

<pre class="sh_java">
package application.domain;

public class Person implements Identifiable {
    private String name;
    private String id;

    public Person(String name, String id) {
        this.name = name;
        this.henkilotunnus = id;
    }

    public String getName() {
        return this.name;
    }

    public String getPersonID() {
        return this.id;
    }

    @Override
    public String getID() {
        return getPersonID();
    }

    @Override
    pulic toString(){
        return this.name + " ID: " +this.id; 
    }
}
</pre>


    <p>Interface strength is that they are also <em>types</em>. All the object which come from classes that implement an interface also have that interface's type. This effictively helps us to build our applications.</p>

    <p>We creae the class <code>Register</code>, which we can use to search for people against their names. In addition to retrieve single people, <code>Register</code> provides a method to retrieve a list with all the people.</p>

<pre class="sh_java">
public class Register {
    private HashMap&lt;String, Identifiable&gt; registered;

    public Register() {
        this.registered = new HashMap&lt;String, Identifiable&gt;();
    }

    public void add(Identifiable toBeAdded) {
        this.registered.put(toBeAdded.getID(), toBeAdded);
    }

    public Identifiable get(String id) {
        return this.registered.get(id);
    }

    public List&lt;Identifiable&gt; getAll() {
        return new ArrayList&lt;Identifiable&gt;(registered.values());
    }
}
</pre>

<p>Using the register is easy.</p>

<pre class="sh_java">
Register personnel = new Register();
personnel.add( new Person("Pekka", "221078-123X") );
personnel.add( new Person("Jukka", "110956-326B") );

System.out.println( personnel.get("280283-111A") );

Person found = (Person) register.get("110956-326B");
System.out.println( found.getName() );
</pre>

<p>Because the people are recorded in the register as <code>Identifiable</code>, we have to change back their type if we want to deal with people through those methods which are not defined in the interface. This is what happens in the last two lines.</p>

    <p>What about if we wanted an operation which returns the people recorded in our register sorted according to their ID?</p>

    <p>One class can implement various different interfaces, and our <code>Person</code> class can implement <code>Comparable</code> in addition to <code>Identifiable</code>. When we implement various different interfaces, we separate them with a comma (<code>public class ... implements <em>FirstInterface</em>, <em>SecondInterface</em> ...</code>). When we implement many interfaces, we have to implement all the methods required by all the interfaces. Below, we implement the interface <code>Comparable</code> in the class <code>Person</code>.</p>

<pre class="sh_java">
package application.domain;

public class Person implements Identifiable, Comparable&lt;Person&gt; {
    private String name;
    private String id;

    public Person(String name, String id) {
        this.name = name;
        this.id = id;
    }

    public String getName() {
        return this.name;
    }

    public String getPersonID() {
        return this.id;
    }

    @Override
    public String getID() {
        return getPersonID();
    }

    @Override
    public int compareTo(Person another) {
        return this.getID().compareTo(toinen.getID());
    }
}
</pre>

    <p>Now we can add the method sortAndGetEverything to the register:</p>

<pre class="sh_java">
    public List&lt;Identifiable&gt; sortAndGetAll() {
        ArrayList&lt;Identifiable&gt; all = new ArrayList&lt;Identifiable&gt;(registered.values());;
        Collections.sort(all);
        return all;
    }
</pre>

<p>However, we notice that our solution does not work. Because the people are recorded into the register as if their type was <code>Identifiable</code>, Person must implement the interface <code>Comparable&lt;Identifiable&gt;</code> so that our register could sort people with its method <code>Collections.sort()</code>. This means we have to modify Person's interface:</p>

<pre class="sh_java">
public class Person implements Identifiable, Comparable&lt;Identifiable&gt; {
    // ... 

    @Override
    public int compareTo(Identifiable another) {
        return this.getID().compareTo(toinen.getID());
    }
}
</pre>

<p>Now our solution works!</p>

<p>Our Register is unaware of the real type of the objects we record. We can use the class Register to record objects of different type thank Person, as long as the object class implements the interface <code>Identifiable</code>. For instance, below we use the register to manage shop sales:</p>

<pre class="sh_java">
public class Sale implements Identifiable {
    private String name;
    private String barcode;
    private int stockBalance;
    private int price;

    public Tuote(String name, String barcode) {
        this.name = name;
        this.barcode = barcode;
    }

    public String getID() {
        return barcode;
    }

    // ...
}

Register products = new Register();
products.add( new Product("milk", "11111111") );
products.add( new Product("yogurt", "11111112") );
products.add( new Product("cheese", "11111113") );

System.out.println( products.get("99999999") );

Product product = (Product)products.get("11111112");
product.increaseStock(100);
product.changePrice(23);
</pre>

<p>The class <code>Register</code> is quite universal now that is not dependent on concrete classes. Whatever class which implements the interface <code>Identifiable</code> is compatible with Register. The method <code>get
Eli olemme tehneet luokasta <code>Rekisteri</code> melko yleiskäyttöisen pitämällä sen riippumattomana konkreettisista luokista. Mikä tähänsa luokka, joka toteuttaa rajapinnan <code>Tunnistettava</code> on rekisterin kanssa käyttökelpoinen. However, the metodin <code>sortAndGetEverything</code> can only work if we implement the interface Comparable&lt;Identifiable&gt;.</p>



    <p>We create now the class <code>PersonRegister</code> which returns people using the interface <code>Identifiable</code>. In addition to retrieve individuals, <code>PersonRegister</code> provides a method to return a list with all the people.</p>

<pre class="sh_java">
public class PersonRegister {
    private HashMap&lt;String, Person&gt; people;

    public PersonRegister(HashMap&lt;String, Person&gt; people) {
        this.people = people;
    }

    public void addPerson(Person person) {
        this.people.put(person.getID(), person);
    }

    public void getPersonByID(Identifiable identifiable) {
        this.people.get(identifiable.getID());
    }

    public List&lt;Person&gt; getPerson() {
        return new ArrayList&lt;Person&gt;(people.values());
    }
}
</pre>

    <p>What about if we wanted to order our list in alphabetic order?</p>


    <p>One class can implement various different interfaces; in addition to <code>Identifiable</code> the class <code>Person</code> can implement the interface we saw last week, <code>Comparable</code>. We can implement different interfaces by deviding them with a comma (<code>public class ... implements <em>FirstInterface</em>, <em>SecondInterface</em> ...</code>). When we implement many interfaces, we also have to implement all the methods they require. In the following example, <code>Person</code> implements the interface <code>Comparable</code>.</p>

<pre class="sh_java">
package application.domain;

public class Person implements Identifiable, Comparable&lt;Person&gt; {
    private String name;
    private String id;

    public Person(String name, String id) {
        this.name = name;
        this.id = id;
    }

    public String getName() {
        return this.name;
    }

    public String getPersonID() {
        return this.id;
    }

    @Override
    public String getID() {
        return getPersonID();
    }

    @Override
    public int compareTo(Person another) {
        return this.name.compareTo(another.getName());
    }
}
</pre>

    <p>Now we can extend our the List method of PersonRegister in the following way:</p>

<pre class="sh_java">
    public List&lt;Person&gt; getPerson() {
        ArrayList&lt;Person&gt; people = new ArrayList&lt;Person&gt;(people.values());
        Collections.sort(people);
        return people;
    }
</pre>




    <h3>Check-out Example</h3>

    <p>In the following section, we can reason about the product identification operations of a market check-out. We can suppose that the products have a barcode, a name, and a price. A <code>Product</code> object implements the already defined interface <code>Identifiable</code>.</p>

<pre class="sh_java">
package application.domain;

public class Tuote implements Identifiable {
    private String barcode;
    private String name;
    private int price;

    public Tuote(String barcode, String name, int price) {
        this.barcode = barcode;
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return this.name;
    }

    public int getPrice() {
        return this.price;
    }

    @Override
    public String getID() {
        return this.barcode;
    }
}
</pre>

    <p>Below, we implement <code>BarcodeReader</code> which reads objects and turns them into products. The barcode reader has to identify products thanks to the interface <code>Identifiable</code>. We can implement the class <code>BarcodeReader</code> so that it will include a HashMap, which retrieves products against their ID. The BarcodeReader is a part of our application logic, and we store it into the package <code>application.logic</code>.</p>

<pre class="sh_java">
package application.logic;

public class BarcodeReader {
    private HashMap&lt;String, Product&gt; products;

    public BarcodeReader(HashMap&lt;String, Product&gt; products) {
        this.products = products;
    }

    public Tuote tunnista(Identifiable identifiable) {
        return this.products.get(identifiable.getID());
    }
}
</pre>

    <p>A BarcodeReader object returns a <code>Product</code> object is its barcode is found in the BarcodeReader HashMap. With the following example, we create a check-out which uses the barcode reader to add products to the purchase list. The class has got the method <code>public void buy</code> which is given an instance of <code>Identifiable</code> as parameter. The purchase adds to the purchase list the objects which are recognised by the barcode reader. If an object is not recognised, nothing happens. The method <code>printPurchases</code> prints the name of the purchased products.</p>

<pre class="sh_java">
package application.domain;

public class Cashout {
    private BarcodeReader reader;
    private List&lt;Product&gt; products;

    public Cashout(BarcodeReader barcodeReader) {
        this.reader = barcodeReader;
        this.products = new ArrayList&lt;Product&gt;();
    }

    public void osta(Identifiable identifiable) {
        Product identified = this.reader.identify(identifiable);
        if (identified == null) {
            return;
        }

        this.products.add(identified);
    }

    public void printPurchases() {
        for(Product product: this.products) {
            System.out.println(product.getName());
        }
    }
}
</pre>

    <p>At this point we notice that it is extremely unconvenient to read products if they are printed in succession according to when they were added. We modify the printout to list the products in aplphabetic order. We add the interface <code>Comparable</code> to <code>Product</code> to sort our products in alphabetic order.</p>

<pre class="sh_java">
package application.domain;

public class Product implements Identifiable, Comparable&lt;Tuote&gt; {
    private String barcode;
    private String name;
    private int price;

    public Tuote(String barcode, String name, int price) {
        this.barcode = barcode;
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return this.name;
    }

    public int getPrice() {
        return this.price;
    }

    @Override
    public String getID() {
        return this.barcode;
    }

    @Override
    public int compareTo(Product product) {
        return this.name.compareTo(product.getName());
    }
}
</pre>

    <p>We can still modify our cashout implementation so that our products were sorted if need be. Notice that the products only have to be sorted when products <em>are purchased</em>. A purchase is the only situation where the order of the products in the list can possibly change. If we do so, the purchases are always sorted when we call the method <code>printPurchases</code>.</p>

<pre class="sh_java">
package application.domain;

public class Checkout {
    private BarcodeReder reader;
    private List&lt;Product&gt; products;

    public Kassa( BarcodeReder BarcodeReader) {
        this.reader = BarcodeReader;
        this.products = new ArrayList&lt;Product&gt;();
    }

    public void buy(Identifiable identifiable) {
        Tuote identified = this.reader.identify(identifiable);
        if (identified == null) {
            return;
        }

        this.products.add(identified);
        Collections.sort(this.products);
    }

    public void printPurchases() {
        for(Product product: this.products) {
            System.out.println(product.getName());
        }
    }
}
</pre>


<div>
<big><big><b>Muutama NetBeans-vihje</b></big></big>	

<ul>
<li> Kaikki NetBeans-vihjeet löytyvät <a href="../ohpe/netbeans.html">täältä</a> </li>
<p></p>

<li> <b>Implement all abstract methods</b>

<p>
Oletetaan että ohjelmassasi on rajapinta <code>Rajapinta</code>, ja olet tekemässä rajapinnan toteuttavaa luokkaa <code>Luokka</code>. Joudut näkemään hieman vaivaa kirjoittaessasi toteuttavaan luokkaan rajapinnan määrittelemien metodien esittelyrivit.
</p>

<p>On kuitenkin mahdollista pyytää NetBeansia täydentämään automaattisesti metodirungot toteuttavalle luokalle. Kun olet määritellyt luokan toteuttavan rajapinnan, eli kirjoittanut</p>

<pre class="sh_java">
public class Luokka implements Rajapinta {
}
</pre>

<p>NetBeans värjää luokan nimen punaisella. Mene rivin vasemmassa reunassa olevan lamppusymbolin kohdalle, klikkaa ja valitse <em>Implement all abstract methods</em> ja metodirungot ilmestyvät koodiin!</p>

</li>

<li> <b>Clean and Build</b>

<p>
Tietyissä tilanteissa NetBeans saattaa mennä sekaisin ja yrittää ajaa koodista versiota johon ei ole huomioitu kaikkia koodiin kirjoitettuja muutoksia. Yleensä huomaat tilanteen siten, että jotain "outoa" vaikuttaa tapahtuvan. Ongelman korjaa usein <em>Clean and build</em> -operaation suorittaminen. Operaatio löytyy Run-valikosta ja sen voi suorittaa myös painamalla <em>harja ja vasara</em> -symbolia. Clean and build poistaa koodista olemassa olevat käännetyt versiot ja tekee uuden käännöksen.
</p>

</li>
</ul>
</div>

<div class="tehtavat">

  <h3>Muuttaminen</h3>

  <p>Muuttokuormaa pakattaessa esineitä lisätään muuttolaatikoihin siten, että tarvittujen muuttolaatikoiden määrä on mahdollisimman pieni. Tässä tehtävässä simuloidaan esineiden pakkaamista muuttolaatikoihin. Jokaisella esineellä on tilavuus, ja muuttolaatikoilla on maksimitilavuus.</p>


  <h4>Tavara ja Esine</h4>

  <p>Muuttomiehet siirtävät tavarat myöhemmin rekka-autoon (ei toteuteta tässä), joten toteutetaan ensin kaikkia esineitä ja laatikoita kuvaava <code>Tavara</code>-rajapinta.</p>

  <p>Tavara-rajapinnan tulee määritellä metodi <code>int getTilavuus()</code>, jonka avulla tavaroita käsittelevät saavat selville kyseisen tavaran tilavuuden. Toteuta rajapinta <code>Tavara</code> pakkaukseen <code>muuttaminen.domain</code>.</p>

  <p>Toteuta seuraavaksi pakkaukseen <code>muuttaminen.domain</code> luokka <code>Esine</code>, joka saa konstruktorin parametrina esineen nimen (String) ja esineen tilavuuden (int). Luokan tulee toteuttaa rajapinta <code>Tavara</code>.</p>

  <p>Lisää luokalle <code>Esine</code> myös metodit <code>public String getName()</code> ja korvaa metodi <code>public String toString()</code> siten että se tuotta characterStringja muotoa "<code>nimi (tilavuus dm^3)</code>". Esineen pitäisi toimia nyt jotakuinkin seuraavasti</p>

<pre class="sh_java">
    Tavara esine = new Esine("hammasharja", 2);
    System.out.println(esine);
</pre>

<pre>
hammasharja (2 dm^3)
</pre>

  <h4>Esine vertailtavaksi</h4>

  <p>Pakatessamme esineitä muuttolaatikkoon haluamme aloittaa pakkaamisen järjestyksessä olevista esineistä. Toteuta <code>Esine</code>-luokalla rajapinta <code>Comparable</code> siten, että esineiden <em>luonnollinen järjestys</em> on tilavuuden mukaan nouseva. Kun olet toteuttanut esineellä rajapinnan <code>Comparable</code>, tulee niiden toimia <code>Collections</code>-luokan <code>sort</code>-metodin kanssa seuraavasti.</p>


<pre class="sh_java">
    List&lt;Esine&gt; esineet = new ArrayList&lt;Esine&gt;();
    esineet.add(new Esine("passi", 2));
    esineet.add(new Esine("hammasharja", 1));
    esineet.add(new Esine("sirkkeli", 100));

    Collections.sort(esineet);
    System.out.println(esineet);
</pre>

<pre>
[hammasharja (1 dm^3), passi (2 dm^3), sirkkeli (100 dm^3)]
</pre>

  <h4>Muuttolaatikko</h4>

  <p>Toteuta tämän jälkeen pakkaukseen <code>muuttaminen.domain</code> luokka <code>Muuttolaatikko</code>. Tee aluksi muuttolaatikolle seuraavat:</p>

<p>
  <ul>
    <li><code>public Muuttolaatikko(int maksimitilavuus)</code></li>Muuttolaatikko-luokan konstruktori. Saa parametrina muuttolaatikon maksimitilavuuden.<br/>
    <li><code>public boolean lisaaTavara(Tavara tavara)</code></li> Lisää muuttolaatikkoon <code>Tavara</code>-rajapinnan toteuttaman esineen. Jos laatikkoon ei mahdu, metodi palauttaa arvon <code>false</code>. Jos tavara mahtuu laatikkoon, metodi palauttaa arvon <code>true</code>. Muuttolaatikon tulee tallettaa tavarat listaan.<br/>
  </ul>
</p>

  <p>Laita vielä  <code>Muuttolaatikko</code> toteuttamaan rajapinta <code>Tavara</code>. Metodilla <code>getTilavuus</code> tulee saada selville muuttolaatikossa olevien tavaroiden tämänhetkinen yhteistilavuus.</p>

  <h4>Esineiden pakkaaminen</h4>

  <p>Toteuta luokka <code>Pakkaaja</code> pakkaukseen <code>muuttaminen.logiikka</code>. Luokan <code>Pakkaaja</code> konstruktorille annetaan parametrina <code>int laatikoidenTilavuus</code>, joka määrittelee minkä kokoisia muuttolaatikoita pakkaaja käyttää.</p>

  <p>Toteuta tämän jälkeen luokalle metodi <code>public List&lt;Muuttolaatikko&gt; pakkaaTavarat(List&lt;Tavara&gt; tavarat)</code>, joka pakkaa tavarat muuttolaatikoihin.</p>

  <p>Tee metodista sellainen, että kaikki parametrina annetussa listassa olevat tavarat päätyvät palautetussa listassa oleviin muuttolaatikoihin. Sinun ei tarvitse varautua tilanteisiin, joissa tavarat ovat suurempia kuin pakkaajan käyttämä muuttolaatikon koko. Testit eivät välitä siitä kuinka täyteen pakkaaja täyttää muuttolaatikot.</p>

<p>Seuraavassa pakkaajan toimintaa demonstroiva esimerkki:</p>

<pre class="sh_java">
    // tavarat jotka haluamme pakata
    List&lt;Tavara&gt; tavarat = new ArrayList&lt;Tavara&gt;();
    tavarat.add(new Esine("passi", 2));
    tavarat.add(new Esine("hammasharja", 1));
    tavarat.add(new Esine("kirja", 4));
    tavarat.add(new Esine("sirkkeli", 8));

    // luodaan pakkaaja, joka käyttää tilavuudeltaan 10:n kokoisia muuttolaatikoita
    Pakkaaja pakkaaja = new Pakkaaja(10);

    // pyydetään pakkaajaa pakkaamaan tavarat laatikoihin
    List&lt;Muuttolaatikko&gt; laatikot = pakkaaja.pakkaaTavarat( tavarat );

    System.out.println("laatikoita: "+laatikot.size());

    for (Muuttolaatikko laatikko : laatikot) {
        System.out.println("  laatikossa tavaraa: "+laatikko.getTilavuus()+" dm^3");
    }
</pre>

<p>Tulostuu:</p>

<pre>
laatikoita: 2
  laatikossa tavaraa: 7 dm^3
  laatikossa tavaraa: 8 dm^3
</pre>

<p>Pakkaaja on siis pakannut tavarat kahteen laatikkoon, ensimmäiseen laatikkoon on mennyt 3 ensimmäistä tavaraa, yhteistilavuudeltaan 7, ja listan viimeinen tavara eli sirkkeli jonka tilavuus on 8 on mennyt toiseen laatikkoon. Testit eivät aseta rajoitusta pakkaajan käyttävien muuttolaatioiden määrälle, tavarat olisi siis voitu pakata vaikka jokainen eri laatikkoon, eli tuloste olisi ollut:</p>

<p>Tulostuu:</p>

<pre>
laatikoita: 4
  laatikossa tavaraa: 2 dm^3
  laatikossa tavaraa: 1 dm^3
  laatikossa tavaraa: 7 dm^3
  laatikossa tavaraa: 8 dm^3
</pre>

<p><strong>Huom:</strong> tehtävän testaamista helpottamaan kannatanee tehdä luokalle <code>Muuttolaatikko</code> esim. toString-metodi, jonka avulla voi printata laatikon sisällön.</p>

<!--

  <h4>Tehokkaampi pakkaaminen</h4>

  <p>Alla on kuvattu eräs hieman tehokkaampi pakkaustapa <em>pseudokoodina</em>, eli ohjelmointikielen tapaisena koodina. Pseudokoodia käytetään muun muassa ohjelmointikieliriippumattomaan algoritmien eli ohjelmien kuvaamiseen.</p>

<pre>
pakkaaEsineet( esineet ):
    jarjesta( esineet )

    laatikot = [] // huom, kannattaa käyttää ArrayListiä

    while esineet is not empty:
        Muuttolaatikko pakattu = pakkaaLaatikko( esineet )
        laatikot.add( pakattu )

    return laatikot

pakkaaLaatikko( esineet ):
    Muuttolaatikko laatikko = new Muuttolaatikko

    lisaaSuuria( esineet, laatikko )
    lisaaPienia( esineet, laatikko )

    return laatikko

lisaaSuuria( esineet, laatikko ):
    while esineet is not empty:
        esine = suurin( esineet )

        if lisaa ( laatikko, esine ) == false:
            return

lisaaPienia(List esineet, Muuttolaatikko laatikko):
    while esineet is not empty:
        esine = pienin( esineet )

        if lisaa ( laatikko, esine ) == false:
            return
</pre>

  <p>Muokkaa luokkaa <code>Pakkaaja</code> siten, että se toimii samoin tai paremmin kuin yllä kuvattu lähestymistapa.</p>

  <p>Metodissa <code>pakkaaEsineet</code> pakataan muuttolaatikoita niin pitkään kun <code>esineet</code>-listalla on esineitä. Muuttolaatikkoa pakattaessa algoritmi lisää laukkuun ensiksi niin paljon suurimpia esineitä kuin laatikkoon mahtuu. Kun laatikkoon ei enää mahdu suurimpia esineitä, aletaan täyttämään sitä pienimmillä esineillä.</p>

  <p>Toteutuksesta: Kun esineesi ovat järjestyksessä, suurin tavara löytyy indeksistä <code>esinelistan koko - 1</code>, pienin tavara löytyy indeksistä <code>0</code>. Älä käytä tässä <code>Collections.min</code> ja <code>Collections.max</code>-metodeja, sillä ne eivät osaa arvata että <code>ArrayList</code>-lista on jo järjestyksessä.</p>

  <p>Poista esineitä <code>esineet</code>-listalta sitä mukaa kun niitä on lisätty muuttolaatikoihin. Sinun ei tarvitse varautua tilanteisiin joissa esineet ovat suurempia kuin muuttolaatikko.</p>

  <p><em>Huom!</em> Saadaksesi pisteen tästä viimeisestä tehtävästä algoritmisi tulee toimia <em>vähintään</em> yhtä hyvin kuin yllä kuvattu algoritmi. Hyvyydellä tarkoitetaan sitä, että pakkaukseen kulunut aika tulee olla vähintään yhtä pieni kuin pseudokoodiratkaisun. Muuttolaatikkojen määrän tulee myös olla vähintään yhtä pieni.</p>

  <p>Voit käyttää seuraavaa metodia satunnaisten esineiden luomiseen.</p>

<pre class="sh_java">
    public static List&lt;Esine&gt; luoEsineet(int kpl, int maxTilavuus) {
        Random rand = new Random();

        List&lt;Esine&gt; esineet = new ArrayList&lt;Esine&gt;();
        for (int i = 0; i &lt; kpl; i++) {
            esineet.add(new Esine("hammasharja", 1 + rand.nextInt(maxTilavuus)));
        }

        return esineet;
    }
</pre>

  <p>Yllä kuvatulla algoritmilla pakkaamisen pitäisi toimia nopeasti jopa 100000 esinettä sisältävillä listoilla. Voit testata pakkaajasi nopeutta esimerkiksi seuraavasti:</p>

<pre class="sh_java">
        List&lt;Esine&gt esineet = luoEsineet(100000, 10);
        Pakkaaja pakkaaja = new Pakkaaja(50);

        long start = System.nanoTime();
        List&lt;Muuttolaatikko&gt laatikot = pakkaaja.pakkaaEsineet(esineet);
        long kulunutAika = ((System.nanoTime() - start) / 1000000);

        System.out.println("Pakkaukseen kului " + kulunutAika + " ms.");
        System.out.println("Tarvittiin " + laatikot.size() + " laatikkoa.");
</pre>

-->
</div>

<h2>Poikkeustilanteet</h2>

    <p>Poikkeustilanteet ovat tilanteita joissa ohjelman suoritus ei ole edennyt toivotusti. Ohjelma on saattanut esimerkiksi kutsua <em>null</em>-viitteeseen liittyvää metodia, jolloin käyttäjälle <em>heitetään</em> poikkeus <code>NullPointerException</code>. Jos yritämme hakea taulukon ulkopuolella olevaa indeksiä, käyttäjälle heitetään poikkeus <code>IndexOutOfBoundsException</code>. Kaikki poikkeukset ovat tyyppiä <code>Exception</code>.</p>

    <p>Poikkeukset käsitellään <code>try { } catch (Exception e) { }</code> -lohkorakenteella. Avainsanan <code>try</code> aloittaman lohkon sisällä on <em>mahdollisesti</em> poikkeuksen heittävä ohjelmakoodi. Avainsanan <code>catch</code> aloittaman lohkon sisällä taas määritellään mitä tehdään jos try-lohkossa suoritettavassa koodissa tapahtuu poikkeus. Catch-lauseelle määritellään kiinniotettavan poikkeuksen tyyppi (<code>catch (Exception e)</code>).</p>

<pre class="sh_java">
    try {
        // poikkeuksen mahdollisesti heittävä ohjelmakoodi
    } catch (Exception e) {
        // lohko johon päädytään poikkeustilanteessa
    }
</pre>

    <p>characterStringn numeroksi muuttava <code>Integer</code>-luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Integer.html#parseInt(java.lang.String)" target="_blank">parseInt</a></code>-metodi heittää poikkeuksen <code>NumberFormatException</code> jos sille parametrina annettu characterString ei ole muunnettavissa numeroksi. Toteutetaan ohjelma, joka yrittää muuntaa käyttäjän syöttämän characterStringn numeroksi.</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    System.out.print("Syötä numero: ");

    int numero = Integer.parseInt(reader.nextLine());
</pre>

<pre>
Syötä numero: <font color="red">tatti</font>
<font color="red">Exception in thread "..." java.lang.NumberFormatException: For input string: "tatti"</font>
</pre>

    <p>Yllä oleva ohjelma heittää poikkeuksen kun käyttäjä syöttää virheellisen numeron. Ohjelman suoritus päättyy virhetilanteeseen, eikä suoritusta voi enää jatkaa. Lisätään ohjelmaan poikkeuskäsittely. Kutsu, joka saattaa heittää poikkeuksen asetetaan <code>try</code>-lohkon sisään, ja virhetilanteessa tapahtuva toiminta <code>catch</code>-lohkon sisään. </p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    System.out.print("Syötä numero: ");

    try {
        int numero = Integer.parseInt(reader.nextLine());
    } catch (Exception e) {
        System.out.println("Et syöttänyt kunnollista numeroa.");
    }
</pre>

<pre>
Syötä numero: <font color="red">5</font>
</pre>

<pre>
Syötä numero: <font color="red">enpäs!</font>
Et syöttänyt kunnollista numeroa.
</pre>

    <p>Avainsanan <code>try</code> määrittelemän lohkon sisältä siirrytään <code>catch</code>-lohkoon heti poikkeuksen tapahtuessa.  Visualisoidaan tätä lisäämällä tulostuslause <code>try</code>-lohkossa metodia <code>Integer.parseInt</code> kutsuvan rivin jälkeen.</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    System.out.print("Syötä numero: ");

    try {
        int numero = Integer.parseInt(reader.nextLine());
        System.out.println("Hienosti syötetty!");
    } catch (Exception e) {
        System.out.println("Et syöttänyt kunnollista numeroa.");
    }
</pre>


<pre>
Syötä numero: <font color="red">5</font>
Hienosti syötetty!
</pre>

<pre>
Syötä numero: <font color="red">enpäs!</font>
Et syöttänyt kunnollista numeroa.
</pre>

    <p>Ohjelmalle syötetty characterString <code>enpäs!</code> annetaan parametrina <code>Integer.parseInt</code>-metodille, joka heittää poikkeuksen jos parametrina saadun characterStringn muuntaminen luvuksi epäonnistuu. Huomaa että <code>catch</code>-lohkossa oleva koodi suoritetaan <em>vain</em> poikkeustapauksissa -- muulloin ohjelma ei pääse sinne.</p>

    <p>Tehdään luvun muuntajasta hieman hyödyllisempi: Tehdään siitä metodi, joka kysyy numeroa yhä uudestaan kunnes käyttäjä syöttää oikean numeron. Metodista pääsee pois <em>vain</em> jos käyttäjä syöttää oikean luvun.</p>

<pre class="sh_java">
public int lueLuku(Scanner lukija) {
    while (true) {
        System.out.print("Syötä numero: ");

        try {
            int numero = Integer.parseInt(reader.nextLine());
            return numero;
        } catch (Exception e) {
            System.out.println("Et syöttänyt kunnollista numeroa.");
        }
    }
}
</pre>

    <p>Metodin <code>lueLuku</code> kutsuminen voisi toimia esimerkiksi seuraavasti</p>

<pre>
Syötä numero: <font color="red">enpäs!</font>
Et syöttänyt kunnollista numeroa.
Syötä numero: <font color="red">Matilla on ovessa tatti.</font>
Et syöttänyt kunnollista numeroa.
Syötä numero: <font color="red">43</font>

</pre>


<h3>Poikkeusten heittäminen</h3>

    <p>Metodit ja konstruktorit voivat <em>heittää</em> poikkeuksia. Heitettäviä poikkeuksia on karkeasti ottaen kahdenlaisia. On poikkeuksia jotka on pakko käsitellä, ja on poikkeuksia joita ei ole pakko käsitellä. Pakosti käsiteltävät poikkeukset käsitellään joko <code>try-catch</code> -lohkossa, tai <em>heittämällä ne ulos metodista</em>. </p>

<p>
Ohjelmoinnin perusteiden tehtävän <em>kellosta olio</em> bonusversiossa kerrottiin, että ohjelma saadaan viivyttämään itseään sekunnin verran kutsumalla komentoa <code>Thread.sleep(1000)</code>. Komento saattaa heittää poikkeuksen, joka on <em>pakko</em> käsitellä. Poikkeuksen käsittely siis tapahtuu  <code>try-catch</code> -lauseella, seuraavassa esimerkissä olemme välittämättä mahdollisista poikkeustilanteista ja jätimme <code>catch</code>-lohkon tyhjäksi:</p>

<pre class="sh_java">
    try {
        // nukutaan 1000 millisekuntia
        Thread.sleep(1000);
    } catch (Exception e) {
        // ei tehdä mitään poikkeustilanteessa
    }
</pre>

    <p>Metodeissa on myös mahdollista jättää poikkeus itse käsittelemättä ja <em>siirtää vastuu</em> poikkeuksen käsittelystä metodin kutsujalle. Vastuun siirto tapahtuu heittämällä poikkeus metodista eteenpäin sanomalla <code>throws Exception</code>.</p>

<pre class="sh_java">
    public void nuku(int sekuntia) <strong>throws Exception</strong> {
        Thread.sleep(sekuntia * 1000);   // nyt try-catchia ei tarvita!
    }
</pre>

    <p>Nyt metodia <code>nuku</code>-kutsuvan metodin tulee joko käsitellä poikkeus <code>try-catch</code> -lohkossa, tai siirtää poikkeuksen käsittelyn vastuuta eteenpäin heittää poikkeus eteenpäin. Joskus poikkeuksen käsittelyä pakoillaan viimeiseen asti, ja <code>main</code>-metodikin heittää poikkeuksen käsiteltäväksi eteenpäin:</p> 
<pre class="sh_java">
public class MainProgram {
   public static void main(String[] args) throws Exception {
       // ...
   }
}
</pre>

<p>Tällöin poikkeus päätyy Javan virtuaalikoneelle, joka keskeyttää ohjelman suorituksen poikkeukseen johtavan virheen tapahtuessa.</p>

    <p>Osa poikkeuksista, kuten <code>Integer.parseInt</code>-metodin heittämä <code>NumberFormatException</code>, on sellaisia joihin ohjelmoijan ei ole pakko varautua. Poikkeukset, joihin käyttäjän ei tarvitse varautua ovat aina myös tyyppiä tyyppiä <code>RuntimeException</code>, palaamme siihen <em>miksi</em> muuttujilla voi olla useita eri tyyppejä tarkemmin ensi viikolla.</p>

    <p>Voimme itse heittää poikkeuksen lähdekoodista <code>throw</code>-komennolla. Esimerkiksi <code>NumberFormatException</code>-luokasta luodun poikkeuksen heittäminen tapahtuisi komennolla <code>throw new NumberFormatException()</code>.</p>

    <p>Eräs poikkeus johon käyttäjän ei ole pakko varautua on <code>IllegalArgumentException</code>. Poikkeuksella <code>IllegalArgumentException</code> kerrotaan että metodille tai konstruktorille annettujen parametrien arvot ovat <em>vääränlaiset</em>. IllegalArgumentException-poikkeusta käytetään esimerkiksi silloin kun halutaan varmistaa että parametreilla on tietyt arvot. Luodaan luokka <code>Arvosana</code>, joka saa konstruktorin parametrina kokonaislukutyyppisen arvosanan.</p>

<pre class="sh_java">
public class Arvosana {
    private int arvosana;

    public Arvosana(int arvosana) {
        this.arvosana = arvosana;
    }

    public int getArvosana() {
        return this.arvosana;
    }
}
</pre>

    <p>Haluamme seuraavaksi <em>validoida</em> Arvosana-luokan konstruktorin parametrina saadun arvon. Arvosanan tulee olla aina välillä 0-5. Jos arvosana on jotain muuta, haluamme <em>heittää poikkeuksen</em>. Lisätään <code>Arvosana</code>-luokan konstruktoriin ehtolause, joka tarkistaa onko arvosana arvovälin 0-5 ulkopuolella. Jos on, heitetään poikkeus <code>IllegalArgumentException</code> sanomalla <code>throw new IllegalArgumentException("Arvosanan tulee olla välillä 0-5");</code>.</p>

<pre class="sh_java">
public class Arvosana {
    private int arvosana;

    public Arvosana(int arvosana) {
        if (arvosana &lt; 0 || arvosana &gt; 5) {
            throw new IllegalArgumentException("Arvosanan tulee olla välillä 0-5");
        }
        this.arvosana = arvosana;
    }

    public int getArvosana() {
        return this.arvosana;
    }
}
</pre>

<pre class="sh_java">
    Arvosana arvosana = new Arvosana(3);
    System.out.println(arvosana.getArvosana());

    Arvosana virheellinenArvo = new Arvosana(22);
    // tapahtuu poikkeus, tästä ei jatketa eteenpäin
</pre>

<pre>
3
Exception in thread "..." java.lang.IllegalArgumentException: Arvosanan tulee olla välillä 0-5
</pre>


<div class="tehtavat">
  <h3>Parametrien validointi</h3>

  <p>Harjoitellaan hieman parametrien validointia <code>IllegalArgumentException</code>-poikkeuksen avulla. Tehtäväpohjassa tulee kaksi luokkaa, <code>Person</code> ja <code>Calculator</code>. Muuta luokkia seuraavasti:</p>

  <h4>Henkilön validointi</h4>

  <p>Luokan <code>Person</code> konstruktorin tulee varmistaa että parametrina annettu nimi ei ole null, tyhjä tai yli 40 merkkiä pitkä. Myös iän tulee olla väliltä 0-120. Jos joku edelläolevista ehdoista ei päde, tulee konstruktorin heittää <code>IllegalArgumentException</code>-poikkeus.</p>

  <h4>Laskimen validointi</h4>

  <p>Luokan <code>Calculator</code> metodeja tulee muuttaa seuraavasti: Metodin <code>kertoma</code> tulee toimia vain jos parametrina annetaan ei-negatiivinen luku (0 tai suurempi). Metodin <code>binomikerroin</code> tulee toimia vain jos parametrit ovat ei-negatiivisia ja osajoukon koko on pienempi kuin joukon koko. Jos jompikumpi metodeista saa epäkelpoja arvoja metodikutsujen yhteydessä, tulee metodien heittää poikkeus <code>IllegalArgumentException</code>.</p>

<h3>Sensorit ja lämpötilan mittausta</h3>

<p>Kakki sovelluksessa oleva koodi tulee sijoittaa pakkaukseen <code>sovellus</code>.</p>

<p>Käytössämme on seuraava rajapinta:</p>

<pre class="sh_java">
public interface Sensori {
    boolean onPaalla();  // palauttaa true jos sensori on päällä
    void paalle();       // käynnistä sensorin
    void poisPaalta();   // sulkee sensorin
    int mittaa();        // palauttaa sensorin lukeman jos sensori on päällä
                         // jos sensori ei päällä heittää poikkeuksen IllegalStateException
}
</pre>

<h4>Vakiosensori</h4>

<p>Tee luokka <code>Vakiosensori</code> joka toteuttaa rajapinnan <code>Sensori</code>.</p>

<p>Vakiosensori on koko ajan päällä. Metodien paalle ja poisPaalta kutsuminen ei tee mitään. Vakiosensorilla tulee olla konstruktori, jonka parametrina on kokonaisluku. Metodikutsu <code>mittaa</code> palauttaa aina konstruktorille parametrina annetun luvun.
</p>

<p>Esimerkki:</p>

<pre class="sh_java">
public static void main(String[] args) {
  Vakiosensori kymppi = new Vakiosensori(10);
  Vakiosensori miinusViis = new Vakiosensori(-5);

  System.out.println( kymppi.mittaa() );
  System.out.println( miinusViis.mittaa() );

  System.out.println( kymppi.onPaalla() );
  kymppi.poisPaalta();
  System.out.println( kymppi.onPaalla() );
}
</pre>

<p>Tulostuu:</p>

<pre>
10
-5
true
true
</pre>

<h4>Lampomittari</h4>

<p>Tee luokka <code>Lampomittari</code> joka toteuttaa rajapinnan <code>Sensori</code>.</p>

<p>
Aluksi lämpömittari on poissa päältä. Kutsuttaessa metodia <code>mittaa</code> kun mittari on päällä mittari arpoo luvun väliltä -30...30 ja palauttaa sen kutsujalle. Jos mittari ei ole päällä, heitetään poikkeus </code>IllegalStateException</code>. 
</p>

<h4>Keskiarvosensori</h4>

<p>Tee luokka <code>Keskiarvosensori</code> joka toteuttaa rajapinnan </code>Sensori</code>.</p>

<p>
Keskiarvosensori sisältää useita sensoreita. Rajapinnan <code>Sensori</code> määrittelemien metodien lisäksi keskiarvosensorilla on metodi 
<code>public void lisaaSensori(Sensori lisattava)</code> jonka avulla keskiarvosensorin hallintaan lisätään uusi sensori.
</p>

<p>
Keskiarvosensori on päällä silloin kuin <em>kaikki</em> sen sisältävät sensorit ovat päällä. Kun keskiarvosensori käynnistetään, täytyy kaikkien sen sisältävien sensorien käynnistyä jos ne eivät ole käynnissä. Kun keskiarvosensori suljetaan, täytyy ainakin yhden sen sisältävän sensorin mennä pois päältä. Saa myös käydä niin että kaikki sen sisältävät sensorit menevät pois päältä.
</p>

<p>
Keskiarvosensorin metodi <code>mittaa</code> palauttaa sen sisältämien sensoreiden lukemien keskiarvon (koska paluuarvo on <code>int</code>, pyöristyy lukema alaspäin kuten kokonaisluvuilla tehdyissä jakolaskuissa). Jos keskiarvosensorin metodia <code>mittaa</code> kutsutaan sensorin ollessa poissa päältä, tai jos keskiarvosensorille ei vielä ole lisätty yhtään sensoria heitetään poikkeus <code>IllegalStateException</code>.
</p>

<p>Seuraavassa sensoreja käyttävä esimerkkiohjelma (huomaa, että sekä Lämpömittarin että Keskiarvosensorin konstruktorit ovat parametrittomia):</p>

<pre class="sh_java">
public static void main(String[] args) {
    Sensori kumpula = new Lampomittari();         
    kumpula.paalle();
    System.out.println("lämpötila Kumpulassa "+kumpula.mittaa() + " astetta");
    
    Sensori kaisaniemi = new Lampomittari();        
    Sensori helsinkiVantaa = new Lampomittari();
        
    Keskiarvosensori paakaupunki = new Keskiarvosensori();
    paakaupunki.lisaaSensori(kumpula);
    paakaupunki.lisaaSensori(kaisaniemi);
    paakaupunki.lisaaSensori(helsinkiVantaa);
        
    paakaupunki.paalle();
    System.out.println("lämpötila Pääkaupunkiseudulla "+paakaupunki.mittaa() + " astetta");     
}
</pre>

<p>tulostuu (tulostetut lukuarvot riippuvat tietenkin arvotuista lämpötiloista):</p>

<pre class="sh_java">
lämpötila Kumpulassa -7 astetta
lämpötila Pääkaupunkiseudulla -10 astetta
</pre>

<p><b>Huom:</b> kannatata käyttää Vakiosensori-oliota keskiarvosensorin testaamiseen!</p>

<h4>Kaikki mittaukset</h4>

<p>Lisää luokalle Keskiarvosensori metodi <code>public List&lt;Integer&gt; mittaukset()</code>, joka palauttaa listana kaikkien keskiarvosensorin avulla suoritettujen mittausten tulokset. Seuraavassa esimerkki metodin toiminnasta: </p>

<pre class="sh_java">
public static void main(String[] args) {
    Sensori kumpula = new Lampomittari();         
    Sensori kaisaniemi = new Lampomittari();        
    Sensori helsinkiVantaa = new Lampomittari();
        
    Keskiarvosensori paakaupunki = new Keskiarvosensori();
    paakaupunki.lisaaSensori(kumpula);
    paakaupunki.lisaaSensori(kaisaniemi);
    paakaupunki.lisaaSensori(helsinkiVantaa);
        
    paakaupunki.paalle();
    System.out.println("lämpötila Pääkaupunkiseudulla "+paakaupunki.mittaa() + " astetta");     
    System.out.println("lämpötila Pääkaupunkiseudulla "+paakaupunki.mittaa() + " astetta");    
    System.out.println("lämpötila Pääkaupunkiseudulla "+paakaupunki.mittaa() + " astetta");    

    System.out.println("mittaukset: "+paakaupunki.mittaukset());
}
</pre>

<p>tulostuu (tulostetut lukuarvot riippuvat jälleen arvotuista lämpötiloista):</p>

<pre class="sh_java">
lämpötila Pääkaupunkiseudulla -10 astetta
lämpötila Pääkaupunkiseudulla -4 astetta
lämpötila Pääkaupunkiseudulla 5 astetta

mittaukset: [-10, -4, 5]
</pre>

</div>




<h3>Poikkeukset ja rajapinnat</h3>

    <p>Rajapintaluokilla ei ole metodirunkoa, mutta metodimäärittely on vapaasti rajapinnan suunnittelijan toteutettavissa. Rajapintaluokat voivat määritellä myös poikkeusten heiton. Esimerkiksi seuraavan rajapinnan <code>Tiedostopalvelin</code> toteuttavat luokat heittävät <em>mahdollisesti</em> poikkeuksen <code>lataa</code>- ja <code>tallenna</code>-metodissa.</p>

<pre class="sh_java">
public interface Tiedostopalvelin {
    String lataa(String tiedosto) throws Exception;
    void tallenna(String tiedosto, String characterString) throws Exception;
}
</pre>

    <p>Jos rajapinta määrittelee metodeille <code>throws Exception</code>-määreet, eli että metodit heittävät mahdollisesti poikkeuksen, tulee samat määreet olla myös rajapinnan toteuttavassa luokassa. Luokan ei kuitenkaan ole pakko heittää poikkeusta kuten alla olevasta esimerkistä näkee.</p>

<pre class="sh_java">
public class Tekstipalvelin implements Tiedostopalvelin {

    private Map&lt;String, String&gt; data;

    public Tekstipalvelin() {
        this.data = new HashMap&lt;String, String&gt;();
    }

    @Override
    public String lataa(String tiedosto) throws Exception {
        return this.data.get(tiedosto);
    }

    @Override
    public void tallenna(String tiedosto, String characterString) throws Exception {
        this.data.put(tiedosto, characterString);
    }
}
</pre>

<h3>Poikkeuksen tiedot</h3>

    <p>Poikkeusten käsittelytoiminnallisuuden sisältämä <code>catch</code>-lohko määrittelee catch-osion sisällä poikkeuksen johon varaudutaan <code>catch (<em>Exception e</em>)</code>. Poikkeuksen tiedot tallennetaan <code>e</code>-muuttujaan.</p>

<pre class="sh_java">
    try {
        // ohjelmakoodi, joka saattaa heittää poikkeuksen
    } catch (Exception e) {
        // poikkeuksen tiedot ovat tallessa muuttujassa e
    }
</pre>

    <p>Luokka <code>Exception</code> tarjoaa hyödyllisiä metodeja. Esimerkiksi metodi <code>printStackTrace()</code> tulostaa <em>polun</em>, joka kertoo mistä päädyttiin poikkeukseen. Tutkitaan seuraavaa metodin <code>printStackTrace()</code> tulostamaa virhettä.</p>

<pre>
Exception in thread "main" java.lang.NullPointerException
  at pakkaus.Luokka.tulosta(Luokka.java:43)
  at pakkaus.Luokka.main(Luokka.java:29)
</pre>

    <p>Poikkeuspolun lukeminen tapahtuu alhaalta ylöspäin. Alimpana on ensimmäinen kutsu, eli ohjelman suoritus on alkanut luokan <code>Luokka</code> metodista <code>main()</code>. Luokan <code>Luokka</code> main-metodin rivillä 29 on kutsuttu metodia <code>tulosta()</code>. Metodin <code>tulosta</code> rivillä 43 on tapahtunut poikkeus <code>NullPointerException</code>. Poikkeuksen tiedot ovatkin hyvin hyödyllisiä virhekohdan selvittämisessä.</p>


<h2>Tiedoston lukeminen</h2>

    <p>Huomattava osa ohjelmista käsittelee jollain tavalla tallennettua tietoa. Otetaan ensiaskeleet tiedostojen käsittelyyn Javassa. Javan API tarjoaa luokan <a href="http://docs.oracle.com/javase/6/docs/api/java/io/File.html" target="_blank">File</a>, jonka sisältö voidaan lukea kurssilla jo tutuksi tulleen <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html" target="_blank">Scanner</a>-luokan avulla.</p>

    <p>Luokan <code>File</code> <a href="http://docs.oracle.com/javase/6/docs/api/java/io/File.html" target="_blank">API-kuvausta</a> lukiessamme huomaamme <code>File</code>-luokalla on konstruktori <code>File(String pathname)</code> (<em>Creates a new File instance by converting the given pathname string into an abstract pathname</em>). Voimme siis antaa avattavan tiedoston polun <code>File</code>-luokan konstruktorille.</p>

    <p><em>NetBeans-ohjelmointiympäristössä tiedostoille on oma välilehti nimeltä <em>Files</em>. Files-välilehdellä on määritelty kaikki projektiin liittyvät tiedostot. Jos projektin <em>juureen</em>, eli ei yhdenkään hakemiston sisälle, lisätään tiedosto, voidaan siihen viitata projektin sisältä suoraan tiedoston nimellä. Tiedosto-olion luominen tapahtuu antamalla sille parametrina polku tiedostoon, esimerkiksi seuraavasti</em></p>

<pre class="sh_java">
    File tiedosto = new File("tiedoston-nimi.txt");
</pre>

    <p>Scanner-luokan konstruktorille voi antaa myös muita lukemislähteitä kuin <code>System.in</code>-syöttövirran. Lukemislähteenä voi olla näppäimistön lisäksi muun muassa tiedosto. Scanner tarjoaa tiedoston lukemiseen samat metodit kuin näppäimistöltä syötetyn syötteen lukemiseen. Seuraavassa esimerkissä avataan tiedosto ja tulostetaan kaikki tiedoston sisältämän tekstit <code>System.out.println</code>-komennolla Lopuksi tiedosto suljetaa komennolla <code>close</code>.</p>

<pre class="sh_java">
        // tiedosto mistä luetaan
        File tiedosto = new File("tiedosto.txt");

        Scanner lukija = new Scanner(tiedosto);
        while (reader.hasNextLine()) {
            String rivi = reader.nextLine();
            System.out.println(rivi);
        }

        reader.close();
</pre>

    <p>Scanner-luokan konstruktori <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html#Scanner(java.io.File)" target="_blank">public Scanner(File source)</a></code> (<em>Constructs a new Scanner that produces values scanned from the specified file.</em>) heittää <code><a href="http://docs.oracle.com/javase/6/docs/api/java/io/FileNotFoundException.html" target="_blank">FileNotFoundException</a></code>-poikkeuksen jos luettavaa tiedostoa ei löydy. Poikkeus <code>FileNotFoundException</code> ei ole tyyppiä <code>RuntimeException</code>, joten se tulee joko käsitellä tai heittää eteenpäin. Tässä vaiheessa riittää tietää että ohjelmointiympäristö kertoo jos sinun tulee käsitellä poikkeus erikseen. Luodaan ensin vaihtoehto, jossa poikkeus käsitellään tiedostoa avattaessa.</p>

<pre class="sh_java">
    public void lueTiedosto(File tiedosto) {
        // tiedosto mistä luetaan
        Scanner lukija = null;

        try {
            lukija = new Scanner(tiedosto);
        } catch (Exception e) {
            System.out.println("Tiedoston lukeminen epäonnistui. Virhe: " + e.getMessage());
            return; // poistutaan metodista
        }

        while (reader.hasNextLine()) {
            String rivi = reader.nextLine();
            System.out.println(rivi);
        }

        reader.close();
    }
</pre>

    <p>Toinen vaihtoehto poikkeuksen käsittelyyn on poikkeuksen käsittelyvastuun siirtäminen metodin kutsujalle. Poikkeuksen käsittelyvastuu siirretään metodin kutsujalle lisäämällä metodiin määre <code>throws <em>PoikkeuksenTyyppi</em></code>, eli esimerkiksi <code>throws Exception</code> sillä kaikki poikkeukset ovat tyyppiä <code>Exception</code>. Kun metodilla on määre <code>throws Exception</code>, tietävät kaikki sitä kutsuvat että se saattaa heittää poikkeuksen johon tulee varautua.</p>

<pre class="sh_java">
    public void lueTiedosto(File tiedosto) throws Exception {
        // tiedosto mistä luetaan
        Scanner lukija = new Scanner(tiedosto);

        while (reader.hasNextLine()) {
            String rivi = reader.nextLine();
            System.out.println(rivi);
        }

        reader.close();
    }
</pre>

    <p>Esimerkki avaa tiedoston <code>tiedosto.txt</code> projektin juuripolusta ja tulostaa sen rivi riviltä käyttäjälle näkyville. Lopuksi lukija suljetaan, jolloin tiedosto myös suljetaan. Määre <code>throws Exception</code> kertoo että metodi saattaa heittää poikkeuksen. Samanlaisen määreen voi laittaa kaikkiin metodeihin jotka käsittelevät tiedostoja.</p>

    <p>Huomaa että <code>Scanner</code>-olio ei liitä rivinvaihtomerkkejä osaksi <code>nextLine</code>-metodin palauttamaa characterStringa. Yksi vaihtoehto tiedoston lukemiseen siten, että rivinvaihdot säilyvät, on lisätä jokaisen rivin jälkeen rivinvaihtomerkki:</p>

<pre class="sh_java">
    public String lueTiedostocharacterStringon(File tiedosto) throws Exception {
        // tiedosto mistä luetaan
        Scanner lukija = new Scanner(tiedosto);

        String characterString = "";

        while (reader.hasNextLine()) {
            String rivi = reader.nextLine();
            characterString += rivi;
            characterString += "\n";
        }

        reader.close();
        return characterString;
    }
</pre>

    <p>Koska käytämme tiedoston lukemiseen <code>Scanner</code>-luokkaa, käytössämme on kaikki Scanner-luokan tarjoamat metodit. Esimerkiksi metodi <code>hasNext()</code> palauttaa totuusarvon <code>true</code>, jos luettavassa tiedostossa on vielä luettavaa jäljellä, ja metodi <code>next()</code> lukee seuraavan sanan metodin palauttamaan <code>String</code>-olioon. </p>

    <p>Seuraava ohjelma luo <code>Scanner</code>-olion, joka avaa tiedoston <code>tiedosto.txt</code>. Sen jälkeen se tulostaa joka viidennen sanan tiedostosta.</p>

<pre class="sh_java">
        File tiedosto = new File("tiedosto.txt");
        Scanner lukija = new Scanner(tiedosto);

        int monesko = 0;
        while (reader.hasNext()) {
            monesko++;
            String sana = reader.next();

            if (monesko % 5 == 0) {
                System.out.println(sana);
            }
        }
</pre>

    <p>Alla on ensin luetun tiedoston sisältämä teksti ja sitten ohjelman tulostus</p>

<pre>
Poikkeukset (exceptions) ovat &quot;poikkeuksellisia tilanteita&quot; kesken normaalin ohjelmansuorituksen:
tiedosto loppuu, characterString ei kelpaa kokonaisluvuksi, odotetun olion tilalla onkin null-arvo,
taulukon indeksi menee ohjelmointivirheen takia sopimattomaksi, ...
</pre>

<pre>
tilanteita&quot;
loppuu,
odotetun
taulukon
sopimattomaksi,
</pre>

<h3>Merkistöongelmista</h3>

    <p>Tekstiä tiedostosta luettaessa (tai tiedostoon tallennettaessa) Java joutuu päättelemään käyttöjärjestelmän käyttämän merkistön. Merkistön tuntemusta tarvitaan sekä tekstin tallentamiseen tietokoneen kovalevylle binäärimuotoiseksi että binäärimuotoisen datan tekstiksi kääntämiseksi.</p>

    <p>Merkistöihin on kehitetty standardeja, joista "UTF-8" on nykyään yleisin. UTF-8 -merkistö sisältää sekä jokapäiväisessä käytössä olevien aakkosten että erikoisempien merkkien kuten Japanin kanji-merkistön tai shakkipelin nappuloiden tallentamiseen ja lukemiseen tarvittavat tiedot. Ohjelmointimielessä merkistöä voi hieman yksinkertaistaen ajatella hajautustauluna merkistä numeroon ja numerosta merkkiin. Merkistä numeroon oleva hajautustaulu kuvaa minkälaisena binäärilukuna kukin merkki tallennetaan tiedostoon. Numerosta merkkiin oleva hajautustaulu taas kuvaa miten tiedostoa luettaessa saadut values muunnetaan merkeiksi.</p>

    <p>Lähes jokaisella käyttöjärjestelmävalmistajalla on myös omat standardinsa. Osa tukee ja haluaa osallistua avoimien standardien käyttöön, osa ei. Mikäli sinulla on ongelmia ääkkösellisten sanojen kanssa (eritoten mac ja windows käyttäjät) voit kertoa <code>Scanner</code>-oliota luodessa käytettävän merkistön. Tällä kurssilla käytämme aina merkistöä "UTF-8".</p>

    <p>UTF-8 -merkistöä käyttävän tiedostoa lukevan Scanner-olion voi luoda seuraavasti:</p>

<pre class="sh_java">
    File tiedosto = new File("esimerkkitiedosto.txt");
    Scanner lukija = new Scanner(tiedosto, "UTF-8");
</pre>

    <p>Toinen vaihtoehto merkistön asettamiseksi on ympäristömuuttujan käyttäminen. Macintosh ja Windows-käyttäjät voivat asettaa ympäristömuuttujan <code>JAVA_TOOL_OPTIONS</code> arvoksi characterStringn <code>-Dfile.encoding=UTF8</code>. Tällöin Java käyttää oletuksena aina UTF-8-merkistöä.</p>

<div class="tehtavat">
  <h3>Rivit joilla sana</h3>

<p>Tee luokka <code>Tulostaja</code> ja sille konstruktori <code>public Tulostaja(String tiedostonNimi)</code>, joka saa parametrinaan tiedoston nimeä vastaavan characterStringn sekä metodi <code>public void tulostaRivitJoilla(String sana)</code> tulostaa tiedostosta ne rivit, joilla esiintyy parametrina oleva sana (<em>pienet ja isot kirjaimet erotellaan tehtävässä, eli esim. "koe" ja "Koe" eivät ole sama sana</em>), rivit tulostetaan samassa järjestyksessä missä ne ovat tiedostossa. </p>

<p>Jos parametri on tyhjä characterString, tulostuu koko tiedosto.</p> 

<p>Jos tiedostoa ei ole olemassa, heittää konstruktori aiheutuvan poikkeuksen eteenpäin, eli try-catch-komentoa ei tarvita, riittää määritellä konstruktori seuraavasti:</p>

<pre class="sh_java">
public Tulostaja {

   public Tulostaja(String tiedostonNimi) throws Exception {
      // ...
   }

   // ...
}
</pre>

<p>Projektisi default-pakkauksessa on testausta varten tiedosto <em>testitiedosto.txt</em>. Ohjelmasta avatessa tiedoston nimeksi tulee antaa <code>src/testitiedosto.txt</code>. Tiedoston sisältö on seuraava:</p> 

<pre>
Siinä vanha Väinämöinen
katseleikse käänteleikse 
Niin tuli kevätkäkönen
näki koivun kasvavaksi 
Miksipä on tuo jätetty
koivahainen kaatamatta  
Sanoi vanha Väinämöinen 
</pre>

<p>Seuraavassa esimerkki ohjelman toiminnasta testitiedostolla:</p>

<pre class="sh_java">
    Tulostaja tulostaja = new Tulostaja("src/testitiedosto.txt");

    tulostaja.tulostaRivitJoilla("Väinämöinen");
    System.out.println("-----");
    tulostaja.tulostaRivitJoilla("Frank Zappa");
    System.out.println("-----");
    tulostaja.tulostaRivitJoilla("");
    System.out.println("-----");
</pre>

<p>Tulostuu:</p>

<pre>
Siinä vanha Väinämöinen
Sanoi vanha Väinämöinen 
-----
-----
Siinä vanha Väinämöinen
katseleikse käänteleikse 
Niin tuli kevätkäkönen
näki koivun kasvavaksi 
Miksipä on tuo jätetty
koivahainen kaatamatta  
Sanoi vanha Väinämöinen 
</pre>

<p>Projektipohjasta löytyy myös koko Kalevala, tiedoston nimi on <code>src/kalevala.txt</code></p>


  <h3>Tiedoston analyysi</h3>

  <p>Tässä tehtävässä tehdään sovellus tiedoston rivi- ja merkkimäärän laskemiseen.</p>

  <h4>Rivien laskeminen</h4>


  <p>Tee pakkaukseen <code>tiedosto</code> luokka <code>Analyysi</code>, jolla on konstruktori <code>public Analyysi(File tiedosto)</code>. Toteuta luokalle metodi <code>public int rivimaara()</code>, joka palauttaa konstruktorille annetun tiedoston rivimäärän.</p>

<p>Metodi ei saa olla "kertakäyttöinen", eli sen pitää tuottaa oikea tulos myös usealla peräkkäisellä kutsulla. Huomaa, että kun teet tiedostoa vastaavan Scanner-olion, ja luet tiedoston koko sisällön <code>nextLine</code>-komennoilla, et voi käyttää enää <em>samaa</em> skanneria tiedoston uudelleenlukemiseen!</p>

<p><strong>Huom:</strong> jos testit sanovat <em>timeout</em>, et todennäköisesti muista lukea tiedostoa ollenkaan, eli <code>nextLine</code>-kutsut puuttuvat!</p>

  <h4>Merkkien laskeminen</h4>

  <p>Toteuta luokkaan <code>Analyysi</code> metodi <code>public int merkkeja()</code>, joka palauttaa luokan konstruktorille annetun tiedoston merkkien määrän.</p>

<p>Metodi ei saa olla "kertakäyttöinen", eli sen pitää tuottaa oikea tulos myös usealla peräkkäisellä kutsulla.</p>

  <p>Voit itse päättää miten reagoidaan jos konstruktorin parametrina saatua tiedostoa ei ole olemassa.</p>

<p>Projektisi testipakkauksessa on testausta varten tiedosto <em>testitiedosto.txt</em>. Ohjelmasta avatessa tiedoston nimeksi tulee antaa <code>test/testitiedosto.txt</code>. Tiedoston sisältö on seuraava:</p> 

<pre>
rivejä tässä on 3 ja merkkejä 
koska rivinvaihdotkin ovat
merkkejä
</pre>

<p>Ohjelman toiminta testaustiedostolla:</p>

<pre class="sh_java">
    File tiedosto = new File("src/testitiedosto.txt");
    Analyysi analyysi = new Analyysi(tiedosto);
    System.out.println("Rivejä: " + analyysi.rivimaara());
    System.out.println("Merkkejä: " + analyysi.merkkeja());
</pre>

<pre>
Rivejä: 3
Merkkejä: 67
</pre>

  <h3>Sanatutkimus</h3>

  <p>Tee luokka Sanatutkimus, jolla voi tehdä erilaisia tutkimuksia tiedoston sisältämille sanoille. Toteuta luokka pakkaukseen <code>sanatutkimus</code>.</p>

  <p>Kotimaisten kielten tutkimuskeskus (Kotus) on julkaissut netissä suomen kielen sanalistan. Tässä tehtävässä käytetään listan muokattua versiota, joka löytyy tehtäväpohjasta <code>src</code>-hakemistosta nimellä <code>sanalista.txt</code>, eli suhteellisesta polusta <code>"src/sanalista.txt"</code>.
Koska sanalista on varsin pitkä, on projektissa testausta varten myös <code>pienilista.txt</code> joka löytyy polusta <code>"src/pienilista.txt"</code>.
</p>

  <p><strong>Mikäli sinulla on ongelmia ääkkösellisten sanojen kanssa</strong> (mac ja windows käyttäjät) luo <code>Scanner</code>-olio antaen sille parametrina merkistö "UTF-8" seuraavasti: <code> Scanner lukija = new Scanner(tiedosto, "UTF-8");</code> Ongelmat liittyvät erityisesti testien suoritukseen.</p>

  <h4 class="req">Sanojen määrä</h4>

  <p>Luo Sanatutkimus-luokalle konstruktori <code>public Sanatutkimus(File tiedosto)</code> joka luo uuden Sanatutkimus-olion, joka tutkii parametrina annettavaa tiedostoa.</p>

  <p>Tee luokkaan metodi <code>public int sanojenMaara()</code>, joka lukee tiedostossa olevat sanat ja tulostaa niiden määrän. Tässä vaiheessa sanoilla ei tarvitse tehdä mitään, riittää laskea niiden määrä. Voit olettaa tässä tehtävässä, että tiedostossa on vain yksi sana riviä kohti.</p>


  <h4 class="req">z-kirjain</h4>

  <p>Tee luokkaan metodi <code>public List&lt;String&gt; kirjaimenZSisaltavatSanat()</code>, joka palauttaa tiedoston kaikki sanat, joissa on z-kirjain. Tällaisia sanoja ovat esimerkiksi jazz ja zombi.</p>

  <h4 class="req">l-pääte</h4>

  <p>Tee luokkaan metodi <code>public List&lt;String&gt; kirjaimeenLPaattyvatSanat()</code>, joka palauttaa tiedoston kaikki sanat, jotka päättyvät l-kirjaimeen. Tällaisia sanoja ovat esimerkiksi kannel ja sammal.</p>

  <p><em>Huom! Jos luet tiedoston uudestaan ja uudestaan jokaisessa metodissa huomaat viimeistään tässä vaiheessa copy-paste koodia. Kannattaa miettiä olisiko tiedoston lukeminen helpompi tehdä osana konstruktoria tai metodina, jota konstruktori kutsuu. Metodeissa voitaisiin käyttää tällöin jo luettua listaa ja luoda siitä aina uusi, hakuehtoihin sopiva lista. Viikolle 6 on tulossa oikeaoppinen tapa copypasten eliminointiin.</em></p>

  <h4>Palindromit</h4>

  <p>Tee luokkaan metodi <code>public List&lt;String&gt; palindromit()</code>, joka palauttaa tiedoston kaikki sanat, jotka ovat palindromeja. Tällaisia sanoja ovat esimerkiksi ala ja enne.</p>

  <h4 class="req">Kaikki vokaalit</h4>

  <p>Tee luokkaan metodi <code>public List&lt;String&gt; kaikkiVokaalitSisaltavatSanat()</code>, joka palauttaa tiedoston kaikki sanat, jotka sisältävät kaikki suomen kielen vokaalit (aeiouyäö). Tällaisia sanoja ovat esimerkiksi myöhäiselokuva ja ympäristönsuojelija.</p>
</div>







<h2>Hajautustauluista ja joukoista</h2>

<h3>Monta arvoa yhtä avainta kohti</h3>

<p>Kuten muistamme, voi HashMapiin tallettaa tiettyä avainta kohti vaan yhden arvon. Seuraavassa esimerkissä tallennamme henkilöiden puhelinnumeroita HashMap:iin.</p>

<pre class="sh_java">
  Map&lt;String, String&gt; puhelinnumerot = new HashMap&lt;String, String&gt;();

  puhelinnumerot.put("Pekka", "040-12348765");

  System.out.println( "Pekan numero: "+ puhelinnumerot.get("Pekka") );

  puhelinnumerot.put("Pekka", "09-111333");

  System.out.println( "Pekan numero: "+ puhelinnumerot.get("Pekka") );
</pre>

<p>Kuten odotettua, tulostus kertoo, että</p>

<pre>
Pekan numero: 040-12348765
Pekan numero: 09-111333
</pre>

<p>Entä jos haluaisimmekin tallettaa yhtä avainta kohti useita arvoja, eli esim yhtä henkilöä kohti monta puhelinnumeroa? Onnistuuko se HashMap:in avulla? Kyllä, esim. tallettamalla HashMap:iin Stringien sijaan esim. ArrayList:eja arvoiksi, voidaan yhteen avaimeen "liittää" useampia oliota. Muutetaan puhelinnumeroiden talletustapaa seuraavasti:</p>

<pre class="sh_java">
  Map&lt;String, ArrayList&lt;String&gt;&gt; puhelinnumerot = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();
</pre>

<p>Nyt siis HashMapissa jokaiseen avaimeen littyy lista. Vaikka new-komento luokin HashMapin, on mapin sisälle talletettavat listatu luotava erikseen. Seuraavassa lisätään HashMapiin Pekalle kaksi numeroa ja tulostataan ne:</p>

<pre class="sh_java">
  Map&lt;String, ArrayList&lt;String&gt;&gt; puhelinnumerot = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();

  // liitetään Pekka-nimeen ensin tyhjä ArrayList
  puhelinnumerot.put( "Pekka", new  ArrayList&lt;String&gt;() );
  
  // ja lisätään Pekkaa vastaavalle listalle puhelinnumero
  puhelinnumerot.get("Pekka").add("040-12348765");
 
  // ja lisätään toinenkin puhelinnumero
  puhelinnumerot.get("Pekka").add("09-111333");

  System.out.println( "Pekan numerot: "+ puhelinnumerot.get("Pekka") );
</pre>

<p>Tulostuu</p>

<pre>
Pekan numero: [040-12348765, 09-111333]
</pre>

<p>Määrittelimme muuttujan puhelinnumero tyypiksi <code>Map&lt;String, ArrayList&lt;String&gt;&gt;</code> eli Map jonka avaimena on characterString ja arvona characterStringja sisältävä lista. Konkreettinen toteutus, eli luotu olio oli HasMap. Olisimme voineet määritellä muuttujan myös seuraavasti:
</p>

<pre class="sh_java">
Map&lt;String, List&lt;String&gt;&gt; puhelinnumero = new HashMap&lt;String, List&lt;String&gt;&gt;();
</pre>

<p>
Eli nyt muuttujan tyyppi on Map, jonka avaimena on characterString ja arvona characterStringja sisältävä <code>List</code>, joka siis on rajapinta joka määrittelee listatoiminnallisuuden, esim. ArrayList toteuttaa tämän rajapinnan. Konkreettinen olio on HashMap.
</p>

<p>HashMap:iin talletettavat arvot siis ovat <code>List&lt;String&gt;</code>-rajapinnan toteuttavia konkreettisia olioita, esim. ArrayListeja. Eli lisäys HashMapiin tapahtuu edelleen seuraavasti:</p>

<pre class="sh_java">
  // liitetään Pekka-nimeen ensin tyhjä ArrayList
  puhelinnumerot.put( "Pekka", new  ArrayList&lt;String&gt;() );

  // ...
</pre>

<p>Jatkossa pyrkimyksemme on käyttää tyyppimäärittelyissä konkreettisten luokkien, esim. <code>HashMap</code> ja <code>ArrayList</code> sijaan niitä vastaavia rajapintoja <code>Map</code> ja <code>List</code>.</p>

<h3>Joukoista</h3>

    <p>Rajapinta <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a></code> kuvaa joukon toiminnallisuutta. Toisin kuin listalla, on joukossa kutakin alkioita korkeintaan yksi kappale, eli yhtän samanlaista oliota ei ole kahdesti. Olioiden samankaltaisuuden tarkistaminen toteutetaan <code>equals</code> ja <code>hashCode</code> -metodeja käyttämällä. </p>

<p>Yksi rajapinnan <code>Set</code> toteuttava luokka on  <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html" target="_blank">HashSet</a></code>. Toteutetaan sen avulla luokka <code>Tehtavakirjanpito</code>, joka tarjoaa mahdollisuuden tehtävien kirjanpitoon ja tehtyjen tehtävien tulostamiseen. Oletetaan että tehtävät ovat aina kokonaislukuja.</p>

<pre class="sh_java">
public class Tehtavakirjanpito {
    private Set&lt;Integer&gt; tehdytTehtavat;

    public Tehtavakirjanpito() {
        this.tehdytTehtavat = new HashSet&lt;Integer&gt;();
    }

    public void lisaa(int tehtava) {
        this.tehdytTehtavat.add(tehtava);
    }

    public void tulosta() {
        for (int tehtava: this.tehdytTehtavat) {
            System.out.println(tehtava);
        }
    }
}
</pre>

<pre class="sh_java">
        Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
        kirjanpito.lisaa(1);
        kirjanpito.lisaa(1);
        kirjanpito.lisaa(2);
        kirjanpito.lisaa(3);

        kirjanpito.tulosta();
</pre>

<pre>
1
2
3
</pre>

    <p>Yllä oleva ratkaisu toimii tilanteessa, jossa emme tarvitse tietoa käyttäjistä eri käyttäjien tekemistä tehtävistä. Muutetaan tehtävien tallennuslogiikkaa siten, että tehtävät tallennetaan <em>käyttäjäkohtaisesti</em> hajautustaulua hyödyntäen. Käyttäjät tunnistetaan käyttäjän yksilöivällä characterStringlla (esimerkiksi opiskelijanumero), ja jokaiselle käyttäjälle on oma joukko tehdyistä tehtävistä.</p>

<pre class="sh_java">
public class Tehtavakirjanpito {
    private Map&lt;String, Set&lt;Integer&gt;&gt; tehdytTehtavat;

    public Tehtavakirjanpito() {
        this.tehdytTehtavat = new HashMap&lt;String, Set&lt;Integer&gt;&gt;();
    }

    public void lisaa(String kayttaja, int tehtava) {
        // huomaa miten uudelle käyttäjälle on lisättävä HashMapiin ensin tyhjä tehtäväjoukko
        if (!this.tehdytTehtavat.containsKey(kayttaja)) {
            this.tehdytTehtavat.put(kayttaja, new HashSet&lt;Integer&gt;());
        }

        // haetaan ensin käyttäjän tehtävät sisältävä joukko ja tehdään siihen lisäys
        Set&lt;Integer&gt; tehdyt = this.tehdytTehtavat.get(kayttaja);
        tehdyt.add(tehtava);

        // edellinen olisi onnitunut myös ilman apumuuttujaa seuraavasti
        //  this.tehdytTehtavat.get(kayttaja).add(tehtava);
    }

    public void tulosta() {
        for (String kayttaja: this.tehdytTehtavat.keySet()) {
            System.out.println(kayttaja + ": " + this.tehdytTehtavat.get(kayttaja));
        }
    }
}
</pre>

<pre class="sh_java">
        Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
        kirjanpito.lisaa("Mikael", 3);
        kirjanpito.lisaa("Mikael", 4);
        kirjanpito.lisaa("Mikael", 3);
        kirjanpito.lisaa("Mikael", 3);

        kirjanpito.lisaa("Pekka", 4);
        kirjanpito.lisaa("Pekka", 4);

        kirjanpito.lisaa("Matti", 1);
        kirjanpito.lisaa("Matti", 2);

        kirjanpito.tulosta();
</pre>

<pre>
Matti: [1, 2]
Pekka: [4]
Mikael: [3, 4]
</pre>


    <p>Huomaamme että käyttäjien nimet eivät tulostu esimerkissä	 järjestyksessä. Tämä selittyy sillä että <code>HashMap</code>-tyyppisessä hajautustaulussa alkioiden tallennus tapahtuu <code>hashCode</code>-metodin palauttaman hajautusarvon perusteella, eikä se liity millään tavalla alkioiden järjestykseen.</p>
 
<div class="tehtavat">

<h3>Sanakirja usealle käännökselle</h3>

<p>Tehdään hieman laajennettu versio viikolla 1 tehdystä sanakirjasta. Tehtävänäsi on toteuttaa pakkaukseen <code>sanakirja</code> luokka <code>OmaUseanKaannoksenSanakirja</code>, joka voi tallettaa yhden tai useamman käännöksen jokaiselle sanalle. Luokan tulee toteuttaa tehtäväpohjassa annettu rajapinta <code>UseanKaannoksenSanakirja</code>, jossa on seuraavat toiminnot:</p>

<p>
  <ul>
    <li><code>public void lisaa(String sana, String kaannos)</code></li>lisää käännöksen sanalle säilyttäen vanhat käännökset<br/>
    <li><code>public Set&lt;String&gt; kaanna(String sana)</code></li>palauttaa <code>Set</code>-olion, jossa on kaikki käännökset sanalle, tai <code>null</code>-viitteen, jos sanaa ei ole sanakirjassa<br/>
    <li><code>public void poista(String sana)</code></li>poistaa sanan ja sen kaikki käännökset sanakirjasta<br/>
  </ul>
</p>

<p>Käännökset kannattanee tallentaa yllä olevan esimerkin Tehtavakirjanpito tapaan <code>Map&lt;String, Set&lt;String&gt;&gt;</code>-tyyppiseen oliomuuttujaan.</p>

<p>Rajapinnan koodi:</p>

<pre class="sh_java">
package sanakirja;

import java.util.Set;

public interface UseanKaannoksenSanakirja {
    void lisaa(String sana, String kaannos);
    Set&lt;String&gt; kaanna(String sana);
    void poista(String sana);
}
</pre>

<p>Esimerkkiohjelma:</p>

<pre class="sh_java">
    UseanKaannoksenSanakirja sanakirja = new OmaUseanKaannoksenSanakirja();
    sanakirja.lisaa("kuusi", "six");
    sanakirja.lisaa("kuusi", "spruce");

    sanakirja.lisaa("pii", "silicon");
    sanakirja.lisaa("pii", "pi");

    System.out.println(sanakirja.kaanna("kuusi"));
    sanakirja.poista("pii");
    System.out.println(sanakirja.kaanna("pii"));
</pre>

<p>Tulostuu:</p>

<pre>
[six, spruce]
null
</pre>

</div>



<div class="tehtavat">
  <h3>Duplikaattien poistaja</h3>

  <p>Tehtävänäsi on toteuttaa pakkaukseen <code>tyokalut</code> luokka <code>OmaDuplikaattienPoistaja</code>, joka tallettaa annetut characterStringt siten, että annetuista characterStringista poistetaan samanlaiset characterStringt (eli duplikaatit). Lisäksi luokka pitää kirjaa duplikaattien määrästä. Luokan tulee toteuttaa tehtäväpohjassa annettu rajapinta <code>DuplikaattienPoistaja</code>, jossa on seuraavat toiminnot:</p>

  <p>
    <ul>
      <li><code>public void lisaa(String characterString)</code></li> tallettaa characterStringn, jos se ei ole duplikaatti<br/>
      <li><code>public int getHavaittujenDuplikaattienMaara()</code></li> palauttaa tähän mennessä havaittujen duplikaattien määrän<br/>
      <li><code>public Set&lt;String&gt; getUniikitcharacterStringt()</code></li> palauttaa <code>Set&lt;String&gt;</code>-rajapinnan toteuttavan olion, jossa on kaikki uniikit lisätyt characterStringt (ei siis duplikaatteja!). Jos characterStringja ei ole, palautetaan tyhjä joukko-olio.<br/>
      <li><code>public void tyhjenna()</code></li> poistaa talletetut characterStringt ja nollaa havaittujen duplikaattien määrän<br/>
    </ul>
  </p>

  <p>Rajapinnan koodi:</p>

<pre class="sh_java">
package tyokalut;

import java.util.Set;

public interface DuplikaattienPoistaja {
    void lisaa(String characterString);
    int getHavaittujenDuplikaattienMaara();
    Set&lt;String&gt; getUniikitcharacterStringt();
    void tyhjenna();
}
</pre>

  <p>Rajapintaa voi käyttää esimerkiksi näin:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        DuplikaattienPoistaja poistaja = new OmaDuplikaattienPoistaja();
        poistaja.lisaa("eka");
        poistaja.lisaa("toka");
        poistaja.lisaa("eka");

        System.out.println("Duplikaattien määrä nyt: " +
            poistaja.getHavaittujenDuplikaattienMaara());

        poistaja.lisaa("vika");
        poistaja.lisaa("vika");
        poistaja.lisaa("uusi");

        System.out.println("Duplikaattien määrä nyt: " +
            poistaja.getHavaittujenDuplikaattienMaara());

        System.out.println("Uniikit characterStringt: " +
            poistaja.getUniikitcharacterStringt());

        poistaja.tyhjenna();

        System.out.println("Duplikaattien määrä nyt: " +
            poistaja.getHavaittujenDuplikaattienMaara());

        System.out.println("Uniikit characterStringt: " +
            poistaja.getUniikitcharacterStringt());
    }
</pre>

  <p>Yllä oleva ohjelma tulostaisi: (characterStringjen järjestys saa vaihdella, sillä ei ole merkitystä)</p>

<pre>
Duplikaattien määrä nyt: 1
Duplikaattien määrä nyt: 2
Uniikit characterStringt: [eka, toka, vika, uusi]
Duplikaattien määrä nyt: 0
Uniikit characterStringt: []
</pre>

</div>

<h3>Yksi olio useammassa eri listassa, Map-rakenteessa tai joukossa</h3>

<p>Kuten muistamme, oliomuuttujat ovat viitetyyppisiä, eli muuttuja ei tallenna olioa itseään vaan viitteen olioon. Vastaavasti jos olio laitetaan esim. ArrayListaan, ei listalle talleteta olioa itseään vaan <em>viite</em> olioon. Mikään ei estäkään tallentamasta samaan olioon viitettä esim. useaan listaan tai HashMapiin. </p>

<p>Tarkastellaan esimerkkinä kirjastoa joka tallettaa kirjat hashMapeihin sekä kirjailijan että kirjan isbn-numeron perusteella. Tämän lisäksi kirjasto pitää kaikkia lainassa olevia sekä hyllyssä olevia kirjoja omalla listallaan.</p>

<pre class="sh_java">
public class Book {
    private String ISBN;
    private String kirjailija;
    private String name;
    private int vuosi;
    // ...
}

public class Booksto {
    private Map&lt String, Book&gt kirjaIsbnNumeronPerusteella;
    private Map&lt String, List&ltString&gt&gt kirjatBookilijanPerusteella;
    private List&ltBook&gt lainassaOlevatBookt;
    private List&ltBook&gt hyllyssaOlevatBookt;

    public void lisaaBookKokoelmaan(Book uusiBook){
        kirjaIsbnNumeronPerusteella.put(uusiBook.getIsbn(), uusiBook);
        kirjatBookilijanPerusteella.get(uusikirja.getBookilija()).add(uusiBook);
        hyllyssaOlevatBookt.add(uusiBook);
    }

    public Book haeBookIsbnNumeronPerusteella(String isbn){
        return kirjaIsbnNumeronPerusteella.get(isbn);
    }

    // ...
}
</pre>

<p>Jos olio on yhtäaikaa useassa kokoelmassa (listalla, joukossa tai map-rakenteessa), on kiinnitettävä erityistä huomiota, että kokoelmien tila on konsistentti. Jos esim. kirja päätetään poistaa, on se poistettava molemmista mapeista sekä lainassa/hyllyssä olevia kuvaavalta listalta.</p>

<div class="tehtavat">

  <h3>Numerotiedustelu</h3>

<p><b>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. Älä myöskään käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</b></p>


<p>Tehdään sovellus jonka avulla on mahdollista hallinnoida ihmisten puhelinnumeroita ja osoitteita.</p>

<p>Tehtävän voi suorittaa 1-5 pisteen laajuisena. Yhden pisteen laajuuteen on toteutettava seuraavat toiminnot:</p>

<ul>
  <li>1 puhelinnumeron lisäys henkilölle</li>
  <li>2 henkilön puhelinnumeroiden haku</li>
</ul>

<p>kahteen pisteeseen vaadittaan edellisten lisäksi</p>

<ul>
  <li>3 numeroa vastaavan henkilön nimen haku</li>
</ul>

<p>kolmeen pisteeseen vaadittaan edellisten lisäksi</p>

<ul>
  <li>4 osoitteen lisäys henkilölle</li>
  <li>5 henkilön tietojen (osoite ja puhelinnumero) haku</li>
</ul>

<p>neljään pisteeseen vaadittaan toiminto</p>

<ul>
  <li>6 henkilön tietojen poisto</li>
</ul>

<p>ja täysiin pisteeseen vaaditaan vielä</p>

<ul>
  <li>7 hakusanalla filtteröity listaus (nimen mukaan aakkostettuna), hakusana voi esiintyä henkilön nimessä tai osoitteessa</li>
</ul>

<p>Esimerkki ohjelman toiminnasta:</p>

<pre>
numerotiedustelu
käytettävissä olevat komennot:
 1 lisää numero
 2 hae numerot
 3 hae puhelinnumeroa vastaava henkilö
 4 lisää osoite
 5 hae henkilön tiedot
 6 poista henkilön tiedot
 7 filtteröity listaus
 x lopeta

command: <font color="red">1</font>
kenelle: <font color="red">pekka</font>
numero: <font color="red">040-123456</font>

command: <font color="red">2</font>
kenen: <font color="red">jukka</font>
  ei löytynyt

command: <font color="red">2</font>
kenen: <font color="red">pekka</font>
 <font color="red">040-123456</font>

command: <font color="red">1</font>
kenelle: <font color="red">pekka</font>
numero: <font color="red">09-222333</font>

command: <font color="red">2</font>
kenen: <font color="red">pekka</font>
 040-123456
 09-222333

command: <font color="red">3</font>
numero: <font color="red">02-444123</font>
 ei löytynyt

command: <font color="red">3</font>
numero: <font color="red">09-222333</font>
 pekka

command: <font color="red">5</font>
kenen: <font color="red">pekka</font>
  osoite ei tiedossa
  puhelinnumerot:
   040-123456
   09-222333

command: <font color="red">4</font>
kenelle: <font color="red">pekka</font>
katu: <font color="red">ida ekmanintie</font>
kaupunki: <font color="red">helsinki</font>

command: <font color="red">5</font>
kenen: <font color="red">pekka</font>
  osoite: ida ekmanintie helsinki
  puhelinnumerot:
   040-123456
   09-222333

command: <font color="red">4</font>
kenelle: <font color="red">jukka</font>
katu: <font color="red">korsontie</font>
kaupunki: <font color="red">vantaa</font>

command: <font color="red">5</font>
kenen: <font color="red">jukka</font>
  osoite: korsontie vantaa
  ei puhelinta

command: <font color="red">7</font>
hakusana (jos tyhjä, listataan kaikki): <font color="red">kk</font>

 jukka
  osoite: korsontie vantaa
  ei puhelinta

 pekka
  osoite: ida ekmanintie helsinki
  puhelinnumerot:
   040-123456
   09-222333

command: <font color="red">7</font>
hakusana (jos tyhjä, listataan kaikki): <font color="red">vantaa</font>

 jukka
  osoite: korsontie vantaa
  ei puhelinta

command: <font color="red">7</font>
hakusana (jos tyhjä, listataan kaikki): <font color="red">seppo</font>
 ei löytynyt

command: <font color="red">6</font>
kenet: <font color="red">jukka</font>

command: <font color="red">5</font>
kenen: <font color="red">jukka</font>
  ei löytynyt

command: <font color="red">x</font>
</pre>

<p>Huomioita:</p>
<ul>
  <li> Testien kannalta on oleellista että <em>käyttöliittymä</em> toimii kuten yllä olevassa esimerkissä. Sovellus voi itse päättää kuinka epäkelvot syötteet käsitellään. Testit sisältävät vaan kelvollisia syötteitä.</li>
  <li><em><strong>Ohjelman tulee käynnistyä kun tehtäväpohjassa oleva main-metodi suoritetaan, tehtävässä saa luoda vain yhden Scanner-olion.</strong></em></li>
<li> Älä käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</li>
<li>Älä käytä luokkein nimissä skandeja, ne saattavat aiheuttaa ongelmia testeihin!</li>
  <li>Yksinkertaisuuden vuoksi oletetaan että nimi on yksittäinen characterString, eli jos halutaan sukunimen mukaan aakkostetun tulostus viimeiseen toimintoon , nimi on annettava muodossa <em>mikkola pekka</em>.</li>
  <li>Henkilöllä voi olla useita puhelinnumeroja sekä osoite. Henkilöllä ei kuitenkaan ole välttämättä yhtään puhelinnumeroa tai osoite ei ole tiedossa.</li>
  <li>Jos henkilö poistetaan, ei mikään haku saa enää palauttaa henkilön tietoja.</li>
</ul>
</div>

<div class="tyhja"></div>



<div class="viikkoraja">Viikko 4</div>

<div class="tehtavat">


<NEXTWEEK></NEXTWEEK>
<h3>Rengastustoimisto</h3>

<p>Ohjelmoinnin perusteiden kuudennella viikolla teimme lintubongaria varten havaintotietokannan. Jatkamme hieman samasta teemasta, tällä kertaa teemme rengastustoimistolle ohjelman, jonka avulla pidetään kirjaa tiettynä vuotena rengastettujen lintujen havaintopaikoista.</p>

<big>
<p><strong>HUOM:</strong> saatat törmätä tehtävässä kummalliseen virheilmoitukseen <code>NoSuchMethodError: Lintu.equals(LLintu;)Z</code>, jos näin käy suorita <strong>clean and build</strong> eli paina harja ja vasara -kuvakkeesta.</p>
</big>

<h4>Linnun equals ja toString</h4>

<p>Rengastustoimisto tallettaa tiettynä vuotena rengastettettujen lintujen tiedot <code>Lintu</code>-olioihin:</p>

<pre class="sh_java">
public class Lintu {

    private String name;
    private String latinankielinenNimi;
    private int rengastusvuosi;

    public Lintu(String name, String latinankielinenNimi, int rengastusvuosi) {
        this.name = nimi;
        this.latinankielinenNimi = latinankielinenNimi;
        this.rengastusvuosi = rengastusvuosi;
    }

    @Override
    public String toString() {
        return this.latinankielinenNimi + "(" + this.rengastusvuosi + ")";
    }
}

</pre>

<p>Ideana on toteuttaa rengastustoimistoon toiminnallisuus jonka avulla voidaan pitää kirjaa tiettynä vuotena rengastettujen lintujen havaintojen lukumääristä ja havaintopaikoista. Havaintomääriä ja -paikkoja ei kuitenkaan talleteta Lintu-olioihin, vaan erilliseen HashMap:iin jonka avaimena käytetään Lintu-olioita. Kuten muistamme viikolta 2, on tälläisessä tapauksessa toteutettava luokalle <code>Lintu</code> metodit <code>equals(Object t)</code> ja <code>hashCode()</code>.</p>

<p>Joillain linnuilla on useita suomenkielisä nimiä (esim. punakottaraisesta käytetään edelleen joskus sen vanhaa nimitystä rusokottarainen), latinankielinen nimi on kuitenkin aina yksikäsitteinen. Tee luokalle <code>Lintu</code> <code>equals-</code> ja <code>hashCode-</code>metodit jotka toimivat siten, että lintu-oliot tulkitaan samoiksi jos niiden latinankielinen nimi ja rengastusvuosi ovat samat.</p>

<p>Esimerkki:</code>

<pre>
    Lintu lintu1 = new Lintu("punakottarainen", "Sturnus roseus", 2012);
    Lintu lintu2 = new Lintu("rusokottarainen", "Sturnus roseus", 2012);
    Lintu lintu3 = new Lintu("varis", "Corvus corone cornix", 2012);
    Lintu lintu4 = new Lintu("punakottarainen", "Sturnus roseus", 2000);

    System.out.println( lintu1.equals(lintu2));   // ovat sama koska sama latinankielinen nimi ja rengastusvuosi
    System.out.println( lintu1.equals(lintu3));   // eivät ole sama koska eri rengastusvuosi
    System.out.println( lintu1.equals(lintu4));   // eivät ole sama koska latinankielinen nimi eri
    System.out.println( lintu1.hashCode()==lintu2.hashCode() );
</pre>

<p>tulostuu:</p>

<pre>
true
false
false
true
</pre>

<h4>Rengastustoimisto</h4>

<p>Rengastustoimistolla on kaksi metodia: <code>public void havaitse(Lintu lintu, String paikka)</code> lisää linnulle havainnon ja havaintopaikan ja metodi <code>public void havainnot(Lintu lintu)</code> tulostaa alla olevan esimerkin mukaisesti parametrina olevan linnun havaintojen määrän ja havaintopaikat. Havaintopaikkojen tulostusjärjestyksellä ei ole testien läpimenon kannalta merkitystä.</p>

<p>Rengastustoimisto tallettaa havaintopaikat <code>Map&lt;Lintu, List&lt;String&gt;&gt;</code>-tyyppiseen oliomuuttujaan. Havaintojen lukumäärä selviää havaintopaikkojen listan pituudesta. Tarvittaessa voit ottaa tehtävään mallia luvusta 16.</p>

<p>Esimerkki rengastustoimiston käytöstä:</p>

<pre class="sh_java">
    Rengastustoimisto kumpulanRengas = new Rengastustoimisto();
  
    kumpulanRengas.havaitse( new Lintu("punakottarainen", "Sturnus roseus", 2012), "Arabia" );
    kumpulanRengas.havaitse( new Lintu("rusokottarainen", "Sturnus roseus", 2012), "Vallila" );
    kumpulanRengas.havaitse( new Lintu("harmaalokki", "Larus argentatus", 2008), "Kumpulanmäki" );
    kumpulanRengas.havaitse( new Lintu("punakottarainen", "Sturnus roseus", 2008), "Mannerheimintie" );

    kumpulanRengas.havainnot( new Lintu("rusokottarainen", "Sturnus roseus", 2012 ) );
    System.out.println("--");
    kumpulanRengas.havainnot( new Lintu("harmaalokki", "Larus argentatus", 2008 ) );
    System.out.println("--");
    kumpulanRengas.havainnot( new Lintu("harmaalokki", "Larus argentatus", 1980 ) );
</pre>

<p>tulostuu:</p>

<pre>
Sturnus roseus (2012) havaintoja: 2
Arabia
Vallila
--
Larus argentatus (2008) havaintoja: 1
Kumpulanmäki
--
Larus argentatus (1980) havaintoja: 0
</pre>

</div>


<h2>Olioiden monimuotoisuus</h2>

    <p>Olemme aiemmissa kappaleissa törmänneet tilanteisiin, joissa muuttujilla on oman tyyppinsä lisäksi muita tyyppejä. Esimerkiksi kappaleessa <a href="#45">45</a> huomasimme että <em>kaikki</em> oliot ovat tyyppiä <code>Object</code>. Jos olio on jotain tiettyä tyyppiä, voidaan se myös esittää <code>Object</code>-tyyppisenä muuttujana. Esimerkiksi <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html" target="_blank">String</a></code> on myös tyyppiä <code>Object</code>, joten kaikki <code>String</code>-tyyppiset muuttujat voidaan esitellä <code>Object</code> tyypin avulla.</p>

<pre class="sh_java">
    String characterString = "characterString";
    Object characterStringString = "toinen characterString";
</pre>

    <p>characterString-olion asettaminen <code>Object</code>-tyyppiseen viitteeseen onnistuu.</p>

<pre class="sh_java">
    String characterString = "characterString";
    Object characterStringString = characterString;
</pre>

    <p>Toiseen suuntaan asettaminen ei onnistu. Koska <code>Object</code>-tyyppiset muuttujat eivät ole tyyppiä <code>String</code>, ei object-tyyppistä muuttujaa voi asettaa <code>String</code>-tyyppiseen muuttujaan.</p>

<pre class="sh_java">
    Object characterStringString = "toinen characterString";
    String characterString = characterStringString; // EI ONNISTU!
</pre>

    <p>Mistä tässä oikein on kyse?</p>

    <p>Muuttujilla on oman tyyppinsä lisäksi aina perimiensä luokkien ja toteuttamiensa rajapintojen tyypit. Luokka <code>String</code> perii <code>Object</code>-luokan, joten <code>String</code>-oliot ovat aina myös tyyppiä <code>Object</code>. Luokka <code>Object</code> ei peri <code>String</code>-luokkaa, joten <code>Object</code>-tyyppiset muuttujat eivät ole automaattisesti tyyppiä <code>String</code>. Tutustutaan tarkemmin <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html">String</a></code>-luokan API-dokumentaatioon, erityisesti HTML-sivun yläosaan.</p>

    <p><img src="img-ohja/perinta/string-api.png"/></p>

    <p>String-luokan API-dokumentaatio alkaa yleisellä otsakkeella jota seuraa luokan pakkaus (<code>java.lang</code>). Pakkauksen jälkeen tulee luokan nimi (<code>Class String</code>), jota seuraa luokan <em>perintähierarkia</em>.</p>

<pre>
<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html">java.lang.Object</a>
  <img src="img-ohja/perinta/perinta.gif"/><strong>java.lang.String</strong>
</pre>

    <p>Perintähierarkia listaa luokat, jotka luokka on perinyt. Perityt luokat listataan perimisjärjestyksessä, tarkasteltava luokka aina alimpana. String-luokan perintähierarkiasta näemme, että <code>String</code>-luokka perii luokan <code>Object</code>. <em>Javassa jokainen luokka voi periä korkeintaan yhden luokan</em>, mutta välillisesti niitä voi periä useampia.</p>
    <p>Perintähierarkiaa voi ajatella myös listana tyypeistä, joita olio toteuttaa.</p>

    <p>Se, että kaikki oliot ovat tyyppiä <code>Object</code> helpottaa ohjelmointia. Jos tarvitsemme metodissa vain <code>Object</code>-luokassa määriteltyjä toimintoja, voimme käyttää metodin parametrina tyyppiä <code>Object</code>. Koska kaikki oliot ovat myös tyyppiä object, voi metodille antaa <em>minkä tahansa</em> olion parametrina. Luodaan metodi <code>tulostaMonesti</code>, joka saa parametrinaan <code>Object</code>-tyyppisen muuttujan ja tulostusten lukumäärän.</p>

<pre class="sh_java">
public class Tulostin {
    ...
    public void tulostaMonesti(Object object, int times) {
        for (int i = 0; i &lt; kertaa; i++) {
            System.out.println(object.toString());
        }
    }
    ...
}
</pre>

    <p>Metodille <code>tulostaMonesti</code> voi antaa parametrina minkä tahansa olion. Metodin <code>tulostaMonesti</code> sisässä oliolla on käytössään vain <code>Object</code>-luokassa määritellyt metodit koska olio <em>esitellään</em> metodissa <code>Object</code>-tyyppisenä.</p>

<pre class="sh_java">
    Tulostin tulostin = new Tulostin();

    String characterString = " o ";
    List&lt;String&gt; sanat = new ArrayList&lt;String&gt;();
    sanat.add("polymorfismi");
    sanat.add("perintä");
    sanat.add("kapselointi");
    sanat.add("abstrahointi");

    tulostin.tulostaMonesti(characterString, 2);
    tulostin.tulostaMonesti(sanat, 3);
</pre>

<pre>
 o
 o
[polymorfismi, perintä, kapselointi, abstrahointi]
[polymorfismi, perintä, kapselointi, abstrahointi]
[polymorfismi, perintä, kapselointi, abstrahointi]
</pre>


    <p>Jatketaan <code>String</code>-luokan API-kuvauksen tarkastelua. Kuvauksessa olevaa perintähierarkiaa seuraa listaus luokan toteuttamista rajapinnoista.</p>

<pre>
<strong>All Implemented Interfaces:</strong>
  <A HREF="http://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html" title="interface in java.io">Serializable</A>, <A HREF="http://docs.oracle.com/javase/6/docs/api/java/lang/CharSequence.html" title="interface in java.lang">CharSequence</A>, <A HREF="http://docs.oracle.com/javase/6/docs/api/java/lang/Comparable.html" title="interface in java.lang">Comparable</A>&lt;<A HREF="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html" title="class in java.lang">String</A>&gt;
</pre>

    <p>Luokka <code>String</code> toteuttaa rajapinnat <code>Serializable</code>, <code>CharSequence</code>, ja <code>Comparable&lt;String&gt;</code>. Myös rajapinta on tyyppi. Luokan String API-kuvauksen mukaan String-olion tyypiksi voi asettaa seuraavat rajapinnat.</p>

<pre class="sh_java">
    Serializable serializableString = "characterString";
    CharSequence charSequenceString = "characterString";
    Comparable&lt;String&gt; comparableString = "characterString";
</pre>

    <p>Koska metodeille voidaan määritellä metodin parametrin tyyppi, voimme määritellä metodeja jotka vastaanottavat <em>tietyn rajapinnan toteuttavan</em> olion. Kun metodille määritellään parametrina rajapinta, sille voidaan antaa parametrina mikä tahansa olio joka toteuttaa kyseisen rajapinnan, metodi ei välitä olion oikeasta tyypistä.</p>

    <p>Täydennetään <code>Tulostin</code>-luokkaa siten, että sillä on metodi <code>CharSequence</code>-rajapinnan toteuttavien olioiden merkkien tulostamiseen. Rajapinta <code>CharSequence</code> tarjoaa muunmuassa metodit <code>int length()</code>, jolla saa characterStringn pituuden, ja <code>char charAt(int index)</code>, jolla saa merkin tietyssä indeksissä.</p>

<pre class="sh_java">
public class Tulostin {
    ...
    public void tulostaMonesti(Object object, int times) {
        for (int i = 0; i &lt; kertaa; i++) {
            System.out.println(object.toString());
        }
    }

    public void tulostaMerkit(CharSequence charSequence) {
        for (int i = 0; i &lt; charSequence.length(); i++) {
            System.out.println(charSequence.charAt(i);
        }
    }
    ...
}
</pre>

    <p>Metodille <code>tulostaMerkit</code> voi antaa minkä tahansa <code>CharSequence</code>-rajapinnan toteuttavan olion. Näitä on muunmuassa <code>String</code> ja characterStringjen rakentamisessa usein Stringiä tehokkaampi <code>StringBuilder</code>. Metodi <code>tulostaMerkit</code> tulostaa annetun olion jokaisen merkin omalle rivilleen.</p>

<pre class="sh_java">
    Tulostin tulostin = new Tulostin();

    String mjono = "toimii";

    tulostin.tulostaMerkit(mjono);
</pre>

<pre>
t
o
i
m
i
i
</pre>

<div class="tehtavat">

<h3>Joukkoja</h3>

<p>Tässä tehtävässä teemme eliöita ja eliöistä koostuvia laumoja jotka liikkuvat ympäriinsä. Eliöiden sijaintien ilmoittamiseen käytetään  <em>kaksiulotteista koordinaatistoa</em>. Jokaiseen sijaintiin liittyy kaksi lukua, <code>x</code>- ja <code>y</code>-koordinaatti. Koordinaatti <code>x</code> kertoo, kuinka pitkällä "nollapisteestä" mitattuna sijainti on vaakasuunnassa, ja koordinaatti <code>y</code> vastaavasti kuinka pitkällä sijainti on pystysuunnassa. Jos koordinaatiston käsite ei ole tuttu, voit lukea siitä lisää esimerkiksi <a href="http://fi.wikipedia.org/wiki/Koordinaatisto">wikipediasta</a>.</p>

<p>Tehtävän mukana tulee rajapinta <code>Siirrettava</code>, joka kuvaa asiaa jota voidaan siirtää paikasta toiseen. Rajapinta sisältää metodin <code>void siirra(int dx, int dy)</code>. Parametri <code>dx</code> kertoo, paljonko asia siirtyy x-akselilla ja <code>dy</code> y-akselilla.</p>

<p>Tehtävässä toteutat luokat <code>Elio</code> ja <code>Lauma</code>, jotka molemmat ovat siirrettäviä. Toteuta kaikki toiminnallisuus pakkaukseen <code>siirrettava</code>.</p>

<h4>Elio-luokan toteuttaminen</h4>

<p>Luo pakkaukseen <code>siirrettava</code> luokka <code>Elio</code>, joka toteuttaa rajapinnan <code>Siirrettava</code>. Eliön tulee tietää oma sijaintinsa (x, y -koordinaatteina). Luokan <code>Elio</code> APIn tulee olla seuraava:</p>

  <ul>
    <li><strong>public Elio(int x, int y)</strong><br/>Luokan konstruktori, joka saa olion aloitussijainnin x- ja y-koordinaatit parametrina</li>
    <li><strong>public String toString()</strong><br/> Luo ja palauttaa oliosta characterStringesityksen. Eliön characterStringesityksen tulee olla seuraavanlainen <code>"x: 3; y: 6"</code>. Huomaa että koordinaatit on erotettu puolipisteellä (<code>;</code>)</li>
    <li><strong>public void siirra(int dx, int dy)</strong><br/> Siirtää oliota parametrina saatujen arvojen verran. Muuttuja <code>dx</code> sisältää muutoksen koordinaattiin <code>x</code>, muuttuja <code>dy</code> sisältää muutoksen koordinaattiin <code>y</code>. Esimerkiksi jos muuttujan <code>dx</code> arvo on 5, tulee oliomuuttujan <code>x</code> arvoa kasvattaa viidellä</li>
  </ul>

<p>Kokeile luokan <code>Elio</code> toimintaa seuraavalla esimerkkikoodilla. </p>

<pre class="sh_java">
     Elio elio = new Elio(20, 30);
     System.out.println(elio);
     elio.siirra(-10, 5);
     System.out.println(elio);
     elio.siirra(50, 20);
     System.out.println(elio);
</pre>

<pre>
x: 20; y: 30
x: 10; y: 35
x: 60; y: 55
</pre>

<h4>Lauman toteutus</h4>

<p>Luo seuraavaksi pakkaukseen <code>siirrettava</code> luokka <code>Lauma</code>, joka toteuttaa rajapinnan <code>Siirrettava</code>. Lauma koostuu useasta <code>Siirrettava</code>-rajapinnan toteutavasta oliosta, jotka tulee tallettaa esimerkiksi listarakenteeseen.</p>

<p>Luokalla <code>Lauma</code> tulee olla seuraavanlainen API.</p>

  <ul>
    <li><strong>public String toString()</strong><br/> Palauttaa characterStringesityksen lauman jäsenten sijainnista rivin vaihdolla erotettuna.</li>
    <li><strong>public void lisaaLaumaan(Siirrettava siirrettava)</strong><br/> Lisää laumaan uuden <code>Siirrettava</code>-rajapinnan toteuttavan olion</li>
    <li><strong>public void siirra(int dx, int dy)</strong><br/> Siirtää laumaa parametrina saatujen arvojen verran. Huomaa että tässä sinun tulee siirtää jokaista lauman jäsentä.</li>
  </ul>

<p>Kokeile ohjelmasi toimintaa alla olevalla esimerkkikoodilla.</p>

<pre class="sh_java">
    Lauma lauma = new Lauma();
    lauma.lisaaLaumaan(new Elio(73, 56));
    lauma.lisaaLaumaan(new Elio(57, 66));
    lauma.lisaaLaumaan(new Elio(46, 52));
    lauma.lisaaLaumaan(new Elio(19, 107));
    System.out.println(lauma);
</pre>

<pre>
x: 73; y: 56
x: 57; y: 66
x: 46; y: 52
x: 19; y: 107
</pre>
</div>

<h2>Luokan ominaisuuksien periminen</h2>

    <p>Luokat ovat ohjelmoijan tapa ratkaistavan ongelma-alueen käsitteiden selkeyttämiseen. Lisäämme jokaisella luomallamme luokalla uutta toiminnallisuutta ohjelmointikieleen. Toiminnallisuutta tarvitaan kohtaamiemme ongelmien ratkomiseen, ratkaisut syntyvät luokista luotujen olioiden välisen interaktion avulla. Olio-ohjelmoinnissa olio on itsenäinen kokonaisuus, jolla on olion tarjoamien metodien avulla muutettava tila. Olioita käytetään yhteistyössä; jokaisella oliolla on oma vastuualue. Esimerkiksi käyttöliittymäluokkamme ovat tähän mennessä hyödyntäneet <code>Scanner</code>-olioita.</p>

    <p>Jokainen Javan luokka perii luokan <code>Object</code>, eli jokainen luomamme luokka saa käyttöönsä kaikki <code>Object</code>-luokassa määritellyt metodit. Jos haluamme muuttaa <code>Object</code>-luokassa määriteltyjen metodien toiminnallisuutta tulee ne korvata (<code>Override</code>) määrittelemällä niille uusi toteutus luodussa luokassa.</p>

<p>Luokan <code>Object</code> perimisen lisäksi myös muiden luokkien periminen on mahdollista. Javan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/ArrayList.html" target="_blank">ArrayList</a></code>-luokan APIa tarkasteltaessa huomaamme että <code>ArrayList</code> perii luokan <code>AbstractList</code>. Luokka <code>AbstractList</code> perii luokan <code>AbstractCollection</code>, joka perii luokan <code>Object</code>.</p>

<pre>
<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html" target="_blank">java.lang.Object</a>
  <img src="img-ohja/perinta/perinta.gif" /><a href="http://docs.oracle.com/javase/6/docs/api/java/util/AbstractCollection.html" target="_blank">java.util.AbstractCollection</a>&lt;E&gt;
      <img src="img-ohja/perinta/perinta.gif" /><a href="http://docs.oracle.com/javase/6/docs/api/java/AbstractList.html" target="_blank">java.util.AbstractList</a>&lt;E&gt;
          <img src="img-ohja/perinta/perinta.gif" /><strong>java.util.ArrayList&lt;E&gt;</strong>
</pre>

        <p>Kukin luokka voi periä suoranaisesti yhden luokan. Välillisesti luokka kuitenkin perii kaikki perimänsä luokan ominaisuudet. Luokka <code>ArrayList</code> perii suoranaisesti luokan <code>AbstractList</code>, ja välillisesti luokat <code>AbstractCollection</code> ja <code>Object</code>. Luokalla <code>ArrayList</code> on siis käytössään luokkien <code>AbstractList</code>, <code>AbstractCollection</code> ja <code>Object</code> muuttujat, metodit <em>ja</em> rajapinnat.</p>

        <p>Luokan ominaisuudet peritään avainsanalla <code>extends</code>. Luokan perivää luokkaa kutsutaan aliluokaksi (<em>subclass</em>), perittävää luokkaa yliluokaksi (<em>superclass</em>). Tutustutaan erään autonvalmistajan järjestelmään, joka hallinnoi auton osia. Osien hallinan peruskomponentti on luokka <code>Osa</code>, joka määrittelee tunnuksen, valmistajan ja kuvauksen.</p>

<pre class="sh_java">
public class Osa {

    private String tunnus;
    private String valmistaja;
    private String kuvaus;

    public Osa(String tunnus, String valmistaja, String kuvaus) {
        this.tunnus = tunnus;
        this.valmistaja = valmistaja;
        this.kuvaus = kuvaus;
    }

    public String getTunnus() {
        return tunnus;
    }

    public String getKuvaus() {
        return kuvaus;
    }

    public String getValmistaja() {
        return valmistaja;
    }
}
</pre>

        <p>Yksi osa autoa on moottori. Kuten kaikilla osilla, myös moottorilla on valmistaja, tunnus ja kuvaus. Näiden lisäksi moottoriin liittyy moottorityyppi: esimerkiksi polttomoottori, sähkömoottori tai hybridi. Luodaan luokan <code>Osa</code> perivä luokka <code>Moottori</code>: moottori on osan erikoistapaus.</p>

<pre class="sh_java">
public class Moottori extends Osa {

    private String moottorityyppi;

    public Moottori(String moottorityyppi, String tunnus, String valmistaja, String kuvaus) {
        super(tunnus, valmistaja, kuvaus);
        this.moottorityyppi = moottorityyppi;
    }

    public String getMoottorityyppi() {
        return moottorityyppi;
    }
}
</pre>

        <p>Luokkamäärittely <code>public class Moottori extends Osa</code> kertoo että luokka <code>Moottori</code> perii luokan <code>Osa</code> toiminnallisuuden. Luokassa <code>Moottori</code> määritellään oliomuuttuja <code>moottorityyppi</code>.</p>

        <p>Moottori-luokan konstruktori on mielenkiintoinen. Konstruktorin ensimmäisellä rivillä on avainsana <code>super</code>, jolla kutsutaan yliluokan konstruktoria. Kutsu <code>super(tunnus, valmistaja, kuaus)</code> kutsuu luokassa <code>Osa</code> määriteltyä konstruktoria <code>public Osa(String tunnus, String valmistaja, String kuvaus</code>, jolloin yliluokassa määritellyt oliomuuttujat saavat arvonsa. Tämän jälkeen oliomuuttujalle <code>moottorityyppi</code> asetetaan siihen liittyvä arvo.</p>

        <p>Kun luokka <code>Moottori</code> perii luokan <code>Osa</code>, saa se käyttöönsä kaikki luokan <code>Osa</code> tarjoamat metodit. Luokasta <code>Moottori</code> voi tehdä ilmentymän aivan kuten mistä tahansa muustakin luokata.</p>

<pre class="sh_java">
        Moottori moottori = new Moottori("polttomoottori", "hz", "volkswagen", "VW GOLF 1L 86-91");
        System.out.println(moottori.getMoottorityyppi());
        System.out.println(moottori.getValmistaja());
</pre>

<pre>
polttomoottori
volkswagen
</pre>

        <p>Kuten huomaat, luokalla <code>Moottori</code> on käytössä luokassa <code>Osa</code> määritellyt metodit.</p> 

        <h3>Private, protected ja public</h3>

<p>Jos metodilla tai muuttujalla on näkyvyysmääre <code>private</code>, ei se näy aliluokille eikä aliluokalla ole mitään suoraa tapaa päästä käsiksi yliluokan siihen. Edellisessä esimerkissä Moottori ei siis pääse suoraan käsiksi yliluokassa Osa määriteltyihin ominaisuuksiinsa (tunnus, valmistaja, kuvaus). Aliluokka näkee luonnollisesti kaiken yliluokan julkisen eli <code>public</code>-määreellä varustetun kaluston. Jos halutaan määritellä yliluokkaan joitain muuttujia tai metodeja joiden näkeminen halutaan sallia aliluokille, mutta estää muilta voidaan käyttää näkyvyysmäärettä <code>protected</code>.</p>

        <h3>Yliluokka super</h3>

        <p>Yliluokan konstruktoria kutsutaan avainsanalla <code>super</code>. Kutsu <code>super</code> on käytännössä samanlainen kuin <code>this</code>-konstruktorikutsu. Kutsulle annetaan parametrina yliluokan konstruktorin vaatiman tyyppiset arvot.</p>

        <p>Konstruktoria kutsuttaessa yliluokassa määritellyt muuttujat alustetaan. Konstruktorikutsussa tapahtuu käytännössä täysin samat asiat kuin normaalissa konstruktorikutsussa. Jos yliluokassa ei ole määritelty parametritonta konstruktoria, tulee aliluokan konstruktorikutsuissa olla aina mukana yliluokan konstruktorikutsu.</p>

        <p>Huom! Kutsun <code>super</code> tulee olla aina konstruktorin ensimmäisellä rivillä!</p>

<h3>Yliluokan metodin kutsuminen</h3>

        <p>Yliluokassa määriteltyjä metodeja voi kutsua <code>super</code>-etuliitteen avulla, aivan kuten tässä luokassa määriteltyjä metodeja voi kutsua <code>this</code>-etuliitteellä. Esimerkiksi yliluokassa määriteltyä <code>toString</code>-metodia voi hyödyntää sen korvaavassa metodissa seuraavasti:</p>

<pre class="sh_java">
    @Override
    public String toString() {
        return super.toString() + "\n  Ja oma viestini vielä!";
    }
</pre>

<div class="tehtavat">
  <h3>Henkilö ja sen perilliset</h3>

  <h4 class="req">Person</h4>

  <p>Tee pakkaus <code>henkilot</code> ja sinne luokka <code>Person</code>, joka toimii seuraavan pääohjelman yhteydessä</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Person pekka = new Person("Pekka Mikkola", "Korsontie 1 03100 Vantaa");
        Person esko = new Person("Esko Ukkonen", "Mannerheimintie 15 00100 Helsinki");
        System.out.println(pekka);
        System.out.println(esko);
    }
</pre>

  <p>siten että tulostuu</p>

<pre>
Pekka Mikkola
  Korsontie 1 03100 Vantaa
Esko Ukkonen
  Mannerheimintie 15 00100 Helsinki
</pre>

<h4 class="req">Opiskelija</h4>

  <p>Tee pakkaukseen luokka <code>Opiskelija</code> joka <i>perii</i> luokan <code>Person</code>.

  <p>Opiskelijalla on aluksi 0 opintopistettä. Aina kun opiskelija opiskelee, kasvaa opintopistemäärä. Toteuta luokka siten, että seuraava pääohjelma:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Opiskelija olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
        System.out.println(olli );
        System.out.println("opintopisteitä " + olli.opintopisteita());
        olli.opiskele();
        System.out.println("opintopisteitä "+ olli.opintopisteita());
    }
</pre>

  <p>tuottaa tulostuksen:</p>

<pre>
Olli
  Ida Albergintie 1 00400 Helsinki
opintopisteitä 0
opintopisteitä 1
</pre>

<h4 class="req">Opiskelijalle toString</h4>

  <p>Edellisessä tehtävässä <code>Opiskelija</code> perii toString-metodin luokalta <code>Person</code>. Perityn metodin voi myös ylikirjoittaa, eli korvata omalla versiolla. Tee nyt <code>Opiskelija</code>:lle oma versio toString:istä joka toimii seuraavan esimerkin mukaan:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Opiskelija olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
        System.out.println( olli );
        olli.opiskele();
        System.out.println( olli );
    }
</pre>

  <p>Tulostuu:</p>

<pre>
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitä 0
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitä 1
</pre>

  <h4 class="req">Opettaja</h4>

  <p>Tee pakkaukseen luokka <code>Person</code>:n perivä luokka <code>Opettaja</code>. Opettajalla on palkka joka tulostuu opettajan characterStringesityksessä. </p>

  <p>Testaa, että seuraava pääohjelma</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Opettaja pekka = new Opettaja("Pekka Mikkola", "Korsontie 1 03100 Vantaa", 1200);
        Opettaja esko = new Opettaja("Esko Ukkonen", "Mannerheimintie 15 00100 Helsinki", 5400);
        System.out.println( pekka );
        System.out.println( esko );

        Opiskelija olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
        for ( int i=0; i &lt; 25; i++ ) {
            olli.opiskele();
        }
        System.out.println( olli );
    }
</pre>

  <p>Aikaansaa tulostuksen</p>

<pre>
Pekka Mikkola
  Korsontie 1 03100 Vantaa
  palkka 1200 euroa/kk
Esko Ukkonen
  Mannerheimintie 15 00100 Helsinki
  palkka 5400 euroa/kk
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitä 25
</pre>

<h4 class="req">Kaikki Persont listalle</h4>

  <p>Toteuta oletuspakkauksessa olevaan <code>Main</code>-luokkaan luokkametodi <code>public static void tulostaLaitoksenPersont(List&lt;Person&gt; henkilot)</code>, joka tulostaa kaikki metodille parametrina annetussa listassa olevat henkilöt. Metodin tulee toimia seuraavasti <code>main</code>-metodista kutsuttaessa.</p>

<pre class="sh_java">
    public static void tulostaLaitoksenPersont(List&lt;Person&gt; henkilot) {
       // tulostetaan kaikki listan henkilöt
    }

    public static void main(String[] args) {
        List&lt;Person&gt; henkilot = new ArrayList&lt;Person&gt;();
        henkilot.add( new Opettaja("Pekka Mikkola", "Korsontie 1 03100 Vantaa", 1200) );
        henkilot.add( new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki") );

        tulostaLaitoksenPersont(henkilot);
    }
</pre>

<pre>
Pekka Mikkola
  Korsontie 1 03100 Vantaa
  palkka 1200 euroa/kk
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitä 0
</pre>

</div>

   <h3>Olion tyyppi määrää kutsutun metodin: Polymorfismi</h3>

    <p>Olion kutsuttavissa olevat metodit määrittyvät muuttujan tyypin kautta. Esimerkiksi jos <code>Opiskelija</code>-tyyppisen olion viite on talletettu  <code>Person</code>-tyyppiseen muuttujaan, on oliosta käytössä vain <code>Person</code>-luokassa määritellyt metodit:</p> 

<pre class="sh_java">
   Person olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
   olli.opintopisteita();        // EI TOIMI!
   olli.opiskele();              // EI TOIMI!
   String.out.println( olli );   // olli.toString() TOIMII
</pre>

<p>Jos oliolla on monta eri tyyppiä, on sillä käytössä <em>jokaisen</em> tyypin määrittelemät metodit. Esimerkiksi <code>Opiskelija</code>-tyyppisellä oliolla on käytössä <code>Person</code>-luokassa määritellyt metodit sekä <code>Object</code>-luokassa määritellyt metodit.</p> 

<p>Edellisessä tehtävässä korvasimme Opiskelijan luokalta Henkilö perimän <code>toString</code> uudella versiolla. Myös luokka Henkilö oli jo korvannut Object-luokalta perimänsä toStringin. Jos käsittelemme olioa jonkin muun kuin sen todellisen tyypin omaavan muuttujan kautta, mitä versiota olion metodista kutsutaa? Esim. seuraavassa on kaksi opiskelijaa joiden viitteet on talletettu Person- ja Object-tyyppisiin muuttujiin. Molemmille kutsutaan metodia <code>toString</code>. Mikä versio metodista suoritetaan, luokassa Object, Person vai Opiskelija määritelty?</p>

<pre class="sh_java">
   Person olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
   String.out.println( olli );   

   Object liisa = new Opiskelija("Liisa", "Väinö Auerin katu 20 00500 Helsinki");
   String.out.println( liisa );
</pre>

<p>Tulostuu:</p>

<pre>
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitä 0
Liisa
  Väinö Auerin katu 20 00500 Helsinki
  opintopisteitä 0
</pre>

<p>Eli suoritettava metodi valitaan olion todellisen tyypin perusteella, ei viitteen tallettavan muuttujan tyypin perusteella!</p>

    <p>Hieman yleisemmin: <b>Suoritettava metodi valitaan aina olion todellisen tyypin perusteella riippumatta käytetyn muuttujan tyypistä. Oliot ovat monimuotoisia, eli olioita voi käyttää usean eri muuttujatyypin kautta. Suoritettava metodi liittyy aina olion todelliseen tyyppiin.</b> Tätä monimuotoisuutta kutsutaan polymorfismiksi.</p>

<h3>Toinen esimerkki: pisteitä</h3>

<p>Kaksiulotteisessa koordinaatiostossa sijaitsevaa pistettä voisi kuvata seuraavan luokan avulla:</p>

<pre class="sh_java">
public class Piste {

    private int x;
    private int y;

    public Piste(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int manhattanEtaisyysOrigosta(){
        return Math.abs(x)+Math.abs(y);
    }
    
    protected String sijainti(){
        return x+", "+y;
    }

    @Override
    public String toString() {
        return "("+this.sijainti()+") etäisyys "+this.manhattanEtaisyysOrigosta();
    }    
}
</pre>

<p>Metodi <code>sijainti</code> ei ole tarkoitettu ulkoiseen käyttöön, joten se on näkyvyysmääreeltään protected, eli aliluokat pääsevät siihen käsiksi. Esim. <a href="http://wiki.gamegardens.com/Path_Finding_Tutorial">reitinhakualgoritmien</a> hyödyntämässä <a href="http://en.wiktionary.org/wiki/Manhattan_distance">Manhattan-etäisyydellä</a> tarkoitetaan pisteiden etäisyyttä, jos niiden välin voi kulkea ainoastaan koordinaattiakselien suuntaisesti. </p> 

<p>Värillinen piste on muuten samanlainen kuin piste, mutta se sisältää characterStringna ilmaistavan värin. Luokka voidaan siis tehdä perimällä Piste:</p>

<pre class="sh_java">
public class VariPiste extends Piste {

    private String vari;

    public VariPiste(int x, int y, String vari) {
        super(x, y);
        this.vari = vari;
    }

    @Override
    public String toString() {
        return super.toString()+" väri: "+vari; 
    }
}
</pre>

<p>Luokka määrittelee oliomuuttujan värin talletusta varten. Koordinaatit talletetaan yliluokkaan. characterStringesityksestä halutaan muuten samanlainen kuin pisteellä, mutta väri tulee myös ilmaista. Ylikirjoitettu metodi <code>toString</code> kutsuukin yliluokan toStringiä ja lisää sen tulokseen pisteen värin.</p>

<p>Seuraavassa esimerkki, jossa listalle laitetaan muutama piste, osa normaaleja ja osa väripisteitä ja tulostetaan listalla olevat pisteet. Polymorfismin ansioista kaikille tulee kutsutuksi olion todellisen tyypin toString-metodi vaikka lista tuntee kaikki pisteet <code>Piste</code>-tyyppisinä:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        List<Piste> pisteet = new ArrayList<Piste>(); 
        pisteet.add(new Piste(4, 8));
        pisteet.add(new VariPiste(1, 1, "vihreä"));
        pisteet.add(new VariPiste(2, 5, "sininen"));
        pisteet.add(new Piste(0, 0));
        
        for (Piste piste : pisteet) {
            System.out.println(piste);
        }
    }
}
</pre>

<p>Tulostuu:</p>

<pre>
(4, 8) etäisyys 12
(1, 1) etäisyys 2 väri: vihreä
(2, 5) etäisyys 7 väri: sininen
(0, 0) etäisyys 0
</pre>

<p>Haluamme ohjelmaamme myös kolmeulotteisen pisteen. Koska kyseessä ei ole värillinen versio, periytetään se pisteestä:</p>

<pre class="sh_java">
public class Piste3D extends Piste {

    private int z;

    public Piste3D(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    protected String sijainti() {
        return super.sijainti()+", "+z;    // tulos characterString muotoa "x, y, z"
    }    

    @Override
    public int manhattanEtaisyysOrigosta() {
        // kysytään ensin yliluokalta x:n ja y:n perusteella laskettua etäisyyttä 
        // ja lisätään tulokseen z-koordinaatin vaikutus
        return super.manhattanEtaisyysOrigosta()+Math.abs(z);   
    }    
    
    @Override
    public String toString() {
        return "("+this.sijainti()+") etäisyys "+this.manhattanEtaisyysOrigosta();
    }    
}
</pre>

<p>Kolmiulotteinen piste siis määrittelee kolmatta koordinaattia vastaavan oliomuuttujan ja ylikirjoittaa metodit <code>sijainti</code>,
  <code>manhattanEtaisyysOrigosta</code> ja <code>toString</code> siten, että ne huomioivat kolmannen ulottuvuuden. Voimme nyt laajentaa edellistä esimerkkiä ja lisätä listalle myös kolmiulotteisia pisteitä:</p>

<pre class="sh_java">
public class Main {

    public static void main(String[] args) {
        List<Piste> pisteet = new ArrayList<Piste>(); 
        pisteet.add(new Piste(4, 8));
        pisteet.add(new VariPiste(1, 1, "vihreä"));
        pisteet.add(new VariPiste(2, 5, "sininen"));
        pisteet.add(new Piste3D(5, 2, 8));
        pisteet.add(new Piste(0, 0));
        
        for (Piste piste : pisteet) {
            System.out.println(piste);
        }
    }
}
</pre>

<p>Tulostus on odotusten mukainen</p>

<pre>
(4, 8) etäisyys 12
(1, 1) etäisyys 2 väri: vihreä
(2, 5) etäisyys 7 väri: sininen
(5, 2, 8) etäisyys 15
(0, 0) etäisyys 0
</pre>

<p>Huomamme, että kolmiulotteisen pisteen metodi <code>toString</code> on täsmälleen sama kuin pisteen toString. Voisimmeko jättää toStringin ylikirjoittamatta? Vastaus on kyllä! Kolmiulotteinen piste pelkistyy seuraavanlaiseksi:</p>

<pre class="sh_java">
public class Piste3D extends Piste {

    private int z;

    public Piste3D(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    protected String sijainti() {
        return super.sijainti()+", "+z;
    }    

    @Override
    public int manhattanEtaisyysOrigosta() {
        return super.manhattanEtaisyysOrigosta()+Math.abs(z);
    }      
}
</pre>

<p>Mitä tarkalleenottaen tapahtuu kuin kolmiulotteiselle pisteelle kutsutaan toString-metodia? Suoritus etenee seuraavasti:</p>
<ol>
<li>etsitään toString:in määrittelyä luokasta Piste3D, sitä ei löydy joten mennään yliluokkaan</li>
<li>etsitään toString:in määrittelyä yliluokasta Piste, metodi löytyy, joten suoritetaan sen koodi</li>
<ul>
<li>suoritettava koodi siis on <code>return "("+this.sijainti()+") etäisyys "+this.manhattanEtaisyysOrigosta();</code></li>
<li>esimmäisenä suoritetaan metodi sijainti</li>
<li>etsitään metodin sijainti määrittelyä luokasta Piste3D, metodi löytyy ja suoritetaan sen koodi</li>
<li>metodin sijainti laskee oman tuloksensa kutsumalla yliluokassa olevaa metodia sijainti</li>
<li>seuraavaksi etsitään metodin manhattanEtaisyysOrigosta määrittelyä luokasta Piste3D, metodi löytyy ja suoritetaan sen koodi</li>
<li>jälleen metodi laskee tuloksensa kutsuen ensin yliluokassa olevaa samannimistä metodia</li>
</ul>
</ol>

<p>Metodikutsun aikaansaama toimintoketju siis on varsin monivaiheinen. Periaate on kuitenkin selkeä: suoritettavan metodin määrittelyä etsitään ensin olion todellisen tyypin määrittelystä ja jos sitä ei löydy edetään yliluokkaan. Ja jos yliluokastakaan ei löydy metodin toteutusta siirrytään etsimään yliluokan yliluokasta jne...</p>

          <h3>Milloin perintää tulee käyttää?</h3>

          <p>Perintä on väline käsitehierarkioiden rakentamiseen ja erikoistamiseen; aliluokka on aina yliluokan erikoistapaus. Jos luotava luokka on olemassaolevan luokan erikoistapaus, voidaan uusi luokka luoda perimällä olemassaoleva luokka. Esimerkiksi auton osiin liittyvässä esimerkissä moottori <em>on</em> osa, mutta moottoriin liittyy lisätoiminnallisuutta mitä jokaisella osalla ei ole.</p>

          <p>Perittäessä aliluokka saa käyttöönsä yliluokan toiminnallisuudet. Jos aliluokka ei tarvitse tai käytä perittyä toiminnallisuutta, ei perintä ole perusteltua. Perityt luokat perivät yliluokkiensa metodit ja rajapinnat, eli aliluokkia voidaan käyttää missä tahansa missä yliluokkaa on käytetty. Perintähierarkia kannattaa mitää matalana, sillä hierarkian ylläpito ja jatkokehitys vaikeutuu perintöhierarkian kasvaessa. Yleisesti ottaen, jos perintähierarkian korkeus on yli 2 tai 3, ohjelman rakenteessa on todennäköisesti parannettavaa.</p>

          <p>Perinän käyttöä tulee miettiä. Esimerkiksi luokan <code>Auto</code> periminen luokasta <code>Osa</code> (tai <code>Moottori</code>) on väärin. Auto <em>sisältää</em> moottorin ja osia, mutta auto ei ole moottori tai osa. Voimme yleisemmin ajatella että jos olio omistaa tai koostuu toisista olioista, ei perintää tule käyttää.</p>

          <p>Perintää käytettäessä tulee varmistaa että Single Responsibility Principle pätee myös perittäessä. Jokaisella luokalla tulee olla vain yksi syy muuttua. Jos huomaat että perintä lisää luokan vastuita, tulee luokka pilkkoa useammaksi luokaksi.</p>

          <h4>Esimerkki: perinnän väärinkäyttö</h4>

          <p>Pohditaan postituspalveluun liittyviä luokkia <code>Asiakas</code>, joka sisältää asiakkaan tiedot, ja <code>Tilaus</code>, joka perii asiakkaan tiedot ja sisältää tilattavan tavaran tiedot. Luokassa <code>Tilaus</code> on myös metodi <code>postitusOsoite</code>, joka kertoo tilauksen postitusosoitteen.</p>

<pre class="sh_java">
public class Asiakas {

    private String name;
    private String osoite;

    public Asiakas(String name, String osoite) {
        this.name = nimi;
        this.osoite = osoite;
    }

    public String getName() {
        return nimi;
    }

    public String getOsoite() {
        return osoite;
    }

    public void setOsoite(String osoite) {
        this.osoite = osoite;
    }
}
</pre>

<pre class="sh_java">
public class Tilaus extends Asiakas {

    private String tuote;
    private String lukumaara;

    public Tilaus(String tuote, String lukumaara, String name, String osoite) {
        super(nimi, osoite);
        this.tuote = tuote;
        this.lukumaara = lukumaara;
    }

    public String getTuote() {
        return tuote;
    }

    public String getLukumaara() {
        return lukumaara;
    }

    public String postitusOsoite() {
        return this.getName() + "\n" + this.getOsoite();
    }
}
</pre>

  <p>Yllä perintää on käytetty väärin. Luokkaa perittäessä aliluokan tulee olla yliluokan erikoistapaus; tilaus ei ole asiakkaan erikoistapaus. Väärinkäyttö ilmenee single responsibility principlen rikkomisena: luokalla <code>Tilaus</code> on vastuu sekä asiakkaan tietojen ylläpidosta, että tilauksen tietojen ylläpidosta.</p>

  <p>Ratkaisussa piilevä ongelma tulee esiin kun mietimme mitä käy asiakkaan osoitteen muuttuessa.</p>

  <p>Osoitteen muuttuessa joudumme muuttamaan <em>jokaista</em> kyseiseen asiakkaaseen liittyvää tilausoliota, mikä kertoo huonosta tilanteesta. Parempi ratkaisu olisi kapseloida <code>Asiakas</code> <code>Tilaus</code>-luokan oliomuuttujaksi. Jos ajattelemme tarkemmin tilauksen semantiikkaa, tämä on selvää. <em>Tilauksella on asiakas</em>. Muutetaan luokkaa <code>Tilaus</code> siten, että se sisältää <code>Asiakas</code>-viitteen.</p>

<pre class="sh_java">
public class Tilaus {

    private Asiakas asiakas;
    private String tuote;
    private String lukumaara;

    public Tilaus(Asiakas asiakas, String tuote, String lukumaara) {
        this.asiakas = asiakas;
        this.tuote = tuote;
        this.lukumaara = lukumaara;
    }

    public String getTuote() {
        return tuote;
    }

    public String getLukumaara() {
        return lukumaara;
    }

    public String postitusOsoite() {
        return this.asiakas.getName() + "\n" + this.asiakas.getOsoite();
    }
}
</pre>

    <p>Yllä oleva luokka <code>Tilaus</code> on nyt parempi. Metodi <code>postitusosoite</code> käyttää <em>asiakas</em>-viitettä postitusosoitteen saamiseen sen sijaan että luokka perisi luokan <code>Asiakas</code>. Tämä helpottaa sekä ohjelman ylläpitoa, että sen konkreettista toiminnallisuutta. </p>

    <p>Nyt asiakkaan muuttaessa tarvitsee muuttaa vain asiakkaan tietoja, tilauksiin ei tarvitse tehdä muutoksia.</p>

<div class="tehtavat">

<h3>Varastointia</h3>

<p>Tehtäväpohjassa tulee mukana luokka <code>Varasto</code>, jonka tarjoamat konstruktorit ja metodit ovat seuraavat:</p>

<ul>

<li><b>public Varasto(double tilavuus)</b><br/>
     Luo tyhjän varaston, jonka vetoisuus eli tilavuus annetaan parametrina;
     sopimaton tilavuus (&lt;=0) luo käyttökelvottoman varaston,
     jonka tilavuus on 0.</li>

<li><b>public double getSaldo()</b><br/>
     Palauttaa arvonaan varaston saldon, eli varastossa olevan tilavuuden.</li>


<li><b>public double getTilavuus()</b><br/>
     Palauttaa arvonaan varaston tilavuuden (eli sen, joka annettiin konstruktorille).</li>

<li><b>public double paljonkoMahtuu()</b><br/>
     Palauttaa arvonaan tiedon, paljonko varastoon vielä mahtuu.</li>

<li><b>public void lisaaVarastoon(double maara)</b><br/>
     Lisää varastoon pyydetyn määrän; jos määrä on negatiivinen, mikään ei muutu,
     jos kaikki pyydetty ei enää mahdu, varasto laitetaan
     täydeksi ja loput määräsätä "heitetään menemään", "vuotaa yli".</li>

<li><b>public double otaVarastosta(double maara)</b><br/>
    Otetaan varastosta pyydetty määrä, metodi palauttaa paljonko <b>saadaan</b>.
    Jos pyydetty määrä on negatiivinen, mikään ei muutu ja palautetaan nolla.
    Jos pyydetään enemmän kuin varastossa on, annetaan mitä voidaan ja varasto
    tyhjenee.</li>

<li><b>public String toString()</b><br/>
    Palauttaa olion tilan characterStringesityksenä tyyliin <tt>saldo = 64.5, tilaa 123.5</tt></li>
</ul>

        <p>Tehtävässä rakennetaan <code>Varasto</code>-luokasta useampia erilaisia varastoja. Huom! Toteuta kaikki luokat pakkaukseen <code>varastot</code>.</p>

        <h4 class="req">Tuotevarasto, vaihe 1</h4>

        <p>Luokka <code>Varasto</code> hallitsee tuotteen määrään liittyvät toiminnot. Nyt tuotteelle halutaan lisäksi tuotenimi ja nimen käsittelyvälineet. <i>  <b>Ohjelmoidaan Tuotevarasto Varaston aliluokaksi!</b></i> Toteutetaan ensin pelkkä yksityinen oliomuuttuja tuotenimelle, konstruktori ja getteri nimikentälle:</p>


<ul>
<li><b>public Tuotevarasto(String tuotenimi, double tilavuus)</b><br/>
     Luo tyhjän tuotevaraston. Tuotenimi ja vetoisuus annetaan parametrina.</li>


<li><b>public String getName()</b><br/>
     Palauttaa arvonaan tuotteen nimen.</li>
</ul>


        <p><i>Muista millä tavoin konstruktori voi ensi toimenaan suorittaa yliluokan konstruktorin!</i></p>

        <p>Käyttöesimerkki:</p>

<pre class="sh_java">
        Tuotevarasto mehu = new Tuotevarasto("Juice", 1000.0);
        mehu.lisaaVarastoon(1000.0);
        mehu.otaVarastosta(11.3);
        System.out.println(mehu.getName()); // Juice
        System.out.println(mehu);           // saldo = 988.7, tilaa 11.3
</pre>

<pre>
Juice
saldo = 988.7, vielä tilaa 11.3
</pre>


<h4 class="req">Tuotevarasto, vaihe 2</h4>


<p>Kuten edellisestä esimerkistä näkee, Tuotevarasto-olion perimä <code>toString()</code> ei tiedä (tietenkään!) mitään tuotteen nimestä. <i>Asialle on tehtävä jotain!</i> Lisätään samalla myös setteri tuotenimelle:</p>

<ul>
<li><b>public void setNimi(String uusiNimi)</b> asettaa tuotteelle
       uuden nimen.</li>

<li><b>public String toString()</b> palauttaa olion tilan characterStringesityksenä
       tyyliin <tt>Juice: saldo = 64.5, tilaa 123.5</tt></li>
</ul>

        <p>Uuden <code>toString()</code>-metodin voisi toki ohjelmoida käyttäen yliluokalta perittyjä gettereitä, joilla perittyjen, mutta piilossa pidettyjen kenttien arvoja saa käyttöönsä. Koska yliluokkaan on kuitenkin jo ohjelmoitu tarvittava taito varastotilanteen merkkiesityksen tuottamiseen, miksi nähdä vaivaa sen uudelleen ohjelmointiin. Käytä siis hyväksesi perittyä <code>toString</code>iä.</p>

        <p><i>Muista miten korvattua metodia voi kutsua aliluokassa!</i></p>

        <p>Käyttöesimerkki:</p>

<pre class="sh_java">
        Tuotevarasto mehu = new Tuotevarasto("Juice", 1000.0);
        mehu.lisaaVarastoon(1000.0);
        mehu.otaVarastosta(11.3);
        System.out.println(mehu.getName()); // Juice
        mehu.lisaaVarastoon(1.0);
        System.out.println(mehu);           // Juice: saldo = 989.7, tilaa 10.299999999999955
</pre>

<pre>
Juice
Juice: saldo = 989.7, tilaa 10.299999999999955
</pre>


<h4>Muutoshistoria</h4>

        <p>Toisinaan saattaa olla kiinostavaa tietää, millä tavoin jonkin tuotteen varastotilanne muuttuu: onko varasto usein hyvin vajaa, ollaanko usein ylärajalla, onko vaihelu suurta vai pientä, jne. Varustetaan siksi <code>Tuotevarasto</code>-luokka taidolla muistaa tuotteen määrän muutoshistoriaa.</p>

        <p>Aloitetaan apuvälineen laadinnalla.</p>

        <p>Muutoshistorian muistamisen voisi toki toteuttaa suoraankin <code>ArrayList&lt;Double&gt;</code>-oliona luokassa <i>Tuotevarasto</i>, mutta nyt laaditaan kuitenkin oma <i>erikoistettu väline</i> tähän tarkoitukseen. Väline toteutetaan kapseloimalla <code>ArrayList&lt;Double&gt;</code>-olio.</p>

        <p><code>Muutoshistoria</code>-luokan julkiset konstruktorit ja metodit:</p>

<ul>
<li><b>public Muutoshistoria()</b> luo tyhjän <code>Muutoshistoria</code>-olion.</li>

<li><b>public void lisaa(double tilanne)</b> lisää muutoshistorian viimeisimmäksi muistettavaksi määräksi parametrina annetun tilanteen. </li>

<li><b>public void nollaa()</b> tyhjää muistin.</li>

<li><b>public String toString()</b> palauttaa muutoshistorian
    characterStringesityksen. <i>ArrayList-luokan antama characterStringesitys kelpaa sellaisenaan.</i> </li>

</ul>


<h4 class="req">Muutoshistoria.java, vaihe 2</h4>

<p>
Täydennä <code>Muutoshistoria</code>-luokkaa analyysimetodein:</p>

<ul>

<li><b>public double maxArvo()</b> palauttaa muutoshistorian
   suurimman arvon. Jos historia on tyhjä, metodi palauttaa nollan.</li>


<li><b>public double minArvo()</b> palauttaa muutoshistorian
   pienimmän arvon. Jos historia on tyhjä, metodi palauttaa nollan.</li>

<li><b>public double keskiarvo()</b> palauttaa muutoshistorian
    arvojen keskiarvon. Jos historia on tyhjä, metodi palauttaa nollan.</li>

</ul>

<h4>Muutoshistoria.java, vaihe 3</h4>

<p>
Täydennä <code>Muutoshistoria</code>-luokkaa analyysimetodein:</p>

<ul>
<li><b>public double suurinMuutos()</b> palauttaa muutoshistorian isoimman (huom: -5:n kokoinen muutos on isompi kuin 4:n kokoinen muutos) yksittäisen muutoksen itseisarvon. Jos historia on tyhjä tai yhden arvon mittainen, metodi palauttaa nollan. Itseisarvo on luvun etäisyys nollasta. Esimerkiksi luvun -5.5 itseisarvo on 5.5, luvun 3.2 itseisarvo on 3.2. </li>

<li><b>public double varianssi()</b> palauttaa muutoshistorian arvojen varianssin (käytetään otosvarianssin kaavaa). Jos historia on tyhjä tai yhden arvon mittainen, metodi palauttaa nollan.</li>
</ul>

<p>Ohjeen varianssin laskemiseksi voit katsoa esimerkiksi <a href="http://fi.wikipedia.org/wiki/Varianssi#Populaatio-_ja_otosvarianssi">Wikipediasta</a> kohdasta populaatio- ja otosvarianssi. Esimerkiksi lukujen 3, 2, 7, 2 keskiarvo on 3.5, joten otosvarianssi on ((3 - 3.5)² + (2 - 3.5)² + (7 - 3.5)² + (2 - 3.5)²)/(4 - 1) ˜ 5,666667.)</p>




<h4 class="req">MuistavaTuotevarasto, vaihe 1</h4>

<p>
Toteuta luokan <code>Tuotevarasto</code> aliluokkana <code>MuistavaTuotevarasto</code>.
Uusi versio tarjoaa vanhojen lisäksi varastotilanteen muutoshistoriaan liittyviä
palveluita. Historiaa hallitaan <code>Muutoshistoria</code>-oliolla.
</p>

<p>
Julkiset konstruktorit ja metodit:</p>

<ul>

<li><b>public MuistavaTuotevarasto(String tuotenimi, double tilavuus, double alkuSaldo)</b>
     luo tuotevaraston. Tuotenimi, vetoisuus ja alkusaldo annetaan parametrina.
     <i>Aseta alkusaldo sekä varaston alkusaldoksi että muutoshistorian ensimmäiseksi arvoksi.</i>

<li><b>public String historia()</b> palauttaa tuotehistorian tyyliin
       <tt>[0.0, 119.2, 21.2]</tt>.  <i>Käytä Muutoshistoria-olion merkkiesitystä sellaisenaan.</i>

</ul>
<p>
<b>Huomaa</b> että tässä esiversiossa historia ei vielä toimi kunnolla; nyt vasta vain aloitussaldo muistetaan.
</p>

<p>
Käyttöesimerkki:
</p>

<pre class="sh_java">
// tuttuun tapaan:
MuistavaTuotevarasto mehu = new MuistavaTuotevarasto("Juice", 1000.0, 1000.0);
mehu.otaVarastosta(11.3);
System.out.println(mehu.getName()); // Juice
mehu.lisaaVarastoon(1.0);
System.out.println(mehu);           // Juice: saldo = 989.7, vielä tilaa 10.3
...
<b>// mutta vielä historia() ei toimi kunnolla:</b>
System.out.println(mehu.historia()); // [1000.0]
   // saadaan siis vasta konstruktorin asettama historian alkupiste...
...
</pre>


<p>
Tulostus siis:
</p>
<pre>
Juice
Juice: saldo = 989.7, vielä tilaa 10.299999999999955
[1000.0]
</pre>

<h4 class="req">MuistavaTuotevarasto, vaihe 2</h4>

<p>
<i>On aika aloittaa historia!</i> Ensimmäinen versio ei historiasta tiennyt kuin alkupisteen. Täydennä luokkaa metodein
</p>
<ul>

<li><b>public void lisaaVarastoon(double maara)</b>

    toimii kuin <i>Varasto</i>-luokan metodi, mutta muuttunut tilanne kirjataan historiaan.
<b>Huom: </b> historiaan tulee kirjata lisäyksen jälkeinen varastosaldo, ei lisättävää määrää!
</li>



<li><b>public double otaVarastosta(double maara)</b> toimii kuin <code>Varasto</code>-luokan metodi, mutta muuttunut tilanne kirjataan historiaan. <b>Huom: </b> historiaan tulee kirjata poiston jälkeinen varastosaldo, ei poistettavaa määrää!</li>

</ul>

<p>
Käyttöesimerkki:
</p>

<pre class="sh_java">
// tuttuun tapaan:
MuistavaTuotevarasto mehu = new MuistavaTuotevarasto("Juice", 1000.0, 1000.0);
mehu.otaVarastosta(11.3);
System.out.println(mehu.getName()); // Juice
mehu.lisaaVarastoon(1.0);
System.out.println(mehu);           // Juice: saldo = 989.7, vielä tilaa 10.3
...
// mutta nyt on historiaakin:
System.out.println(mehu.historia()); // [1000.0, 988.7, 989.7]
...
</pre>
<p>
Tulostus siis:
</p>
<pre>
Juice
Juice: saldo = 989.7, vielä tilaa 10.299999999999955
[1000.0, 988.7, 989.7]
</pre>
<p>

<p>
<i>Muista miten korvaava metodi voi käyttää hyväkseen korvattua metodia!</i>
</p>


<h4 class="req">MuistavaTuotevarasto, vaihe 3</h4>
<p>
Täydennä luokkaa metodilla
</p>
<ul>

<li><b>public void tulostaAnalyysi()</b>, joka tulostaa
     tuotteeseen liittyviä historiatietoja esimerkin
     esittämään tapaan.</li>
</ul>

<p>
Käyttöesimerkki:
</p>
<pre class="sh_java">
MuistavaTuotevarasto mehu = new MuistavaTuotevarasto("Juice", 1000.0, 1000.0);
mehu.otaVarastosta(11.3);
mehu.lisaaVarastoon(1.0);
//System.out.println(mehu.historia()); // [1000.0, 988.7, 989.7]

mehu.tulostaAnalyysi();
</pre>
<p>
Metodi <i>tulostaAnalyysi</i> kirjoittaa ilmoituksen tyyliin:
</p>

<pre>
Tuote: Juice
Historia: [1000.0, 988.7, 989.7]
Suurin tuotemäärä: 1000.0
Pienin tuotemäärä: 988.7
Keskiarvo: 992.8
</pre>
<p>

<h4>MuistavaTuotevarasto, vaihe 4</h4>
<p>
Täydennä analyysin tulostus sellaiseksi, että mukana ovat myös muutoshistorian suurin muutos ja historian varianssi.
</p>

</div>


<h3>Perintä, rajapinnat, kumpikin, vai eikö kumpaakaan?</h3>

<p>Perintä ei sulje pois rajapintojen käyttöä, eikä rajapintojen käyttö sulje pois perinnän käyttöä. Rajapinnat toimivat sopimuksena luokan tarjoamasta toteutuksesta, ja mahdollistavat konkreettisen toteutuksen abstrahoinnin. Rajapinnan toteuttavan luokan vaihto on hyvin helppoa.</p>

        <p>Aivan kuten rajapintaa toteuttaessa, sitoudumme perittäessä siihen, että aliluokkamme tarjoaa kaikki yliluokan metodit. Monimuotoisuuden ja polymorfismin takia perintäkin toimii kuin rajapinnat. Voimme antaa yliluokkaa käyttävälle metodille sen aliluokan ilmentymän.</p>

        <p>Tehdään seuraavaksi maatilasimulaattori, jossa simuloidaan maatilan elämää. Huomaa että ohjelmassa ei käytetä perintää, ja rajapintojenkin käyttö on melko vähäistä. Usein ohjelmat tehdäänkin niin että ensin toteutetaan yksi versio, jota lähdetään parantamaan myöhemmin. Tyypillistä on että ensimmäistä versiota toteutettaessa ongelma-aluetta ei vielä ymmärretä kunnolla, jolloin rajapintojen ja käsitehierarkioiden suunnittelu ennalta on hyvin vaikeaa ja saattaa jopa hidastaa työskentelyä.</p>


<div class="tehtavat">
<h3>Maatilasimulaattori</h3>

<p>
Maatiloilla on lypsäviä eläimiä, jotka tuottavat maitoa.  Maatilat
eivät itse käsittele maitoa, vaan se kuljetetaan Maitoautoilla
meijereille.  Meijerit ovat yleisiä maitotuotteita tuottavia
rakennuksia.  Jokainen meijeri erikoistuu yhteen tuotetyyppiin,
esimerkiksi Juustomeijeri tuottaa Juustoa, Voimeijeri tuottaa voita ja
Maitomeijeri tuottaa maitoa.
<p>

<p>
Rakennetaan maidon elämää kuvaava simulaattori. Toteuta kaikki luokat pakkaukseen <code>maatilasimulaattori</code>.
<p>


<h4>Maitosäiliö</h4>

<p>
Jotta maito pysyisi tuoreena, täytyy se säilöä sille tarkoitettuun säiliöön.
Säiliöitä valmistetaan sekä oletustilavuudella 2000 litraa, että
asiakkaalle räätälöidyllä tilavuudella.  Toteuta luokka Maitosailio
jolla on seuraavat konstruktorit ja metodit.
</p>

  <ul>
    <li><strong>public Maitosailio()</strong></li>
    <li><strong>public Maitosailio(double tilavuus)</strong></li>
    <li><strong>public double getTilavuus()</strong></li>
    <li><strong>public double getSaldo()</strong></li>
    <li><strong>public double paljonkoTilaaJaljella()</strong></li>
    <li><strong>public void lisaaSailioon(double maara)</strong>
      lisää säiliöön vain niin paljon maitoa kuin sinne mahtuu,
      ylimääräiset jäävät lisäämättä, maitosäiliön ei siis tarvitse huolehtia tilanteesta jossa maitoa valuu yli</li>
    <li><strong>public double otaSailiosta(double maara)</strong>
      ottaa säiliöstä pyydetyn määrän, tai niin paljon kuin siellä on jäljellä
    </li>
  </ul>

<p>
Toteuta <code>Maitosailio</code>-luokalle myös <code>toString()</code>-metodi, jolla kuvaat sen tilaa.
Ilmaistessasi säiliön tilaa <code>toString()</code>-metodissa, pyöristä litramäärät
ylöspäin käyttäen <code>Math</code>-luokan tarjoamaa <code>ceil()</code>-metodia.
</p>

<p>Testaa maitosailiötä seuraavalla ohjelmapätkällä:</p>

<pre class="sh_java">
        Maitosailio sailio = new Maitosailio();
        sailio.otaSailiosta(100);
        sailio.lisaaSailioon(25);
        sailio.otaSailiosta(5);
        System.out.println(sailio);

        sailio = new Maitosailio(50);
        sailio.lisaaSailioon(100);
        System.out.println(sailio);
</pre>


<p>Ohjelman tulostuksen tulee olla seuraavankaltainen:</p>

<pre>
20.0/2000.0
50.0/50.0
</pre>

<p>
Huomaa että kutsuttaessa <code>System</code>-luokan <code>out</code>-olioon liittyvää
<code>println()</code>-metodia, joka saa parametrikseen <code>Object</code>-tyyppisen
muuttujan, tulostus käyttää <code>Maitosailio</code>-luokassa korvattua
<code>toString()</code>-metodia! Tässä on kyse polymorfismista, eli
ajonaikaisesta käytettävien metodien päättelystä.
</p>

<h4>Lehmä</h4>

<p>Saadaksemme maitoa tarvitsemme myös lehmiä. Lehmällä on nimi ja utareet. Utareiden tilavuus on satunnainen luku väliltä 15 ja 40, luokkaa <code>Random</code> voi käyttäää satunnaislukujen arpomiseen, esimerkiksi  <code>int luku = 15 + new Random().nextInt(26);</code>. Luokalla <code>Lehma</code> on seuraavat toiminnot:</p>

  <ul>
    <li><strong>public Lehma()</strong> luo uuden lehmän satunnaisesti valitulla nimellä</li>
    <li><strong>public Lehma(String name)</strong> luo uuden lehmän annetulla nimellä</li>
    <li><strong>String getName()</strong> palauttaa lehmän nimen</li>
    <li><strong>double getTilavuus()</strong> palauttaa utareiden tilavuuden</li>
    <li><strong>double getMaara()</strong> palauttaa utareissa olevan maidon määrän</li>
    <li><strong>String toString()</strong> palauttaa lehmää kuvaavan characterStringn (ks. esimerkki alla)</li>
  </ul>

<p><code>Lehma</code> toteuttaa myös rajapinnat: <code>Lypsava</code>, joka kuvaa lypsämiskäyttäytymistä, ja <code>Eleleva</code>, joka kuvaa elelemiskäyttäytymistä.</p>

<pre class="sh_java">
public interface Lypsava {
    public double lypsa();
}

public interface Eleleva {
    public void eleleTunti();
}
</pre>

<p>
Lehmää lypsettäessä sen koko maitovarasto tyhjennetään jatkokäsittelyä
varten.  Lehmän elellessä sen maitovarasto täyttyy hiljalleen.
Suomessa maidontuotannossa käytetyt lehmät tuottavat keskimäärin
noin 25-30 litraa maitoa päivässä.  Simuloidaan tätä tuotantoa
tuottamalla noin 0.7 - 2 litraa tunnissa.
</p>

<p>
Jos lehmälle ei anneta nimeä, valitse sille nimi satunnaisesti seuraavasta listasta.
</p>

<pre class="sh_java">
    private static final String[] NIMIA = new String[]{
        "Anu", "Arpa", "Essi", "Heluna", "Hely",
        "Hento", "Hilke", "Hilsu", "Hymy", "Ihq", "Ilme", "Ilo",
        "Jaana", "Jami", "Jatta", "Laku", "Liekki",
        "Mainikki", "Mella", "Mimmi", "Naatti",
        "Nina", "Nyytti", "Papu", "Pullukka", "Pulu",
        "Rima", "Soma", "Sylkki", "Valpu", "Virpi"};
</pre>

<p>Toteuta luokka Lehma ja testaa sen toimintaa seuraavan ohjelmapätkän avulla.</p>

<pre class="sh_java">
        Lehma lehma = new Lehma();
        System.out.println(lehma);


        Eleleva elelevaLehma = lehma;
        elelevaLehma.eleleTunti();
        elelevaLehma.eleleTunti();
        elelevaLehma.eleleTunti();
        elelevaLehma.eleleTunti();

        System.out.println(lehma);

        Lypsava lypsavaLehma = lehma;
        lypsavaLehma.lypsa();

        System.out.println(lehma);
        System.out.println("");

        lehma = new Lehma("Ammu");
        System.out.println(lehma);
        lehma.eleleTunti();
        lehma.eleleTunti();
        System.out.println(lehma);
        lehma.lypsa();
        System.out.println(lehma);

</pre>

<p>
Ohjelman tulostus on erimerkiksi seuraavanlainen.</p>

</p>

<pre>
Liekki 0.0/23.0
Liekki 7.0/23.0
Liekki 0.0/23.0
Ammu 0.0/35.0
Ammu 9.0/35.0
Ammu 0.0/35.0
</pre>


<h4>Lypsyrobotti</h4>
<p>
Nykyaikaisilla maatiloilla lypsyrobotit hoitavat lypsämisen.
Jotta lypsyrobotti voi lypsää lypsävää otusta, tulee lypsyrobotin
olla kiinnitetty maitosäiliöön:
</p>

  <ul>
    <li><strong>public Lypsyrobotti()</strong> luo uuden lypsyrobotin</li>
    <li><strong>Maitosailio getMaitosailio()</strong> palauttaa kiinnitetyn maitosäiliö tai <code>null</code>-viitteen, jos säiliötä ei ole vielä kiinnitetty</li>
    <li><strong>void setMaitosailio(Maitosailio maitosailio)</strong> kiinnittää annetun säiliön lypsyrobottiin</li>
    <li><strong>void lypsa(Lypsava lypsava)</strong> lypsää lehmän robottiin kiinnitettyyn maitosäiliöön, metodi heittää poikkeuksen <code>IllegalStateException</code>, jos säiliötä ei ole kiinnitetty </li>
  </ul>

<p>Toteuta luokka Lypsyrobotti ja testaa sitä seuraavien ohjelmanpätkien avulla. Varmista että lypsyrobotti voi lypsää kaikkia Lypsava-rajapinnan toteuttavia olioita!</p>

<pre class="sh_java">
        Lypsyrobotti lypsyrobotti = new Lypsyrobotti();
        Lehma lehma = new Lehma();
        lypsyrobotti.lypsa(lehma);
</pre>

<pre>
Exception in thread "main" java.lang.IllegalStateException: Maitosäiliötä ei ole asennettu
        at maatilasimulaattori.Lypsyrobotti.lypsa(Lypsyrobotti.java:17)
        at maatilasimulaattori.Main.main(Main.java:9)
Java Result: 1
</pre>

<pre class="sh_java">
        Lypsyrobotti lypsyrobotti = new Lypsyrobotti();
        Lehma lehma = new Lehma();
        System.out.println("");

        Maitosailio sailio = new Maitosailio();
        lypsyrobotti.setMaitosailio(sailio);
        System.out.println("Säiliö: " + sailio);

        for(int i = 0; i &lt; 2; i++) {
            System.out.println(lehma);
            System.out.println("Elellään..");
            for(int j = 0; j &lt; 5; j++) {
                lehma.eleleTunti();
            }
            System.out.println(lehma);

            System.out.println("Lypsetään...");
            lypsyrobotti.lypsa(lehma);
            System.out.println("Säiliö: " + sailio);
            System.out.println("");
        }
</pre>

<p>Ohjelman tulostus on esimerkiksi seuraavanlainen.</p>

<pre>
Säiliö: 0.0/2000.0
Mella 0.0/23.0
Elellään..
Mella 6.2/23.0
Lypsetään...
Säiliö: 6.2/2000.0

Mella 0.0/23.0
Elellään..
Mella 7.8/23.0
Lypsetään...
Säiliö: 14.0/2000.0
</pre>

<h4>Navetta</h4>

<p>
Lehmät hoidetaan (eli tässä tapauksessa lypsetään) navetassa.
Alkukantaisissa navetoissa on maitosäiliö ja tilaa yhdelle
lypsyrobotille. Huomaa että lypsyrobottia asennettaessa se kytketään
juuri kyseisen navetan maitosäiliöön.  Jos navetassa ei ole
lypsyrobottia, ei siellä voida myöskään hoitaa lehmiä.
Toteuta luokka <code>Navetta</code> jolla on seuraavat konstruktorit ja metodit:
</p>

  <ul>
    <li><strong>public Navetta(Maitosailio maitosailio)</strong></li>
    <li><strong>public Maitosailio getMaitosailio()</strong> palauttaa navetan maitosailion</li>
    <li><strong>public void asennaLypsyrobotti(Lypsyrobotti lypsyrobotti)</strong> asentaa lypsyrobotin ja kiinnittää sen navetan maitosäiliöön</li>
    <li><strong>public void hoida(Lehma lehma)</strong> lypsää parametrina annetun lehmän lypsyrobotin avulla, metodi heittää poikkeuksen <code>IllegalStateException</code>, jos lypsyrobottia ei ole asennettu</li>
    <li><strong>public void hoida(Collection&lt;Lehma&gt; lehmat)</strong> lypsää parametrina annetut lehmät lypsyrobotin avulla, metodi heittää poikkeuksen <code>IllegalStateException</code>, jos lypsyrobottia ei ole asennettu</li>
    <li><strong>public String toString()</strong> palauttaa navetan sisältämän maitosäiliön tilan</li>
  </ul>

<p><code>Collection</code> on Javan oma rajapinta joka kuvaa kokoelmien käyttäytymistä.  Esimerkiksi luokat <code>ArrayList</code> ja <code>LinkedList</code> toteuttavat rajapinnan <code>Collection</code>. Jokaista <code>Collection</code>-rajapinnan toteuttavaa ilmentymää voi myös iteroida for-each-tyyppisesti.</p>

<p>
Testaa luokkaa <code>Navetta</code> seuraavan ohjelmapätkän avulla.
Älä hermoile luokasta <code>LinkedList</code>, se toimii ulkoapäin katsottuna
kuin <code>ArrayList</code>, mutta sen kapseloima toteutus on hieman erilainen.
Tästä lisää tietorakenteet-kurssilla!
</p>

<pre class="sh_java">
        Navetta navetta = new Navetta(new Maitosailio());
        System.out.println("Navetta: " + navetta);

        Lypsyrobotti robo = new Lypsyrobotti();
        navetta.asennaLypsyrobotti(robo);

        Lehma ammu = new Lehma();
        ammu.eleleTunti();
        ammu.eleleTunti();

        navetta.hoida(ammu);
        System.out.println("Navetta: " + navetta);

        LinkedList&lt;Lehma&gt; lehmaLista = new LinkedList();
        lehmaLista.add(ammu);
        lehmaLista.add(new Lehma());

        for(Lehma lehma: lehmaLista) {
            lehma.eleleTunti();
            lehma.eleleTunti();
        }

        navetta.hoida(lehmaLista);
        System.out.println("Navetta: " + navetta);
</pre>

<p>
Tulostuksen tulee olla esimerkiksi seuraavanlainen:
</p>

<pre>
Navetta: 0.0/2000.0
Navetta: 2.8/2000.0
Navetta: 9.6/2000.0
</pre>

<h4>Maatila</h4>

<p>
Maatilalla on omistaja ja siihen kuuluu navetta sekä joukko lehmiä.
Maatila toteuttaa myös aiemmin nähdyn rajapinnan <code>Eleleva</code>,
jonka metodia <code>eleleTunti()</code>-kutsumalla kaikki maatilaan
liittyvät lehmät elelevät tunnin.  Toteuta luokka maatila siten,
että se toimii seuraavien esimerkkiohjelmien mukaisesti.
</p>

<pre class="sh_java">
        Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
        System.out.println(maatila);

        System.out.println(maatila.getOmistaja() + " on ahkera mies!");
</pre>

<p>
Odotettu tulostus:
</p>

<pre>
Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Ei lehmiä.
Esko on ahkera mies!
</pre>


<pre class="sh_java">
        Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        System.out.println(maatila);
</pre>


<p>
Odotettu tulostus:
</p>

<pre>
Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Lehmät:
        Naatti 0.0/19.0
        Hilke 0.0/30.0
        Sylkki 0.0/29.0
</pre>

<pre class="sh_java">
        Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));

        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());

        maatila.eleleTunti();
        maatila.eleleTunti();
</pre>

<p>
Odotettu tulostus:
</p>

<pre>
Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Lehmät:
        Heluna 2.0/17.0
        Rima 3.0/32.0
        Ilo 3.0/25.0
</pre>

<pre class="sh_java">
        Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
        Lypsyrobotti robo = new Lypsyrobotti();
        maatila.asennaNavettaanLypsyrobotti(robo);

        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());

        maatila.eleleTunti();
        maatila.eleleTunti();

        maatila.hoidaLehmat();

        System.out.println(maatila);
</pre>

<p>
Odotettu tulostus:
</p>

<pre>
Maatilan omistaja: Esko
Navetan maitosäiliö: 18.0/2000.0
Lehmät:
        Hilke 0.0/30.0
        Sylkki 0.0/35.0
        Hento 0.0/34.0
</pre>
</div>


<h3>Abstrakti luokka</h3>

        <p>Abstrakti luokka yhdistää rajapintoja ja perintää. Niistä ei voi tehdä ilmentymiä, vaan ilmentymät tehdään tehdään abstraktin luokan aliluokista.  Abstrakti luokka voi sisältää sekä normaaleja metodeja, joissa on metodirunko, että abstrakteja metodeja, jotka sisältävät ainoastaan metodimäärittelyn. Abstraktien metodien toteutus jätetään perivän luokan vastuulle. Yleisesti ajatellen abstrakteja luokkia käytetään esimerkiksi kun abstraktin luokan kuvaama käsite ei ole selkeä itsenäinen käsite. Tällöin siitä ei tule pystyä tekemään ilmentymiä. </p>

        <p>Sekä abstraktin luokan että abstraktien metodien määrittelyssä käytetään avainsanaa <code>abstract</code>. Abstrakti luokka määritellään lauseella <code>public abstract class <em>LuokanNimi</em></code>, abstrakti metodi taas lauseella <code>public abstract <em>palautustyyppi</em> <em>metodinNimi</em></code>. Pohditaan seuraavaa abstraktia luokkaa <code>Toiminto</code>, joka tarjoaa rungon toiminnoille ja niiden suorittamiselle.</p>

<pre class="sh_java">
public abstract class Toiminto {

    private String name;

    public Toiminto(String name) {
        this.name = nimi;
    }

    public String getName() {
        return this.name;
    }

    public abstract void suorita(Scanner lukija);
}
</pre>

        <p>Abstrakti luokka <code>Toiminto</code> toimii runkona erilaisten toimintojen toteuttamiseen. Esimerkiksi pluslaskun voi toteuttaa perimällä luokka <code>Toiminto</code> seuraavasti.</p>

<pre class="sh_java">
public class Pluslasku extends Toiminto {

    public Pluslasku() {
        super("Pluslasku");
    }

    @Override
    public void suorita(Scanner lukija) {
        System.out.print("Anna ensimmäinen luku: ");
        int eka = Integer.parseInt(reader.nextLine());
        System.out.print("Anna toinen luku: ");
        int toka = Integer.parseInt(reader.nextLine());

        System.out.println("Lukujen summa on " + (eka + toka));
    }
}
</pre>

        <p>Koska kaikki <code>Toiminto</code>-luokan perivät luokat ovat myös tyyppiä toiminto, voimme rakentaa käyttöliittymän <code>Toiminto</code>-tyyppisten muuttujien varaan. Seuraava luokka <code>Kayttoliittyma</code> sisaltaa listan toimintoja ja lukijan. Toimintoja voi lisätä käyttöliittymään dynaamisesti.</p>

<pre class="sh_java">
public class Kayttoliittyma {

    private Scanner lukija;
    private List&lt;Toiminto&gt; toiminnot;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
        this.toiminnot = new ArrayList&lt;Toiminto&gt;();
    }

    public void lisaaToiminto(Toiminto toiminto) {
        this.toiminnot.add(toiminto);
    }

    public void start() {
        while (true) {
            tulostaToiminnot();
            System.out.println("Valinta: ");

            String valinta = this.reader.nextLine();
            if (valinta.equals("0")) {
                break;
            }

            suoritaToiminto(valinta);
            System.out.println();
        }
    }

    private void tulostaToiminnot() {
        System.out.println("\t0: Lopeta");
        for (int i = 0; i < this.toiminnot.size(); i++) {
            String toiminnonNimi = this.toiminnot.get(i).getName();
            System.out.println("\t" + (i + 1) + ": " + toiminnonNimi);
        }
    }

    private void suoritaToiminto(String valinta) {
        int toiminto = Integer.parseInt(valinta);

        Toiminto valittu = this.toiminnot.get(toiminto - 1);
        valittu.suorita(lukija);
    }
}
</pre>

        <p>Käyttöliittymä toimii seuraavasti:</p>

<pre class="sh_java">
        Kayttoliittyma kayttolittyma = new Kayttoliittyma(new Scanner(System.in));
        kayttolittyma.lisaaToiminto(new Pluslasku());

        kayttolittyma.start();
</pre>

<pre>
Toiminnot:
        0: Lopeta
        1: Pluslasku
Valinta: <font color="red">1</font>
Anna ensimmäinen luku: <font color="red">8</font>
Anna toinen luku: <font color="red">12</font>
Lukujen summa on 20

Toiminnot:
        0: Lopeta
        1: Pluslasku
Valinta: <font color="red">0</font>
</pre>

        <p>Rajapintojen ja abstraktien luokkien ero on siinä, että abstraktit luokat tarjoavat enemmän rakennetta ohjelmaan. Koska abstrakteihin luokkiin voidaan määritellä toiminnallisuutta, voidaan niitä käyttää esimerkiksi oletustoiminnallisuuden määrittelyyn. Yllä käyttöliittymä käytti abstraktissa luokassa määriteltyä toiminnan nimen tallentamista.</p>


<div class="tehtavat">
  <h3>Erilaisia laatikoita</h3>

  <p>Tehtäväpohjan mukana tulee luokat <code>Tavara</code> ja <code>Laatikko</code>. Luokka <code>Laatikko</code> on abstrakti luokka, jossa useamman tavaran lisääminen on toteutettu siten, että kutsutaan aina <code>lisaa</code>-metodia. Yhden tavaran lisäämiseen tarkoitettu metodi <code>lisaa</code> on abstrakti, joten jokaisen <code>Laatikko</code>-luokan perivän laatikon tulee toteuttaa se. Tehtävänäsi on muokata luokkaa <code>Tavara</code> ja toteuttaa muutamia erilaisia laatikoita luokan <code>Laatikko</code> pohjalta.</p>

  <p>Lisää kaikki uudet luokat pakkaukseen <code>laatikot</code>.</p>


<pre class="sh_java">
package laatikot;

import java.util.Collection;

public abstract class Laatikko {

    public abstract void lisaa(Tavara tavara);

    public void lisaa(Collection&lt;Tavara&gt; tavarat) {
        for (Tavara tavara : tavarat) {
            lisaa(tavara);
        }
    }

    public abstract boolean onkoLaatikossa(Tavara tavara);
}
</pre>

<h4>Tavaran muokkaus</h4>

  <p>Lisää <code>Tavara</code>-luokan konstruktoriin tarkistus, jossa tarkistetaan että tavaran paino ei ole koskaan negatiivinen (paino 0 hyväksytään). Jos paino on negatiivinen, tulee konstruktorin heittää <code>IllegalArgumentException</code>-poikkeus. Toteuta <code>Tavara</code>-luokalle myös metodit <code>equals</code> ja <code>hashCode</code>, joiden avulla  pääset hyödyntämään erilaisten listojen ja kokoelmien <code>contains</code>-metodia. Toteuta metodit siten, että Tavara-luokan oliomuuttujan <code>paino</code> arvolla ei ole väliä. <em>Voit hyvin hyödyntää NetBeansin tarjoamaa toiminnallisuutta equalsin ja hashCoden toteuttamiseen.</em></p>

<h4>Maksimipainollinen laatikko</h4>

  <p>Toteuta pakkaukseen <code>laatikot</code> luokka <code>MaksimipainollinenLaatikko</code>, joka perii luokan <code>Laatikko</code>. Maksimipainollisella laatikolla on konstruktori <code>public MaksimipainollinenLaatikko(int maksimipaino)</code>, joka määrittelee laatikon maksimipainon. Maksimipainolliseen laatikkoon voi lisätä tavaraa jos ja vain jos tavaran lisääminen ei ylitä laatikon maksimipainoa.</p>

<pre class="sh_java">
        MaksimipainollinenLaatikko kahviLaatikko = new MaksimipainollinenLaatikko(10);
        kahviLaatikko.lisaa(new Tavara("Saludo", 5));
        kahviLaatikko.lisaa(new Tavara("Pirkka", 5));
        kahviLaatikko.lisaa(new Tavara("Kopi Luwak", 5));

        System.out.println(kahviLaatikko.onkoLaatikossa(new Tavara("Saludo")));
        System.out.println(kahviLaatikko.onkoLaatikossa(new Tavara("Pirkka")));
        System.out.println(kahviLaatikko.onkoLaatikossa(new Tavara("Kopi Luwak")));
</pre>

<pre>
true
true
false
</pre>

<h4>Yhden tavaran laatikko ja Hukkaava laatikko</h4>

        <p>Toteuta seuraavaksi pakkaukseen <code>laatikot</code> luokka <code>YhdenTavaranLaatikko</code>, joka perii luokan <code>Laatikko</code>. Yhden tavaran laatikolla on konstruktori <code>public YhdenTavaranLaatikko()</code>, ja siihen mahtuu tasan yksi tavara. Jos tavara on jo laatikossa sitä ei tule vaihtaa. Laatikkoon lisättävän tavaran painolla ei ole väliä.</p>

<pre class="sh_java">
        YhdenTavaranLaatikko laatikko = new YhdenTavaranLaatikko();
        laatikko.lisaa(new Tavara("Saludo", 5));
        laatikko.lisaa(new Tavara("Pirkka", 5));

        System.out.println(laatikko.onkoLaatikossa(new Tavara("Saludo")));
        System.out.println(laatikko.onkoLaatikossa(new Tavara("Pirkka")));
</pre>

<pre>
true
false
</pre>


        <p>Toteuta seuraavaksi pakkaukseen <code>laatikot</code> luokka <code>HukkaavaLaatikko</code>, joka perii luokan <code>Laatikko</code>. Hukkaavalla laatikolla on konstruktori <code>public HukkaavaLaatikko()</code>. Hukkaavaan laatikkoon voi lisätä kaikki tavarat, mutta tavaroita ei löydy niitä etsittäessä. Laatikkoon lisäämisen tulee siis aina onnistua, mutta metodin <code>onkoLaatikossa</code> kutsumisen tulee aina palauttaa false.</p>

<pre class="sh_java">
        HukkaavaLaatikko laatikko = new HukkaavaLaatikko();
        laatikko.lisaa(new Tavara("Saludo", 5));
        laatikko.lisaa(new Tavara("Pirkka", 5));

        System.out.println(laatikko.onkoLaatikossa(new Tavara("Saludo")));
        System.out.println(laatikko.onkoLaatikossa(new Tavara("Pirkka")));
</pre>

<pre>
false
false
</pre>


</div>

<h3>Huomio olioiden poistamisesta ArrayListista</h3>

<p>Seuraavassa tehtävässä saatat joutua tilanteeseen, jossa haluat poistaa ArrayListiä läpikäydessäsi osan listan olioista:</p>

<pre class="sh_java">
   // joissain määritelty seuraavasti:
   // ArrayList&ltOlio&gt lista = new ... 

   for ( Olio olio : lista ) {
      if ( tarvitseePoistaa(olio) ) {
         lista.remove(olio);
      }
   }
</pre>

<p>Ratkaisu ei toimi ja aiheuttaa poikkeuksen <code>ConcurrentModificationException</code>, sillä listaa <em>foreach</em>-tyylillä läpikäydessä listaa ei saa muokata. Palaamme aiheeseen hieman tarkemmin viikolla 6. Jos törmäät tilanteeseen, voit hoitaa sen esim. seuraavasti:</p>

<pre class="sh_java">
   // joissain määritelty seuraavasti:
   // ArrayList&ltOlio&gt lista = new ... 

   ArrayList&ltOlio&gt poistettavat = new ArrayList&ltOlio&gt();

   for ( Olio olio : lista ) {
      if ( tarvitseePoistaa(olio) ) {
         poistattavat.add(olio);
      }
   }

   lista.removeAll(poistettavat);
</pre>

<p>Eli poistettavat oliot kerätään listan läpikäyntinä erilliselle listalle ja poisto-operaatio suoritetaan vasta listan läpikäynnin jälkeen.</p>

<div class="tehtavat">

<h3>Luola</h3>


  <p><em>Tämä tehtävä on neljän tehtäväpisteen arvoinen.</em> Huom! Toteuta kaikki toiminnallisuus pakkaukseen <code>luola</code>.</p>

<p><b>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. Älä käytä luokkien nimissä skandeja. Älä myöskään käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</b></p>


<p>Tässä tehtävässä pääset toteuttamaan luolapelin. Pelissä pelaaja on luolassa hirviöitten kanssa. Pelaajan tehtävänä on ehtiä tallata kaikki hirviöt ennen kuin hänen lampustaan loppuu virta ja hirviöt pääsevät pimeän turvin syömään hänet. Pelaaja voi nähdä hirviöiden sijainnit välkäyttämällä lamppua, jonka jälkeen hänen on liikuttava sokkona ennen seuraavaa välkäytystä. Pelaaja voi kulkea monta askelta yhden siirron aikana.</p>

<p>Pelitilanne eli luola, pelaaja ja hirviöt esitetään pelaajalle tekstimuotoisesti. Tulostuksen ensimmäinen rivi kertoo jäljellä olevien siirtojen (eli lampun jäljellä olevan virran) määrän. Virran määrää seuraa pelaajan ja hirviöitten sijainnit, joiden jälkeen on pelitilanteesta piirretty kartta. Alla olevassa esimerkissä näet pelaajan (<code>@</code>) ja kolme hirviötä (<code>h</code>).  Alla olevassa esimerkissä pelaajalla on virtaa neljääntoista siirtoon.</p>

<pre>
14

@ 1 2
h 6 1
h 7 3
h 12 2

.................
......h..........
.@.........h.....
.......h.........
</pre>

<p>Yllä olevassa esimerkissä virtaa on 14 välkäytykseen. Pelaaja <code>@</code> sijatsee koordinaatissa <code>1 2</code>. Huomaa että koordinaatit lasketaan aina pelialueen vasemmasta ylälaidasta lähtien. Alla olevassa kartassa merkki <code>X</code> on koordinaatissa <code>0 0</code>, <code>Y</code> koordinaatissa <code>2 0</code> ja <code>Z</code> koordinaatissa <code>0 2</code>.</p>

<pre>
X.Y..............
.................
Z................
.................
</pre>



<p>Käyttäjä voi liikkua antamalla sarjan komentoja ja painamalla rivinvaihtoa. Komennot ovat:</p>
<ul>
  <li><code>w</code> liiku ylöspäin</li>
  <li><code>s</code> liiku alaspäin</li>
  <li><code>a</code> liiku vasemmalle</li>
  <li><code>d</code> liiku oikealle</li>
</ul>

<p>Kun käyttäjän antamat komennot on suoritettu (niitä voi olla useampi), piirretään uusi pelitilanne. Lampun virta vähenee yhdellä aina kun uusi pelitilanne piirretään. Jos virta menee nollaan, peli loppuu ja ruudulle tulostetaan teksti <code>HÄVISIT</code></p>

<p>Hirviöt liikkuvat pelissä satunnaisesti, yhden askeleen jokaista pelaajan askelta kohti. Jos pelaaja ja hirviö osuvat samaan ruutuun (vaikka vain tilapäisesti), hirviö tuhoutuu. Jos hirviö yrittää siirtyä pelilaudalta ulos tai ruutuun jossa on jo hirviö, jätetään siirto suorittamatta. Kun kaikki hirviöt on tuhottu, peli loppuu ja tulostetaan <code>VOITIT</code>.</p>

<p>Testaamisen helpottamiseksi tee peliisi luokka <code>Luola</code>, jolla on  :</p>

<p>
  <ul>
    <li>konstruktori <strong><code>public Luola(int leveys, int korkeus, int hirvioita, int siirtoja, boolean hirviotLiikkuvat)</code></strong>
      <p>values <code>leveys</code> ja <code>korkeus</code> antavat luolan koon (se on aina neliskulmainen), <code>hirvioita</code> antaa hirviöiden lukumäärän alussa (hirviöiden sijainnin voi arpoa), <code>siirtoja</code> antaa siirtojen lukumäärän alussa ja jos <code>hirviotLiikkuvat</code> on <code>false</code>, hirviöt eivät liiku.</p></li>
    <li>metodi <strong><code>public void run()</code></strong> joka käynnistää pelin</li>
  </ul>
</p>

<p><em>Huom!</em> pelaajan tulee aloittaa sijainnista 0,0!</p>
<p><em>Huom!</em> jos pelaaja tai hirviö koittaa liikkua ulos luolasta
  tai kaksi hirviötä koittaa liikkua samaan ruutuun, ei liikettä tule
  tapahtua!</p>
</ul>

  <p>Alla vielä selkeyden vuoksi vielä esimerkkipeli:</p>

<pre>
14

@ 0 0
h 1 2
h 7 8
h 7 5
h 8 0
h 2 9

@.......h.
..........
.h........
..........
..........
.......h..
..........
..........
.......h..
..h.......

<font color="red">ssd</font>
13

@ 1 2
h 8 8
h 7 4
h 8 3
h 1 8

..........
..........
.@........
........h.
.......h..
..........
..........
..........
.h......h.
..........

<font color="red">ssss</font>
12

@ 1 6
h 6 9
h 6 5
h 8 3

..........
..........
..........
........h.
..........
......h...
.@........
..........
..........
......h...

<font color="red">dd</font>
11

@ 3 6
h 5 9
h 6 7
h 8 1

..........
........h.
..........
..........
..........
..........
...@......
......h...
..........
.....h....

<font color="red">ddds</font>
10

@ 6 7
h 6 6
h 5 0

.....h....
..........
..........
..........
..........
..........
......h...
......@...
..........
..........

<font color="red">w</font>
9

@ 6 6
h 4 0

....h.....
..........
..........
..........
..........
..........
......@...
..........
..........
..........

<font color="red">www</font>
8

@ 6 3
h 4 0

....h.....
..........
..........
......@...
..........
..........
..........
..........
..........
..........

<font color="red">aa</font>
7

@ 4 3
h 4 2

..........
..........
....h.....
....@.....
..........
..........
..........
..........
..........
..........

<font color="red">w</font>
VOITIT
</pre>


</div>

<!-- BEGIN SNIP -->

<div class="tyhja"></div>

<div class="viikkoraja">Viikko 5</div>

<h2 id="tiedostostoon_kirjoitus">Tiedostoon kirjoittaminen</h3>

<p>Luvussa 15 opimme, että tekstitiedostojen lukeminen onnistuu <code>Scanner</code>- ja <code>File</code>-luokkien avulla.
Luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/java/io/FileWriter.html">FileWriter</a></code> tarjoaa toiminnallisuuden tiedostoon kirjoittamiseen. Luokan <code>FileWriter</code> konstruktorille annetaan parametrina kohdetiedoston sijaintia kuvaava characterString.</p>

<pre class="sh_java">
        FileWriter kirjoittaja = new FileWriter("tiedosto.txt");
        kirjoittaja.write("Hei tiedosto!\n"); // rivinvaihto tulee myös kirjoittaa tiedostoon!
        kirjoittaja.write("Lisää tekstiä\n");
        kirjoittaja.write("Ja vielä lisää");
        kirjoittaja.close(); // sulkemiskutsu sulkee tiedoston ja varmistaa että kirjoitettu teksti menee tiedostoon
</pre>

    <p>Esimerkissä kirjoitetaan tiedostoon "tiedosto.txt" characterString "Hei tiedosto!", jota seuraa rivinvaihto, ja vielä hieman lisää tekstiä. Huomaa että tiedostoon kirjoitettaessa metodi <code>write</code> ei lisää rivinvaihtoja, vaan ne tulee lisätä itse.</p>

    <p>Sekä <code>FileWriter</code>-luokan konstruktori että <code>write</code>-metodi heittää mahdollisesti poikkeuksen, joka tulee joko käsitellä tai siirtää kutsuvan metodin vastuulle. Metodi, jolle annetaan parametrina kirjoitettavan tiedoston nimi ja kirjoitettava sisältö voisi näyttää seuraavalta.</p>

<pre class="sh_java">
public class Tallentaja {

    public void kirjoitaTiedostoon(String tiedostonNimi, String teksti) throws Exception {
        FileWriter kirjoittaja = new FileWriter(tiedostonNimi);
        kirjoittaja.write(teksti);
        kirjoittaja.close();
    }
}
</pre>

    <p>Yllä olevassa <code>kirjoitaTiedostoon</code>-metodissa luodaan ensin <code>FileWriter</code>-olio, joka kirjoittaa parametrina annetussa sijainnissa sijaitsevaan tiedostoon <code>tiedostonNimi</code>. Tämän jälkeen kirjoitetaan tiedostoon <code>write</code>-metodilla. Konstruktorin ja <code>write</code>-metodin mahdollisesti heittämä poikkeus tulee käsitellä joko <code>try-catch</code>-lohkolla tai siirtämällä poikkeuksen käsittely vastuuta eteenpäin. Metodissa <code>kirjoitaTiedostoon</code> käsittelyvastuu on siirretty eteenpäin.</p>

    <p>Luodaan <code>main</code>-metodi jossa kutsutaan <code>Tallentaja</code>-olion <code>kirjoitaTiedostoon</code>-metodia. Poikkeusta ei ole pakko käsitellä <code>main</code>-metodissakaan, vaan se voi ilmoittaa heittävänsä mahdollisesti poikkeuksen määrittelyllä <code>throws Exception</code>.</p>

<pre class="sh_java">
    public static void main(String[] args) throws Exception {
        Tallentaja tallentaja = new Tallentaja();
        tallentaja.kirjoitaTiedostoon("paivakirja.txt", "Rakas päiväkirja, tänään oli kiva päivä.");
    }
</pre>

    <p>Yllä olevaa metodia kutsuttaessa luodaan tiedosto "paivakirja.txt" johon kirjoitetaan teksti "Rakas päiväkirja, tänään oli kiva päivä.". Jos tiedosto on jo olemassa, pyyhkiytyy vanhan tiedoston sisältö uutta kirjoittaessa. Metodilla <code>append()</code> voidaan lisätä olemassaolevan tiedoston perään tekstiä, jolloin olemassaolevaa  tekstiä ei poisteta. Lisätään <code>Tallentaja</code>-luokalle metodi <code>lisaaTiedostoon()</code>, joka lisää parametrina annetun tekstin tiedoston loppuun.</p>

<pre class="sh_java">
public class Tallentaja {
    public void kirjoitaTiedostoon(String tiedostonNimi, String teksti) throws Exception {
        FileWriter kirjoittaja = new FileWriter(tiedostonNimi);
        kirjoittaja.write(teksti);
        kirjoittaja.close();
    }

    public void lisaaTiedostoon(String tiedostonNimi, String teksti) throws Exception {
        FileWriter kirjoittaja = new FileWriter(tiedostonNimi);
        kirjoittaja.append(teksti);
        kirjoittaja.close();
    }
}
</pre>

    <p>Useimmiten tiedoston perään metodilla <code>append</code> kirjoittamisen sijasta on helpompi kirjoittaa koko tiedosto uudelleen.</p>

<div class="tehtavat">

<NEXTWEEK></NEXTWEEK>
<h3>Tiedostonkäsittelijä</h3>

<p>Saat tehtävärungon mukana luokan <code>Tiedostonkasittelija</code> joka sisältää metodirungot tiedoston lukemista ja tiedostoon kirjoittamista varten.</p>

<h4>Tiedoston lukeminen</h4>

<p>Täydennä metodi <code>public ArrayList&lt;String&gt; lue(String tiedosto)</code> sellaiseksi, että se palauttaa parametrina annetun tekstitiedoston sisältämät rivit ArrayList:ina siten, että tiedoston jokainen rivi on omana characterStringnaan listalla.
</p>

<p>Projektissa on testaamista varten kaksi tekstitiedostoa <code>src/koesyote1.txt</code> ja <code>src/koesyote2.txt</code>. Metodia on tarjoitus käyttää seuraavalla tavalla: 
</p>

<pre class="sh_java">
    public static void main(String[] args) throws FileNotFoundException, IOException {
        TiedostonKasittelija t = new TiedostonKasittelija();

        for (String rivi : t.lue("src/koesyote1.txt")) {
            System.out.println(rivi);
        }
    }
</pre>

<p>Tulostuksen pitäisi olla</p>

<pre>
eka
toka
</pre>


<h4>Rivin kirjoittaminen tiedostoon</h4>

<p>Täydennä projektipohjan mukana tuleva metodi <code>public void tallenna(String tiedosto, String teksti)</code>  sellaiseksi, että se tallentaa ensimmäisen parametrin määrittelemään tiedostoon toisena parametrina annetun characterStringn. Jos tiedosto on jo olemassa, kirjoitetaan vanhan version päälle.
</p>


<h4>Rivin kirjoittaminen tiedostoo</h4>

<p>Täydennä projektipohjan mukana tuleva metodi <code>public void tallenna(String tiedosto, ArrayList<String> tekstit)</code> sellaiseksi, että se tallentaa ensimmäisen parametrin määrittelemään tiedostoon toisena parametrina annetun listan siten, että jokainen characterString tulee omalle rivilleen.  Jos tiedosto on jo olemassa, kirjoitetaan vanhan version päälle.
</p>

    <h3>Muistava kahteen suuntaan kääntävä sanakirja</h3>

    <p>Tässä tehtävässä laajennetaan aiemmin toteutettua sanakirjaa siten, että sanat voidaan lukea tiedostosta ja kirjoittaa tiedostoon. Sanakirjan tulee myös osata kääntää molempiin suuntiin, suomesta vieraaseen kieleen sekä toiseen suuntaan (tehtävässä oletetaan hieman epärealistisesti, että suomen kielessä ja vieraassa kielessä ei ole yhtään samalla tavalla kirjoitettavaa sanaa). Tehtävänäsi on luoda sanakirja luokkaan <code>MuistavaSanakirja</code> Toteuta luokka pakkaukseen <code>sanakirja</code>.</p>

<h4>Muistiton perustoiminnallisuus</h4>

<p>Tee sanakirjalle parametriton konstruktori sekä metodit:</p>

 <ul>
        <li><code>public void lisaa(String sana, String kaannos)</code></li>lisää sanan sanakirjaan. Jokaisella sanalla on vain yksi käännös, jos sama sana lisätään uudelleen, ei tapahdu mitään.<br/>
        <li><code>public String kaanna(String sana)</code></li> palauttaa käännöksen annetulle sanalle, jos sanaa ei tunneta, palautetaan null<br/>
 </ul>

<p>Sanakirjan tulee tässä vaiheessa toimia seuraavasti:</p>

<pre class="sh_java">
MuistavaSanakirja sanakirja = new MuistavaSanakirja();
sanakirja.lisaa("apina", "monkey");
sanakirja.lisaa("banaani", "banana");
sanakirja.lisaa("apina", "apfe");

System.out.println( sanakirja.kaanna("apina") );
System.out.println( sanakirja.kaanna("monkey") );
System.out.println( sanakirja.kaanna("ohjelmointi") );
System.out.println( sanakirja.kaanna("banana") );
</pre>

<p>Tulostuu</p>

<pre>
monkey
apina
null
banana
</pre>

<p>Kuten tulostuksesta ilmenee, käännöksen lisäämisen jälkeen sanakirja osaa tehdä käännöksen molempiin suuntiin.</p>

<h4>Sanojen poistaminen</h4>

<p>Lisää sanakirjalle metodi <code>public void poista(String sana)</code></li> joka poistaa annetun sanan ja sen käännöksen sanakirjasta.</p>

<p>Sanakirjan tulee tässä vaiheessa toimia seuraavasti:</p>

<pre class="sh_java">
MuistavaSanakirja sanakirja = new MuistavaSanakirja();
sanakirja.lisaa("apina", "monkey");
sanakirja.lisaa("banaani", "banana");
sanakirja.lisaa("ohjelmointi", "programming");
sanakirja.poista("apina");
sanakirja.poista("banana");

System.out.println( sanakirja.kaanna("apina") );
System.out.println( sanakirja.kaanna("monkey") );
System.out.println( sanakirja.kaanna("banana") );
System.out.println( sanakirja.kaanna("banaani") );
System.out.println( sanakirja.kaanna("ohjelmointi") );
</pre>

<p>Tulostuu</p>

<pre>
null
null
null
null
programming
</pre>

<p>Poisto siis toimii myös molemmin puolin, alkuperäisen sanan tai sen käännöksen poistamalla, poistuu sanakirjasta tieto molempien suuntien käännöksestä. </p>



<h4>Lataaminen tiedostosta</h4>

<p>Tee sanakirjalle konstruktori <code>public Sanakirja(String tiedosto)</code>  ja metodi <code>public boolean lataa()</code>, joka lataa sanakirjan konstruktorin parametrina annetun nimisestä tiedostosta. Jos tiedoston avaaminen tai lukeminen ei onnistu, palauttaa metodi false ja muuten true.</p>

<p>Sanakirjatiedostossa yksi rivi sisältää sanan ja sen käännöksen merkillä ":" erotettuna. Tehtäväpohjan mukana tuleva testaamiseen tarkoitettu sanakirjatiedosto <code>src/sanat.txt</code> on sisällöltään seuraava: </p>

<pre>
apina:monkey
alla oleva:below
olut:beer
</pre>

<p>Lue sanakirjatiedosto rivi riviltä lukijan metodilla <code>nextLine</code>. Voit pilkkoa rivin String metodilla <code>split</code> seuraavasti:

<pre class="sh_java">
Scanner tiedostonLukija = new ...
while ( tiedostonreader.hasNextLine() ){
    String rivi = tiedostonreader.nextLine();
    String[] osat = rivi.split(":");   // pilkotaan rivi :-merkkien kohdalta
    
    System.out.println( osat[0] );     // ennen :-merkkiä ollut osa rivistä
    System.out.println( osat[1] );     // :-merkin jälkeen ollut osa rivistä
}
</pre>

<p>Sanakirjaa käytetään seuraavasti:</p>

<pre class="sh_java">
MuistavaSanakirja sanakirja = new MuistavaSanakirja("src/sanat.txt");
sanakirja.lataa();

System.out.println( sanakirja.kaanna("apina") );
System.out.println( sanakirja.kaanna("ohjelmointi") );
System.out.println( sanakirja.kaanna("alla oleva") );
</pre>

<p>Tulostuu</p>

<pre>
monkey
null
below
</pre>


<h4>Tallennus tiedostoon</h4>

    <p>Tee sanakirjalle metodi <code>public boolean talleta()</code>, jota kutsuttaessa sanakirjan sisältö kirjoitetaan konstruktorin parametrina annetun nimiseen tiedostoon. Jos tallennus ei onnistu, palauttaa metodi false ja muuten true. Sanakirjatiedostot tulee tallentaa ylläesitellyssä muodossa, eli ohjelman on osattava lukea itse kirjottamiaan tiedostoja.</p>

<p><strong>Huom:</strong> vaikka sanakirja osaa käännökset molempiin suuntiin, ei sanakirjatiedostoon tule kirjoittaa kuin toinen suunta. Eli jos sanakirja tietää esim. käännöksen <em>tietokone = computer</em>, tulee rivi:</p>

<pre>
tietokone:computer
</pre>

<p>tai rivi</p>

<pre>
computer:tietokone
</pre>

<p>mutta ei molempia!</p>

    <p>Talletus kannattanee hoitaa siten, että koko käännöslista kirjoitetaan uudelleen vanhan tiedoston päälle, eli materiaalissa esiteltyä <code>append</code>-komentoa ei kannata käyttää.</p>

<p>Sanakirjan lopullista versiota on tarkoitus käyttää  seuraavasti:</p>

<pre class="sh_java">
MuistavaSanakirja sanakirja = new MuistavaSanakirja("src/sanat.txt");
sanakirja.lataa();

// käytä sanakirjaa

sanakirja.tallenna();
</pre>

<p>Eli käytön aluksi ladataan sanakirja tiedostosta ja lopussa tallennetaan se takaisin tiedostoon jotta sanakirjaan tehdyt muutokset pysyvät voimassa seuraavallekin käynnistyskerralle.</p>
</div>



<h2 id="kalit">Käyttöliittymät</h2>

<p><hr/></p>
<p><big><strong><strong>Huom!</strong> Osa käyttöliittymätehtävien testeistä avaa käyttöliittymän ja käyttää hiirtäsi käyttöliittymäkomponenttien klikkailuun. Kun suoritat käyttöliittymätehtävien testejä, älä käytä hiirtäsi!</strong></big></p>
<p><hr/></p>

<p>Ohjelmamme ovat tähän mennessä koostuneet lähinnä sovelluslogiikasta ja sovelluslogiikkaa käyttävästä tekstikäyttöliittymästä. Muutamissa tehtävissä on ollut myös graafinen käyttöliittymä, mutta ne on yleensä luotu puolestamme. Tutustutaan seuraavaksi graafisten käyttöliittymien luomiseen Javalla.</p>

<p>Käyttöliittymät ovat ikkunoita, jotka sisältävät erilaisia osia kuten nappeja, tekstikenttiä ja valikkoja. Käyttöliittymien ohjelmoinnissa käytetään Javan <a href="http://docs.oracle.com/javase/tutorial/ui/features/components.html" target="_blank">Swing</a>-komponenttikirjastoa, joka tarjoaa luokkia käyttöliittymäkomponenttien luomiseen ja käsittelyyn.</p>

<p>Käyttöliittymien peruselementti on luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JFrame.html" target="_blank">JFrame</a></code>, jonka sisältämään komponenttiosioon käyttöliittymäkomponentit luodaan. Oikeaoppisesti luodut käyttöliittymät toteuttavat rajapinnan <code>Runnable</code>, ja ne käynnistetään pääohjelmasta. Käytämme kurssilla seuraavanlaista käyttöliittymärunkoa:</p>

<pre class="sh_java">
import java.awt.Container;
import java.awt.Dimension;
import javax.swing.JFrame;
import javax.swing.WindowConstants;

public class Kayttoliittyma implements Runnable {

    private JFrame frame;

    public Kayttoliittyma() {
    }

    @Override
    public void run() {
        frame = new JFrame("Otsikko");
        frame.setPreferredSize(new Dimension(200, 100));

        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        luoKomponentit(frame.getContentPane());

        frame.pack();
        frame.setVisible(true);
    }

    private void luoKomponentit(Container container) {
    }

    public JFrame getFrame() {
        return frame;
    }
}
</pre>

<p>Tarkastellaan ylläolevan käyttöliittymäluokan koodia hieman tarkemmin.</p>

<pre class="sh_java">
public class Kayttoliittyma implements Runnable {
</pre>

<p>Luokka <code>Kayttoliittyma</code> toteuttaa Javan rajapinnan <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Runnable.html" target="_blank">Runnable</a>, joka tarjoaa mahdollisuuden säikeistettyyn ohjelman suorittamiseen. Säikeistetyllä suorittamisella voidaan suorittaa useita ohjelman osia rinnakkain. Emme tutustu säikeisiin tarkemmin, lisää tietoa säikeistä tulee muunmuassa toisen vuoden kurssilla <em>Käyttöjärjestelmät</em>.</p>

<pre class="sh_java">
    private JFrame frame;
</pre>

<p>Käyttöliittymä sisältää oliomuuttujana <code>JFrame</code>-olion, joka on näkyvän käyttöliittymän pohjaelementti. Kaikki käyttöliittymäkomponentit lisätään <code>JFrame</code>-olion sisältämään komponenttialueeseen. Huomaa että <strong>oliomuuttujia ei saa alustaa metodien ulkopuolella</strong>. Esimerkiksi oliomuuttujan <code>JFrame</code> alustus luokkamäärittelyssä <code>"private JFrame frame = new JFrame()"</code> kiertää käyttöliittymäsäikeiden suoritusjärjestyksen, ja voi johtaa ydintuhoon. Tai ohjelmasi kaatumiseen.</p>

<pre class="sh_java">
    @Override
    public void run() {
        frame = new JFrame("Otsikko");
        frame.setPreferredSize(new Dimension(200, 100));

        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        luoKomponentit(frame.getContentPane());

        frame.pack();
        frame.setVisible(true);
    }
</pre>

<p>Rajapinta <code>Runnable</code> määrittelee metodin <code>public void run()</code>, joka jokaisen <code>Runnable</code>-rajapinnan toteuttajan tulee toteuttaa. Metodissa <code>public void run()</code> luodaan ensin uusi JFrame-ikkuna, jonka otsikoksi asetetaan <code>"Otsikko"</code>. Tämän jälkeen asetetaan ikkunan toivotuksi kooksi 200, 100 eli ikkunan leveydeksi tulee 200 pikseliä, korkeudeksi 100 pikseliä. Komento <code>frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</code> kertoo JFrame-oliolle, että käyttöliittymä tulee sulkea kun käyttäjä painaa käyttöliittymässä olevaa ruksia.</p>

<p>Tämän jälkeen kutsutaan luokassa myöhemmin määriteltyä metodia <code>luoKomponentit</code>. Metodille annetaan parametrina <code>JFrame</code>-olion <em><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Container.html" target="_blank">Container</a></em>-olio, johon voi lisätä käyttöliittymäkomponentteja.</em>

<p>Lopuksi kutsutaan metodia <code>frame.pack()</code>, joka asettaa JFrame-olion aiemmin määritellyn kokoiseksi ja järjestää JFrame-olion sisältämän Container-olion sisällä olevat käyttöliittymäkomponentit. Lopuksi kutsutaan metodia <code>frame.setVisible(true)</code>, joka näyttää käyttöliittymän käyttäjälle.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
    }
</pre>

<p>Metodissa <code>luoKomponentit</code> lisätään <code>JFrame</code>-olion sisältämään komponenttialueeseen käyttöliittymäkomponentteja. Esimerkissämme ei ole yhtäkään käyttöliittymäkomponenttia JFrame-ikkunan lisäksi. Luokalla <code>Kayttoliittyma</code> on myös sen käyttöä helpottava metodi <code>getFrame</code>, jolla päästään käsiksi luokan kapseloimaan JFrame-olioon.</em>

<p>Swing-käyttöliittymät käynnistetään <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/SwingUtilities.html" target="_blank">SwingUtilities</a></code>-luokan tarjoaman <code>invokeLater</code>-metodin avulla. Metodi <code>invokeLater</code> saa parametrinaan <code>Runnable</code>-rajapinnan toteuttavan olion. Metodi asettaa <code>Runnable</code>-olion suoritusjonoon, ja kutsuu sitä kun ehtii. Luokan <code>SwingUtilities</code> avulla voimme käynnistää uusia säikeitä tarvittaessa.</p>

<pre class="sh_java">
import javax.swing.SwingUtilities;

public class Main {

    public static void main(String[] args) {
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma();
        SwingUtilities.invokeLater(kayttoliittyma);
    }
}
</pre>


<p>Kun ylläoleva pääohjelmametodi suoritetaan, näemme luokassa <code>Kayttoliittyma</code> määrittellyn käyttöliittymän.</p>

    <p><img src="img-ohja/kali/eka-kali.png"/></p>


<h3>Käyttöliittymäkomponentit</h3>


<p>Käyttöliittymä koostuu taustaikkunan (JFrame) sisältämästä komponenttipohjasta (Container), ja siihen asetetuista käyttöliittymäkomponenteista. Käyttöliittymäkomponentteja ovat erilaiset painikkeet, tekstit ym. Jokaiselle komponentille on oma luokka. Kannattaa tutustua Oraclen visuaalinen kuvasarjaan erilaisista komponenteista osoitteessa <a href="http://docs.oracle.com/javase/tutorial/ui/features/components.html" target="_blank">http://docs.oracle.com/javase/tutorial/ui/features/components.html</a>.</p>

<h4>Teksti</h4>

<p>Tekstin näyttäminen tapahtuu <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JLabel.html" target="_blank">JLabel</a></code>-luokan avulla. Luokka <code>JLabel</code> tarjoaa käyttöliittymäkomponentin, jolle voi asettaa tekstiä ja jonka sisältämää tekstiä voi muokata. Teksti asetetaan joko konstruktorissa tai erillisellä <code>setText</code>-metodilla.</p>

<p>Muokataan käyttöliittymäpohjaamme siten, että siinä näkyy tekstiä. Luodaan uusi JLabel-tekstikomponentti metodissa <code>luoKomponentit</code>. Tämän jälkeen lisätään se <code>JFrame</code>-oliolta saatuun <code>Container</code>-olioon <code>Container</code>-olion <code>add</code>-metodia käyttäen.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        JLabel teksti = new JLabel("Tekstikenttä!");
        container.add(teksti);
    }
</pre>

<p>Kuten yllä olevasta lähdekoodista näemme, JLabel-käyttöliittymäkomponentti tulee näyttämään tekstin <code>"Tekstikenttä!"</code>. Kun suoritamme käyttöliittymän, näemme seuraavanlaisen ikkunan.</p>

    <p><img src="img-ohja/kali/kali-tekstikentta.png"/></p>


<div class="tehtavat">

<h3>Tervehtijä</h3>

<p>Toteuta käyttöliittymä, joka näyttää tekstin "Moi!". Käyttöliittymän (eli JFrame-olion) leveyden tulee olla vähintään 400 ja korkeuden 100 ja otsikkona teksti "Swing on". Tehtävä tulee toteuttaa tehtäväpohjassa tulevaan käyttöliittymärunkoon.  JFrame-olion luominen ja näkyväksi asettamisen tulee tapahtua metodissa <code>run()</code>, tekstikomponentti lisätään käyttöliittymälle metodissa <code>luoKomponentit(Container container)</code>.</p>

<p><strong>HUOM: Käyttöliittymien oliomuuttujia saa alustaa vain metodeissa tai konstruktorissa! Älä alusta oliomuuttujia suoraan määrittelyn yhteydessä.</strong></p>
</div>

<h4>Painikkeet</h4>

<p>Käyttöliittymään saa painikkeita <code>JButton</code>-luokan avulla. JButton-olion lisääminen käyttöliittymään tapahtuu aivan kuin JLabel-olion lisääminen.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        JButton nappi = new JButton("Click!");
        container.add(nappi);
    }
</pre>

    <p><img src="img-ohja/kali/kali-nappi.png"/></p>

<p>Yritetään seuraavaksi lisätä käyttöliittymään sekä tekstiä, että nappi.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        JButton nappi = new JButton("Click!");
        container.add(nappi);
        JLabel teksti = new JLabel("Tekstiä.");
        container.add(teksti);
    }
</pre>

<p>Ohjelmaa suorittaessa näemme seuraavanlaisen käyttöliittymän.</p>

    <p><img src="img-ohja/kali/kali-tarve-asettelulle.png"/></p>

<p>Vain viimeiseksi lisätty käyttöliittymäkomponentti on näkyvillä, eikä ohjelma toimi toivotusti. Mistä tässä oikein on kyse?</p>

<h3>Käyttöliittymäkomponenttien asettelu</h3>

<p>Jokaisella käyttöliittymäkomponentilla on oma sijainti käyttöliittymässä. Komponentin sijainnin määrää käytössä oleva käyttöliittymän asettelija (<em>Layout Manager</em>). Yrittäessämme aiemmin lisätä useampia käyttöliittymäkomponentteja <code>Container</code>-olioon käyttöliittymässä oli vain yksi komponentti näkyvillä. Jokaisessa <code>Container</code>-oliossa on oletuksena käyttöliittymäasettelija <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/BorderLayout.html" target="_blank">BorderLayout</a></code>.</p>

<p>BorderLayout asettelee käyttöliittymäkomponentit viiteen alueeseen: käyttöliittymän keskikohdan lisäksi käytössä on ilmansuunnat. Voimme antaa Container-olion <code>add</code>-metodille ylimääräisenä parametrina lisätoiveen kohdasta, johon haluamme asettaa käyttöliittymäkomponentin. BorderLayout-luokassa on käytössä luokkamuuttujat <code>BorderLayout.NORTH</code>, <code>BorderLayout.EAST</code>, <code>BorderLayout.SOUTH</code>, <code>BorderLayout.WEST</code>, ja <code>BorderLayout.CENTER</code>.</p>

<p>Käytettävä käyttöliittymäasettelija asetetaan <code>Container</code>-oliolle metodin <code>setLayout</code>-parametrina. Metodille <code>add</code> voidaan antaa käyttöliittymäkomponentin lisäksi paikka, johon komponentti lisätään. Alla on esimerkki, jossa jokaiseen BorderLayoutin tarjoamaan paikkaan asetetaan käyttöliittymäkomponentti.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        // seuraava rivi siis ei tässä tilanteessa pakollinen, sillä BorderLayout on JFramessa jokatapauksessa oletuksena
        container.setLayout(new BorderLayout());

        container.add(new JButton("Pohjoinen (North)"), BorderLayout.NORTH);
        container.add(new JButton("Itä (East)"), BorderLayout.EAST);
        container.add(new JButton("Etelä (South)"), BorderLayout.SOUTH);
        container.add(new JButton("Länsi (West)"), BorderLayout.WEST);
        container.add(new JButton("Keski (Center)"), BorderLayout.CENTER);

        container.add(new JButton("Oletuspaikka (Center)"));
    }
</pre>

<p>Huomaa, että nappi <code>"Keski (Center)"</code> ei tule näkymään käyttöliittymässä sillä nappi <code>"Oletuspaikka (Center)"</code> asetetaan oletuksena sen paikalle. Käyttöliittymässäpohjassa yllä oleva koodi näyttää seuraavalta.</p>

    <p><img src="img-ohja/kali/layout-borderlayout.png"/></p>

<p>Kuten käyttöliittymäkomponentteja, myös käyttöliittymän asettelijoita on useita. Oraclella on käyttöliittymäasettelijoihin visuaalinen opas osoitteessa <a href="http://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html" target="_blank">http://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html</a>. Tutustutaan seuraavaksi käyttöliittymäasettelijaan <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/BoxLayout.html" target="_blank">BoxLayout</a></code>.</a>

<h4>BoxLayout</h4>

<p>BoxLayoutia käytettäessä käyttöliittymäkomponentit asetetaan käyttöliittymään joko vaakasuunnassa tai pystysuunnassa. BoxLayoutin konstruktorille annetaan parametrina Container-olio, johon käyttöliittymäkomponentteja ollaan asettamassa, ja käyttöliittymäkomponenttien asettelusuunta. Asettelusuunta on joko <code>BoxLayout.X_AXIS</code>, eli komponentit vaakasuunnassa, tai <code>BoxLayout.Y_AXIS</code>, eli komponentit pystysuunnassa. Toisin kuin BorderLayout-asettelijaa käytettäessä, BoxLayoutilla ei ole rajattua määrää paikkoja. Container-olioon voi siis lisätä niin monta käyttöliittymäkomponenttia kuin haluaa.</p>

<p>Käyttöliittymän asettelu <code>BoxLayout</code>-asettelijaa käyttäen toimii kuten <code>BorderLayout</code>-asettelijan käyttö. Luomme ensin asettelijan, jonka asetamme <code>Container</code>-oliolle sen metodilla <code>setLayout</code>. Tämän jälkeen voimme lisätä käyttöliittymäkomponentteja <code>Container</code>-olion <code>add</code>-metodilla. Emme tarvitse erillistä sijaintia ilmaisevaa parametria. Alla esimerkki vaakasuunnassa asetetuista käyttöliittymäkomponenteista.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.X_AXIS);
        container.setLayout(layout);

        container.add(new JLabel("Eka!"));
        container.add(new JLabel("Toka!"));
        container.add(new JLabel("Kolmas!"));
    }
</pre>

<p><img src="img-ohja/kali/boxlayout-x_axis.png"/></p>

<p>Käyttöliittymäkomponenttien asettelu pystysuunnassa ei vaadi suurta muutosta. Vaihdamme <code>BoxLayout</code>-olion konstruktorille annettavaksi suuntaparametriksi <code>BoxLayout.Y_AXIS</code>.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.Y_AXIS);
        container.setLayout(layout);

        container.add(new JLabel("Eka!"));
        container.add(new JLabel("Toka!"));
        container.add(new JLabel("Kolmas!"));
    }
</pre>

    <p><img src="img-ohja/kali/boxlayout-y_axis.png"/></p>

<p>Käyttöliittymäasettelijoita käyttämällä voimme luoda käyttöliittymiä, joissa käyttöliittymäkomponentit ovat aseteltu sopivasti. Alla on esimerkkikäyttöliittymä, jossa komponentit asetetaan pystysuuntaan. Ensin teksti, ja sitten vaihtoehtoinen valinta. Vaihtoehtoisen valinnan, eli valinnan jossa vain yksi vaihtoehto on aina voimassa, voi tehdä käyttämällä <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/ButtonGroup.html" target="_blank">ButtonGroup</a></code>-ryhmittelijää ja <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JRadioButton.html" target="_blank">JRadioButton</a></code>-painikkeita.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.Y_AXIS);
        container.setLayout(layout);

        container.add(new JLabel("Valitse ruokavalio:"));

        JRadioButton liha = new JRadioButton("Liha");
        JRadioButton kala = new JRadioButton("Kala");

        ButtonGroup buttonGroup = new ButtonGroup();
        buttonGroup.add(liha);
        buttonGroup.add(kala);

        container.add(liha);
        container.add(kala);
    }
</pre>


    <p><img src="img-ohja/kali/buttongroup-ruokavalio.png"/></p>

<div class="tehtavat">

<h3>Kysely</h3>

<p>Toteuta tehtäväpohjaan käyttöliittymä, joka näyttää seuraavalta:</p>

<p><img src="img-ohja/kali/157-kysely.png"/></p>

<p>Käytä käyttöliittymän asettelijana luokkaa <code>BoxLayout</code>, komponentteina luokkia <code>JLabel</code>, <code>JRadioButton</code>, <code>JCheckBox</code> ja <code>JButton</code>.</p>

<p>Käytä <code>ButtonGroup</code>-luokkaa varmistamaan että vaihtoehdot "Siksi" ja "Koska se on kivaa" eivät voi olla valittuina samaan aikaan.</p>

<p>Varmista että käyttöliittymä on niin iso, että käyttäjä voi klikata nappeja muuttamatta sen kokoa. Voit käyttää esimerkiksi leveytenä 200 pikseliä, korkeutena 300 pikseliä.</p>
</div>


<h3>Tapahtumien käsittely</h3>

<p>Tähänastiset graafiset käyttöliittymämme ovatvaikkakin hienoja hieman tylsiä: ne eivät reagoi millään tavalla käyttöliittymässä tehtyihin tapahtumiin. Reagoimattomuus ei johdu käyttöliittymäkomponenteista, vaan siitä että emme ole lisänneet käyttöliittymäkomponentteihin tapahtumia käsitteleviä kuuntelijoita.</p>

<p>Tapahtumankuuntelijat <em>kuuntelevat</em> käyttöliittymäkomponentteja joihin ne on liitetty. Aina kun käyttöliittymäkomponentille tehdään joku toiminto, esimerkiksi napille napin painaminen, käyttöliittymäkomponentti kutsuu jokaisen siihen liitetyn tapahtumakuuntelijan tiettyä metodia. Käytännössä tapahtumankuuntelijat ovat tietyn rajapinnan toteuttavia luokkia, joiden ilmentymiä käyttöliittymäkomponentille voi lisätä. Tapahtuman tapahtuessa käyttöliittymäkomponentti käy jokaisen siihen liitetyn tapahtumankuuntelijan läpi, ja kutsuu rajapinnassa määriteltyä metodia.</p>

<p>Swing-käyttöliittymissä eniten käytetty tapahtumankuuntelurajapinta on <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/ActionListener.html">ActionListener</a></code>. Rajapinta <code>ActionListener</code> määrittelee metodin <code>void actionPerformed(ActionEvent e)</code>, joka saa parametrinaan tapahtumasta kertovan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/ActionEvent.html" target="_blank">ActionEvent</a></code>-olion.</p>

<p>Toteutetaan ensimmäinen oma tapahtumankuuntelija, jonka tarkoituksena on vain tulostaa viesti standarditulostusvirtaan nappia painettaessa. Luokka <code>ViestiKuuntelija</code> toteuttaa rajapinnan <code>ActionListener</code> ja tulostaa viestin <code>"Viesti vastaanotettu!"</code> kun metodia <code>actionPerformed</code> kutsutaan.</p>

<pre class="sh_java">
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class ViestiKuuntelija implements ActionListener {

    @Override
    public void actionPerformed(ActionEvent ae) {
        System.out.println("Viesti vastaanotettu!");
    }
}
</pre>

<p>Luodaan seuraavaksi käyttöliittymään <code>JButton</code>-tyyppinen nappi, ja lisätään siihen <code>ViestiKuuntelija</code>-luokan ilmentymä. Luokalle <code>JButton</code> voi lisätä tapahtumankuuntelijan käyttämällä sen yläluokassa <code>AbstractButton</code> määriteltyä metodia <code>public void addActionListener(ActionListener actionListener)</code>.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        JButton nappi = new JButton("Viestitä!");
        nappi.addActionListener(new ViestiKuuntelija());

        container.add(nappi);
    }
</pre>

<p><img src="img-ohja/kali/kali-actionlistener-viestita.png"/></p>

<p>Käyttöliittymässä olevaa nappia painettaessa näemme standarditulostusvirrassa seuraavan viestin.</p>

<pre>
Viesti vastaanotettu!
</pre>

<h4>Olioiden käsittely tapahtumankuuntelijoissa</h4>

<p>Haluamme usein että tapahtumankuuntelija muokkaa jonkun olion tilaa. Päästäksemme olioon käsiksi tapahtumankuuntelijassa, tulee meidän antaa viite käsiteltävään olioon tapahtumankuuntelijalle sen konstruktorissa. Tapahtumankuuntelijat ovat täysin samanlaisia luokkia kuin muutkin Javan luokat, eli pääsemme ohjelmoimaan kaiken haluamamme toiminnallisuuden.</p>

<p>Pohditaan seuraavaa käyttöliittymää jossa on kaksi <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JTextArea.html" target="_blank">JTextArea</a></code>-tyyppistä tekstikenttää, eli tekstikenttää johon käyttäjä voi syöttää tekstiä, ja <code>JButton</code>-tyyppinen nappi. Käyttöliittymä käyttää <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/GridLayout.html" target="_blank">GridLayout</a></code>-asettelijaa, jonka avulla käyttöliittymän voi rakentaa taulukkomaiseksi. GridLayout-luokan konstruktorille määriteltiin yksi rivi ja kolme saraketta.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(1, 3);
        container.setLayout(layout);

        JTextArea textAreaVasen = new JTextArea("Le Kopioija");
        JTextArea textAreaOikea = new JTextArea();
        JButton kopioiNappi = new JButton("Kopioi!");

        container.add(textAreaVasen);
        container.add(kopioiNappi);
        container.add(textAreaOikea);
    }
</pre>

    <p><img src="img-ohja/kali/kopioija-alku.png"/></p>

<p>Haluamme lisätä käyttöliittymään toiminnallisuuden, jossa <code>JButton</code>-nappia painettaessa vasemman tekstikentän sisältö kopioituu oikeaan tekstikenttään. Tämä onnistuu toteuttamalla tapahtumankuuntelija. Luodaan rajapinnan <code>ActionListener</code> toteuttava luokka <code>KenttienKopioija</code>, joka kopioi JTextArea kentästä toiseen. </p>


<pre class="sh_java">
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JTextArea;

public class KenttienKopioija implements ActionListener {

    private JTextArea lahde;
    private JTextArea kohde;

    public KenttienKopioija(JTextArea lahde, JTextArea kohde) {
        this.lahde = lahde;
        this.kohde = kohde;
    }

    @Override
    public void actionPerformed(ActionEvent ae) {
        this.kohde.setText(this.lahde.getText());
    }
}
</pre>

<p>Tapahtumankuuntelijan rekisteröinti <code>JButton</code>-oliolle onnistuu metodilla <code>addActionListener</code>.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(1, 3);
        container.setLayout(layout);

        JTextArea textAreaVasen = new JTextArea("Le Kopioija");
        JTextArea textAreaOikea = new JTextArea();
        JButton kopioiNappi = new JButton("Kopioi!");

        KenttienKopioija kopioija = new KenttienKopioija(textAreaVasen, textAreaOikea);
        kopioiNappi.addActionListener(kopioija);

        container.add(textAreaVasen);
        container.add(kopioiNappi);
        container.add(textAreaOikea);
    }
</pre>


<p>Nappia painettaessa vasemman tekstikentän sisältö kopioituu oikealla olevaan tekstikenttään.</p>

    <p><img src="img-ohja/kali/kopioija-valmis.png"/></p>



<div class="tehtavat">

<h3>Ilmoitin</h3>

<p>Toteuta tehtäväpohjaan käyttöliittymä, joka näyttää seuraavalta.</p>

    <p><img src="img-ohja/kali/158-ilmoitin.png"/></p>

<p>Ohjelman tulee koostua seuraavista pakkauksessa <code>ilmoitin</code> olevista luokista. Luokka <code>Ilmoitin</code> on käyttöliittymäluokka, joka käynnistetään <code>Main</code>-luokasta. Ilmoittimessa on käyttöliittymäkomponentteina <code>JTextField</code>, <code>JButton</code>, ja <code>JLabel</code>. Voit asetella käyttöliittymäkomponentit <code>GridLayout</code>-asettelijan avulla: kutsu <code>new GridLayout(3, 1)</code> luo uuden asettelijan, joka asettelee kolme käyttöliittymäelementtiä pystysuunnassa.</p>

<p>Sovelluksessa tulee olla lisäksi luokka <code>TapahtumanKuuntelija</code>, joka toteuttaa rajapinnan <code>ActionListener</code>. Tapahtumankuuntelija liitetään nappiin ja sen tulee kopioida käyttöliittymässä olevan JTextField-kentän sisältö JLabel-kenttään napin painalluksen yhteydessä ja samalla tyhentää JTextField asettamalla sen sisällöksi "".</p>

<p>Varmista että käyttöliittymä käynnistyy niin isona että jokaista nappulaa voi klikata.</p>
</div>

<h3>Sovelluslogiikan ja käyttöliittymälogiikan eriyttäminen</h3>

<p>Sovelluslogiikan (esimerkiksi tallennus- tai lukutoiminnallisuuden) ja käyttöliittymän sekoittaminen samoihin luokkiin on yleisesti ottaen huono asia. Se vaikeuttaa ohjelman testaamista ja muokkaamista huomattavasti, ja tekee koodista myös paljon vaikeammin luettavaa. Single responsibility principlen sanoin "Jokaisella luokalla pitäisi olla vain yksi selkeä vastuu". Sovelluslogiikan erottaminen käyttöliittymälogiikasta onnistuu sopivan rajapintasuunnittelun kautta.  Oletetaan, että käytössämme on rajapinta <code>PersonVarasto</code>, ja haluamme toteuttaa käyttöliittymän henkilöiden tallentamiseen.</p>

<pre class="sh_java">
public interface PersonVarasto {
    void talleta(Person henkilo);
    Person hae(String henkilotunnus);

    void poista(Person henkilo);
    void poista(String henkilotunnus);
    void poistaKaikki();

    Collection&lt;Person&gt; haeKaikki();
}
</pre>

<h4>Käyttöliittymän toteutus</h4>

<p>Käyttöliittymää toteutettaessa hyvä aloitustapa on sopivien käyttöliittymäkomponenttien lisääminen käyttöliittymään. Henkilöiden tallennuksessa tarvitsemme kentät nimelle ja henkilötunnukselle, sekä napin jolla henkilö voidaan lisätä. Käytetään Javan <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JTextField.html" target="_blank">JTextField</a></code>-luokkaa tekstin syöttämiseen, ja <code>JButton</code>-luokkaa napin toteuttamiseen. Luodaan käyttöliittymään lisäksi selventävät <code>JLabel</code>-tyyppiset selitystekstit.</p>

<p>Käytetään käyttöliittymän asetteluun <code>GridLayout</code>-asettelijaa. Rivejä käyttöliittymässä on 3, sarakkeita 2. Lisätään tapahtumankuuntelija myöhemmin. Käyttoliittymäluokan metodi <code>luoKomponentit</code> näyttää nyt seuraavalta.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(3, 2);
        container.setLayout(layout);

        JLabel nimiTeksti = new JLabel("Nimi: ");
        JTextField nimiKentta = new JTextField();
        JLabel hetuTeksti = new JLabel("Hetu: ");
        JTextField hetuKentta = new JTextField();

        JButton lisaaNappi = new JButton("Lisää henkilö!");
        // tapahtumankuuntelija

        container.add(nimiTeksti);
        container.add(nimiKentta);
        container.add(hetuTeksti);
        container.add(hetuKentta);
        container.add(new JLabel(""));
        container.add(lisaaNappi);
    }
</pre>

<p>Käyttöliittymä näyttää seuraavalta kun siihen on lisätty tietoa.</p>

    <p><img src="img-ohja/kali/kali-henkilon-lisays.png"/></p>

<p>Tapahtumankuuntelijan tulee tietää tallennustoiminnallisuudesta eli <code>PersonVarasto</code>-rajapinnasta sekä kentistä, joita se käyttää. Luodaan <code>ActionListener</code>-rajapinnan toteuttava luokka <code>PersonnLisaysKuuntelija</code>. Luokka saa konstruktorissaan parametrina <code>PersonVarasto</code>-rajapinnan toteuttavan olion sekä kaksi <code>JTextField</code>-oliota, jotka ovat kentät nimelle ja henkilötunnukselle. Metodissa <code>actionPerformed</code> luodaan uusi <code>Person</code>-olio ja tallennetaan se <code>PersonVarasto</code>-olion tarjoamalla <code>talleta</code>-metodilla.</p>

<pre class="sh_java">
public class PersonnLisaysKuuntelija implements ActionListener {

    private PersonVarasto henkiloVarasto;
    private JTextField nimiKentta;
    private JTextField hetuKentta;

    public PersonnLisaysKuuntelija(PersonVarasto henkiloVarasto, JTextField nimiKentta, JTextField hetuKentta) {
        this.henkiloVarasto = henkiloVarasto;
        this.nameKentta = nimiKentta;
        this.hetuKentta = hetuKentta;
    }

    @Override
    public void actionPerformed(ActionEvent ae) {
        Person henkilo = new Person(nimiKentta.getText(), hetuKentta.getText());
        this.henkiloVarasto.talleta(henkilo);
    }
}
</pre>

<p>Jotta saamme <code>PersonVarasto</code>-viitteen <code>PersonnLisaysKuuntelija</code>-oliolle, tulee sen olla käyttöliittymän tiedossa. Lisätään käyttöliittymälle oliomuuttuja <code>private PersonVarasto henkiloVarasto</code>, joka asetetaan konstruktorissa. Luokan <code>Kayttoliittyma</code> konstruktoria muokataan siten, että sille annetaan <code>PersonVarasto</code>-rajapinnan toteuttama luokka.</p>

<pre class="sh_java">
public class Kayttoliittyma implements Runnable {

    private JFrame frame;
    private PersonVarasto henkiloVarasto;

    public Kayttoliittyma(PersonVarasto henkiloVarasto) {
        this.henkiloVarasto = henkiloVarasto;
    }
    // ...


</pre>

<p>Voimme nyt luoda tapahtumankuuntelijan <code>PersonnLisaysKuuntelija</code>, jolle annetaan sekä <code>PersonVarasto</code>-viite, että kentät.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(3, 2);
        container.setLayout(layout);

        JLabel nimiTeksti = new JLabel("Nimi: ");
        JTextField nimiKentta = new JTextField();
        JLabel hetuTeksti = new JLabel("Hetu: ");
        JTextField hetuKentta = new JTextField();

        JButton lisaaNappi = new JButton("Lisää henkilö!");
        PersonnLisaysKuuntelija kuuntelija = new PersonnLisaysKuuntelija(henkiloVarasto, nimiKentta, hetuKentta);
        lisaaNappi.addActionListener(kuuntelija);

        container.add(nimiTeksti);
        container.add(nimiKentta);
        container.add(hetuTeksti);
        container.add(hetuKentta);
        container.add(new JLabel(""));
        container.add(lisaaNappi);
    }
</pre>

<div class="tehtavat">
<h3>Axe Click Effect</h3>

<p>Tässä tehtävässä toteutetaan laskuri klikkausten laskemiseen. Tehtävässä sovelluslogiikka, eli laskeminen ja käyttöliittymälogiikka on erotettu toisistaan. Lopullisen sovelluksen tulee näyttää kutakuinkin seuraavalta. </p>

    <p><img src="img-ohja/kali/159-clickeffect.png"/></p>

<h4>OmaLaskuri</h4>

<p>Toteuta pakkaukseen <code>clicker.sovelluslogiikka</code> rajapinnan <code>Laskuri</code> toteuttava luokka <code>OmaLaskuri</code>. Luokan <code>OmaLaskuri</code> metodin <code>annaArvo</code> palauttama luku on aluksi 0. Kun metodia <code>kasvata</code> kutsutaan, kasvaa arvo aina yhdellä.</p>

<p>Voit halutessasi testata luokan toimintaa seuraavan ohjelman avulla.</p>

<pre class="sh_java">
        Laskuri laskuri = new OmaLaskuri();
        System.out.println("Arvo: " + laskuri.annaArvo());
        laskuri.kasvata();
        System.out.println("Arvo: " + laskuri.annaArvo());
        laskuri.kasvata();
        System.out.println("Arvo: " + laskuri.annaArvo());
</pre>

<pre>
Arvo: 0
Arvo: 1
Arvo: 2
</pre>

<h4>KlikkaustenKuuntelija</h4>

<p>Toteuta pakkaukseen <code>clicker.kayttoliittyma</code> rajapinnan <code>ActionListener</code> toteuttava luokka <code>KlikkaustenKuuntelija</code>. Luokka <code>KlikkaustenKuuntelija</code> saa konstruktorin parametrina <code>Laskuri</code>-rajapinnan toteuttavan olion ja <code>JLabel</code>-olion.</p>

<p>Toteuta <code>actionPerformed</code>-metodi siten, että <code>Laskuri</code>-oliota kasvatetaan aluksi yhdellä, jonka jälkeen laskurin arvo asetetaan <code>JLabel</code>-olion tekstiksi. <code>JLabel</code>-olion tekstiä voidaan muuttaa metodilla <code>setText</code>.</p>

<h4>Käyttöliittymä</h4>

<p>Muokkaa luokkaa <code>Kayttoliittyma</code> siten, että käyttöliittymä saa konstruktorin parametrina <code>Laskuri</code>-olion, tarvitset uuden konstruktorin. Lisää käyttöliittymään tarvittavat käyttöliittymäkomponentit. Rekisteröi napille myös edellisessä osassa toteutettu tapahtumankuuntelija.</p>

<p>Käytä käyttöliittymäkomponenttien asetteluun <code>BorderLayout</code>-luokan tarjoamia toiminnallisuuksia. Muuta myös <code>Main</code>-luokkaa siten, että käyttöliittymälle annetaan <code>OmaLaskuri</code>-olio. Kun käyttöliittymässä olevaa <code>"Click!"</code>nappia on painettu kahdesti, sovellus näyttää kutakuinkin seuraavalta.</p>

    <p><img src="img-ohja/kali/159-clickeffect-klikattu.png"/></p>

</div>


<h3>Sisäkkäiset Container-oliot</h3>

<p>Törmäämme silloin tällöin tilanteeseen, jossa <code>JFrame</code>-luokan tarjoama <code>Container</code>-olio ei riitä käyttöliittymän asetteluun. Saatamme tarvita erilaisia käyttöliittymänäkymiä tai mahdollisuutta käyttöliittymäkomponenttien ryhmittelyyn niiden käyttötarkoituksen mukaan. Esimerkiksi alla olevan käyttöliittymän rakentaminen ei olisi kovin helppoa vain <code>JFrame</code>-luokan tarjoamalla <code>Container</code>-oliolla.</p>

   <p><img src="img-ohja/kali/jpanel-container.png"/></p>

<p>Voimme asettaa Container-tyyppisiä olioita toistensa sisään. Luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JPanel.html" target="_blank">JPanel</a></code> (katso myös <a href="http://docs.oracle.com/javase/tutorial/uiswing/components/panel.html" target="_blank">How to Use Panels</a>) mahdollistaa sisäkkäiset <code>Container</code>-oliot. JPanel-luokan ilmentymään voi lisätä käyttöliittymäkomponentteja samalla tavalla kuin <code>JFrame</code>-luokasta saatuun <code>Container</code>-ilmentymään. Tämän lisäksi <code>JPanel</code>-luokan ilmentymän voi lisätä <code>Container</code>-olioon. Tämä mahdollistaa useamman <code>Container</code>-olion käyttämisen käyttöliittymän suunnittelussa.</p>

<p>Yllä olevan käyttöliittymän luominen on helpompaa <code>JPanel</code>-luokan avulla.. Luodaan käyttöliittymä, jossa on kolme nappia "Suorita", "Testaa", ja "Lähetä", sekä tekstialue joka sisältää tekstiä. Napit ovat oma joukkonsa, joten tehdään niille erillinen <code>JPanel</code>-olio joka asetetaan <code>JFrame</code>-luokasta saadun <code>Container</code>-olion eteläosaan. Tekstialue tulee keskelle.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        container.add(new JTextArea());
        container.add(luoValikko(), BorderLayout.SOUTH);
    }

    private JPanel luoValikko() {
        JPanel panel = new JPanel(new GridLayout(1, 3));
        panel.add(new JButton("Suorita"));
        panel.add(new JButton("Testaa"));
        panel.add(new JButton("Lähetä"));
        return panel;
    }
</pre>

<p>JPanel-luokalle annetaan konstruktorin parametrina käytettävä asettelutyyli. Jos asettelutyyli tarvitsee konstruktorissaan viitteen käytettyyn <code>Container</code>-olioon, on <code>JPanel</code>-luokalla myös metodi <code>setLayout</code>.</p>

<p>Jos käyttöliittymässämme on selkeät erilliset kokonaisuudet, voimme myös periä <code>JPanel</code> luokan. Esimerkiksi ylläolevan valikon voisi toteuttaa myös seuraavasti.</p>

<pre class="sh_java">
import java.awt.GridLayout;
import javax.swing.JButton;
import javax.swing.JPanel;

public class ValikkoPanel extends JPanel {

    public ValikkoPanel() {
        super(new GridLayout(1, 3));
        luoKomponentit();
    }

    private void luoKomponentit() {
        add(new JButton("Suorita"));
        add(new JButton("Testaa"));
        add(new JButton("Lähetä"));
    }
}
</pre>

<p>Nyt käyttöliittymäluokassa voidaan luoda <code>ValikkoPanel</code>-luokan ilmentymä.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        container.add(new JTextArea());
        container.add(new ValikkoPanel(), BorderLayout.SOUTH);
    }
</pre>

<p>Huomaa että tapahtumankäsittelyä tarvittaessa luokalle <code>ValikkoPanel</code> tulee antaa parametrina kaikki tarvittavat oliot.</p>

<div class="tehtavat">
<h3>Calculator</h3>

<p>Tehtävässä on tarkoitus toteuttaa yksinkertainen laskin. Laskimen käyttöliittymän tulee olla seuraavanlainen:</p>

   <p><img src="img-ohja/laskin.png"/></p>

<p>Tehtäväpohjan mukana tulee käynistyksen suorittava pääohjelma sekä graafisen käyttöliittymän sisältävä luokka <code>GraafinenLaskin</code>. Käyttöliittymän on oltava täsmälleen seuraavassa osassa kuvaillulla tavalla tehty, muuten saat vapaasti suunnitella ohjelman rakenteen.</p> 

<h4>Layout kuntoon</h4>

<p>Käyttöliittymän pohjana olevassa  <code>JFrame</code>:ssa tulee käyttää asettelijana <code>GridLayout</code>ia jossa on kolme riviä ja yksi sarake. Ylimpänä on tuloskenttävä toimiva  <code>JTextField</code>, jonka täytyy asettaa metodikutsulla <code>setEnabled(false)</code> "poissa päältä". Toisena on syötekenttänä toimiva  <code>JTextField</code>. Tuloskentässä on aluksi teksti 0 ja syötekenttä on tyhjä.</p>

<p>Alimpana komponenttina sijaitsee <code>JPanel</code> jolla asettelijana <code>GridLayout</code>ia jossa on yksi rivi ja kolme saraketta. Panelissa on kolme <code>JButton</code>ia, joissa tekstit "+", "+" ja "Z".</p>

<h4>Perustoiminnallisuus</h4>

<p>Laskimen toimintalogiikka on seuraava. Käyttäjän kirjottaessa syötekenttään luvun n ja painaessa <strong>+</strong>, lisätään tuloskentässä olevaan arvoon n ja päivitetään tuloskenttä uuteen arvoon. Vastaavasti käyttäjän kirjottaessa syötekenttään luvun n ja painaessa <strong>-</strong>, vähennetään tuloskentässä olevasta arvosta n ja päivitetään tuloskenttä uuteen arvoon. Jos käyttäjä painaa <strong>Z</strong>, nollautuu tuloskenttä.</p>

<h4>Hienosäätö</h4>

<p>Laajennetaan vielä ohjelmaa seuraavilla ominaisuuksissa:</p>
<ul>
<li>Jos tuloskentässä on 0, ei <strong>Z</strong>-nappia voi painaa, eli se tulee olla asetettu metodikutsulla <code>setEnabled(false)</code> "poissa päältä". Muissa tilanteissa napin tulee olla päällä.</li>
<li>Kun käyttäjä painaa jotain napeista<strong>+, -, Z</strong> syötekenttä tyhjenee.</li>
<li>Jos syötekenttässä oleva syöte ei ole kokonaisluku ja käyttäjjä painaa jotain napeista<strong>+, -, Z</strong> syötekenttä tyhjenee ja tuloskentän tila ei muutu (paitsi napin ollessa <strong></strong>).</li>
</ul>
</div>

<h2>Piirtäminen</h2>

<p>Luokkaa <code>JPanel</code> käytetään <code>Container</code>-toiminnallisuuden lisäksi usein piirtoalustana siten, että käyttäjä perii luokan <code>JPanel</code> ja korvaa metodin <code>protected void paintComponent(Graphics graphics)</code>. Käyttöliittymä kutsuu metodia <code>paintComponent</code> aina kun käyttöliittymäkomponentin sisältö halutaan piirtää ruudulle. Metodi <code>paintComponent</code> saa käyttöliittymältä parametrina abstraktin luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html" target="_blank">Graphics</a></code> toteuttavan olion. Luodaan luokan <code>JPanel</code> perivä luokka <code>Piirtoalusta</code>, joka korvaa <code>paintComponent</code>-metodin.</p>

<pre class="sh_java">
public class Piirtoalusta extends JPanel {

    public Piirtoalusta() {
        super.setBackground(Color.WHITE);
    }

    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);
    }
}
</pre>

<p>Yllä oleva piirtoalusta ei sisällä konkreettista piirtämistoiminnallisuutta. Asetamme konstruktorissa piirtoalustan taustan valkoiseksi kutsumalla yläluokan metodia <code>setBackground</code>. Metodin <code>setBackGround</code> saa parametrina <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Color.html" target="_blank">Color</a></code>-luokan ilmentymän. Luokka <code>Color</code> sisältää yleisimmät värit luokkamuuttujina, esimerkiksi väri valkoinen löytyy luokkamuuttujasta <code>Color.WHITE</code>.</p>

<p>Korvattu <code>paintComponent</code> metodi kutsuu yläluokan <code>paintComponent</code>-metodia eikä tee muuta. Lisätään piirtoalusta seuraavaksi käyttöliittymäluokan <code>luoKomponentit</code>-metodiin. Käytämme kappaleen <a href="#58">58. Käyttöliittymät</a> alussa määriteltyä käyttöliittymäpohjaa.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        container.add(new Piirtoalusta());
    }
</pre>

<p>Käynnistäessämme käyttöliittymän näemme tyhjän ruudun, jonka taustaväri on valkoinen. Alla olevan käyttöliittymän toivotuksi kooksi on asetettu <code>setPreferredSize</code>-metodilla 300, 300, ja sen otsikko on <code>"Piirtoalusta"</code>.</p>

    <p><img src="img-ohja/kali/piirtoalusta.png"/></p>

<p>Piirtoalustalle piirtäminen tapahtuu <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html" target="_blank">Graphics</a></code>-olion tarjoamien metodien avulla. Muokataan <code>Piirtoalusta</code>-luokan metodia <code>paintComponent</code> siten, että siinä piirretään kaksi suorakulmiota <code>Graphics</code>-olion tarjoaman metodin <code>fillRect</code> avulla.</p>

<pre class="sh_java">
    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);

        graphics.fillRect(50, 80, 100, 50);
        graphics.fillRect(200, 20, 50, 200);
    }
</pre>

<p>Metodi <code>fillRect</code> saa parametrina suorakulmion <code>x</code>, ja <code>y</code> -koordinaatit, sekä suorakulmion leveyden ja korkeuden tässä järjestyksessä. Yllä siis piirretään ensin koordinaatista <code>(50, 80)</code> alkava 100 pikseliä leveä ja 50 pikseliä korkea suorakulmio. Tämän jälkeen piirretään koordinaatista <code>(200, 20)</code> alkava 50 pikseliä leveä ja 100 pikseliä korkea suorakulmio.</p>

<p>Kuten piirtotuloksesta huomaat, koordinaatisto ei toimi aivan kuten olemme tottuneet.</p>

    <p><img src="img-ohja/kali/piirtoalusta-suorakulmiot.png"/></p>

<p>Javan <code>Graphics</code>-olio (ja useiden muiden ohjelmointikielten käyttöliittymäkirjastot) olettaa että y-akselin arvo kasvaa alaspäin mennessä. Koordinaatiston origo, eli piste <code>(0, 0)</code> on piirrettävän alueen vasemmassa yläkulmassa: Graphics-olio tietää aina käyttöliittymäkomponentin, johon piirretään, ja osaa sen perusteella päätellä piirtotapahtuman sijainnin. Käyttöliittymän origon sijainti selkeytyy seuraavalla ohjelmalla. Piirretään ensin pisteestä (0, 0) lähtevä 10 pikseliä leveä ja 200 pikseliä korkea vihreä suorakulmio. Tämän jälkeen piirretään pisteestä (0, 0) lähtevä 200 pikseliä leveä ja 10 pikseliä korkea musta. Seuraavana piirrettävän kuvion väri määritellään <code>Graphics</code>-oliolle metodilla <code>setColor</code>.</p>


<pre class="sh_java">
    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);

        graphics.setColor(Color.GREEN);
        graphics.fillRect(0, 0, 10, 200);
        graphics.setColor(Color.BLACK);
        graphics.fillRect(0, 0, 200, 10);
    }
</pre>

    <p><img src="img-ohja/kali/piirtoalusta-koordinaatisto.png"/></p>

<p>Tämä koordinaatiston käänteisyys johtuu siitä, miten käyttöliittymien kokoa muokataan. Käyttöliittymän kokoa muutettaessa sitä pienennetään tai suurennetaan "oikeasta alakulmasta vetäen", jolloin ruudulla näkyvä piirros siirtyy kokoa muuttaessa. Kun koordinaatisto alkaa vasemmasta yläkulmasta, on piirroksen sijainti aina sama, mutta näkyvä osa muuttuu.</p>

<div class="tehtavat">

<h3>Piirtoalusta ja Piirtäminen</h3>

<p>Tehtäväpohjassa on valmiina käyttöliittymä, johon on kytketty <code>JPanel</code>-luokan perivä luokka <code>Piirtoalusta</code>. Muuta luokan <code>Piirtoalusta</code> metodin <code>paintComponent</code> toteutusta siten, että se piirtää seuraavanlaisen kuvion. Saat käyttää tehtävässä vain <code>graphics</code>-olion <code>fillRect</code>-metodia.</p>

<p><img src="img-ohja/smiley.gif"/></p>

<p>Huom! Älä käytä enempää kuin viittä <code>fillRect</code>-kutsua. Kuvion ei tarvitse olla täsmälleen samanlainen kuin ylläoleva, testit kertovat kun piirtämäsi kuva on tarpeeksi lähellä haluttua kuvaa.</p>

</div>

<p>Laajennetaan edellistä esimerkkiä siten, että piirrämme käyttöliittymässä erillisen hahmo-olion. Luodaan hahmon edustamiseen luokka <code>Hahmo</code>. Hahmolla on koordinaatteina ilmaistu sijainti, ja se piirretään ympyränä jonka halkaisija on 10 pikseliä. Hahmon sijaintia voi muuttaa kutsumalla sen <code>siirry</code>-metodia.</p>

<pre class="sh_java">
import java.awt.Graphics;

public class Hahmo {

    private int x;
    private int y;

    public Hahmo(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public void siirry(int xmuutos, int ymuutos) {
        this.x += xmuutos;
        this.y += ymuutos;
    }

    public void piirra(Graphics graphics) {
        graphics.fillOval(x, y, 10, 10);
    }
}
</pre>

<p>Muutetaan piirtoalustaa siten, että sille annetaan <code>Hahmo</code>-luokan ilmentymä konstruktorin parametrina. Luokan <code>Piirtoalusta</code> metodi <code>paintComponent</code> ei itse piirrä hahmoa, vaan delegoi piirtovastuun <code>Hahmo</code>-luokan ilmentymälle.</p>

<pre class="sh_java">
import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JPanel;

public class Piirtoalusta extends JPanel {

    private Hahmo hahmo;

    public Piirtoalusta(Hahmo hahmo) {
        super.setBackground(Color.WHITE);
        this.hahmo = hahmo;
    }

    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);
        hahmo.piirra(graphics);
    }
}
</pre>

<p>Annetaan hahmo myös käyttöliittymälle parametrina. Hahmo on siis käyttöliittymästä erillinen olio, joka vain halutaan piirtää käyttöliittymässä. Oleelliset muutokset käyttöliittymäluokassa ovat siis konstruktorin muuttaminen siten, että se saa parametrina <code>Hahmo</code>-olion. Tämän lisäksi metodissa <code>luoKomponentit</code> annetaan <code>Hahmo</code>-luokan ilmentymä parametrina luotavalle <code>Piirtoalusta</code>-oliolle.</p>

<pre class="sh_java">
public class Kayttoliittyma implements Runnable {

    private JFrame frame;
    private Hahmo hahmo;

    public Kayttoliittyma(Hahmo hahmo) {
        this.hahmo = hahmo;
    }

// ...

    private void luoKomponentit(Container container) {
        Piirtoalusta piirtoalusta = new Piirtoalusta(hahmo);
        container.add(piirtoalusta);
    }
// ...
</pre>

<p>Käyttöliittymän voi nyt käynnistää antamalla sen konstruktorille <code>Hahmo</code>-olion parametrina.</p>

<pre class="sh_java">
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Hahmo(30, 30));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

    <p><img src="img-ohja/kali/piirtoalusta-hahmon-piirtaminen.png"/></p>

<p>Yllä olevassa käyttöliittymässä näkyy huikea, pallonmuotoinen hahmo.</p>

<p>Lisätään seuraavaksi ohjelmaan hahmon siirtämistoiminnallisuus. Haluamme liikuttaa hahmoa näppäimistöllä. Kun käyttäjä painaa nuolta vasemmalle, hahmon pitäisi siirtyä vasemmalle. Oikealle osoittavaa nuolta painettaessa hahmon pitäisi siirtyä oikealle. Tarvitsemme siis tapahtumankuuntelijan, joka kuuntelee näppäimistöä. Rajapinta <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/KeyListener.html" target="_blank">KeyListener</a></code> määrittelee näppäimistönkuuntelijalta vaaditut toiminnallisuudet.</p>

<p>Rajapinta <code>KeyListener</code> vaatii metodien <code>keyPressed</code>, <code>keyReleased</code>, ja <code>keyTyped</code> toteuttamista. Olemme kiinnostuneita vain tapahtumasta, jossa näppäintä painetaan, joten jätämme metodit <code>keyReleased</code> ja <code>keyTyped</code> tyhjiksi. Luodaan luokka <code>NappaimistonKuuntelija</code>, joka toteuttaa rajapinnan <code>KeyListener</code>. Luokka saa parametrina <code>Hahmo</code>-olion, jota tapahtumankäsittelijän tulee liikuttaa.</p>

<pre class="sh_java">
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class NappaimistonKuuntelija implements KeyListener {

    private Hahmo hahmo;

    public NappaimistonKuuntelija(Hahmo hahmo) {
        this.hahmo = hahmo;
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            hahmo.siirry(-5, 0);
        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
            hahmo.siirry(5, 0);
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }

    @Override
    public void keyTyped(KeyEvent ke) {
    }
}
</pre>

<p>Metodi <code>keyPressed</code> saa käyttöliittymältä parametrina <code>KeyEvent</code>-luokan ilmentymän. KeyEvent-oliolta saa tietoon painettuun nappiin liittyvän numeron sen <code>getKeyCode()</code>-metodilla. Eri näppäimille on luokkamuuttujat <code>KeyEvent</code>-luokassa, esimerkiksi nuoli vasemmalle on <code>KeyEvent.VK_LEFT</code>.</p>

<p>Haluamme kuunnella käyttöliittymään kohdistuvia näppäimen painalluksia (emme esimerkiksi ole kirjoittamassa tekstikenttään), joten lisätään näppäimistönkuuntelija <code>JFrame</code>-luokan ilmentymälle. Muokataan käyttöliittymäämme siten, että näppäimistönkuuntelija lisätään JFrame-oliolle.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        Piirtoalusta piirtoalusta = new Piirtoalusta(hahmo);
        container.add(piirtoalusta);

        frame.addKeyListener(new NappaimistonKuuntelija(hahmo));
    }
</pre>

<p>Nyt sovelluksemme kuuntelee näppäimistöltä tulleita painalluksia, ja ohjaa ne luokan <code>NappaimistonKuuntelija</code> ilmentymälle.</p>

<p>Kokeillessamme käyttöliittymää se ei kuitenkaan toimi: hahmo ei siirry ruudulla. Mistä tässä oikein on kyse? Voimme tarkastaa että näppäimistön painallukset ohjautuvat <code>NappaimistonKuuntelija</code>-oliolle lisäämällä <code>keyPressed</code>-metodin alkuun testitulostuksen.</p>

<pre class="sh_java">
    @Override
    public void keyPressed(KeyEvent e) {
        System.out.println("Nappia " + e.getKeyCode() +  " painettu.");

        // ...
</pre>

<p>Käynnistäessämme ohjelman ja painaessamme näppäimiä näemme konsolissa tulostuksen.</p>

<pre>
Nappia 39 painettu.
Nappia 37 painettu.
Nappia 40 painettu.
Nappia 38 painettu.
</pre>

<p>Huomaamme että näppäimistön kuuntelija toimii, mutta piirtoalusta ei päivity.</p>

<h3>Piirtoalustan uudelleenpiirtäminen</h3>

<p>Käyttöliittymäkomponentit sisältävät yleensä toiminnallisuuden komponentin ulkoasun uudelleenpiirtämiseen tarvittaessa. Esimerkiksi nappia painettaessa <code>JButton</code>-luokan ilmentymä osaa piirtää napin "painettuna", jonka jälkeen nappi piirretään taas normaalina. Toteuttamassamme piirtoalustassa ei ole valmista päivitystoiminnallisuutta, vaan meidän tulee pyytää sitä piirtämään itsensä uudelleen tarvittaessa.</p>

<p>Jokaisella <code>Component</code>-luokan aliluokalla on metodi <code>public void repaint()</code>, jonka kutsuminen pakottaa komponentin uudelleenpiirtämisen. Haluamme että <code>Piirtoalusta</code>-olio piirretään uudestaan aina kun hahmoa siirretään. Hahmon siirtäminen tapahtuu luokassa <code>NappaimistonKuuntelija</code>, joten on loogista että uudelleenpiirtokutsu tapahtuu myös näppäimistönkuuntelijassa.</p>

<p>Uudelleenpiirtokutsua varten näppäimistönkuuntelija tarvitsee viitteen piirtoalustaan. Muutetaan luokkaa <code>NappaimistonKuuntelija</code> siten, että se saa parametrinaan <code>Hahmo</code>-olion lisäksi uudelleenpiirrettävän <code>Component</code>-olion. Kutsutaan <code>Component</code>-olion <code>repaint</code>-metodia jokaisen <code>keyPressed</code> tapahtuman lopussa.</p>

<pre class="sh_java">
import java.awt.Component;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class NappaimistonKuuntelija implements KeyListener {

    private Component component;
    private Hahmo hahmo;

    public NappaimistonKuuntelija(Hahmo hahmo, Component component) {
        this.hahmo = hahmo;
        this.component = component;
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            hahmo.siirry(-5, 0);
        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
            hahmo.siirry(5, 0);
        }

        component.repaint();
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }

    @Override
    public void keyTyped(KeyEvent ke) {
    }
}
</pre>

<p>Muutetaan myös <code>Kayttoliittyma</code>-luokan <code>luoKomponentit</code>-metodia siten, että <code>Piirtoalusta</code>-luokan ilmentymä annetaan parametrina näppäimistönkuuntelijalle.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        Piirtoalusta piirtoalusta = new Piirtoalusta(hahmo);
        container.add(piirtoalusta);

        frame.addKeyListener(new NappaimistonKuuntelija(hahmo, piirtoalusta));
    }
</pre>

<p>Nyt hahmon liikuttaminen myös näkyy käyttöliittymässä. Aina kun käyttäjä painaa näppäimistöä, käyttöliittymään liitetty näppäimistönkuuntelija käsittelee kutsun. Jokaisen kutsun lopuksi kutsutaan piirtoalustan <code>repaint</code>-metodia, joka aiheuttaa piirtoalustan uudelleenpiirtämisen.</p>

    <p><img src="img-ohja/kali/piirtoalusta-hahmo-liikkuu.png"/></p>

<div class="tehtavat">
<h3>Liikkuva kuvio</h3>

<p>Teemme ohjelman, jossa käyttäjä voi liikutella näppäimistön avulla ruudulle piirrettyjä kuvioita. Ohjelmassa tulee mukana käyttöliittymärunko, jota pääset muokkaamaan ohjelman edetessä.</p>

<p>Aluksi tehdään muutama luokka, joilla kuvioita hallitaan. Pääsemme myöhemmin piirtämään kuvioita ruudulle. Tee kaikki ohjelman luokat pakkaukseen <code>liikkuvakuvio</code>.</p>

<p>Tehtävässä käytetään perintää ja abstrakteja luokkia. Kertaa siis tarvittaessa values 18.1, 18.2 ja 18.5</p></p>

<h4 class="req">Abstrakti luokka Kuvio</h4>

<p>Tee abstrakti luokka <code>Kuvio</code>. Kuviolla on oliomuuttujat <code>x</code> ja <code>y</code>, jotka kertovat kuvion sijainnin ruudulla sekä metodi <code>public void siirra(int dx, int dy)</code>, jonka avulla kuvion sijainti siirtyy parametrina olevien koordinaattisiirtymien verran. Esim. jos sijainti aluksi on (100,100), niin kutsun <code>siirra(10,-50)</code> jälkeen sijainti on (110, 50). Luokan konstruktorin <code>public Kuvio(int x, int y)</code> tulee asettaa kuviolle alkusijainti. Lisää luokalle myös metodit <code>public int getX()</code> ja <code>public int getY()</code>.</p>

<p>Luokalla tulee olla myös abstrakti metodi <code>public abstract void piirra(Graphics graphics)</code>, jolla kuvio piirretään piirtoalustalle. Kuvion piirtämismetodi toteutetaan luokan <code>Kuvio</code> perivissä metodeissa.</p>

<h4 class="req">Ympyra</h4>

<p>Tee luokka <code>Ympyra</code> joka perii Kuvion. Ympyrällä on <code>halkaisija</code> jonka arvon konstruktori <code>public Ympyra(int x, int y, int halkaisija)</code>. Sijainti tallennetaan yläluokassa määriteltyihin oliomuuttujiin. 
</p>

<p>
Ympyra määrittelee metodin <code>piirra</code> siten, että oikean kokoinen ympyrä piirretään koordinaattien osoittamaan paikkaan
parametrina olevan <code>Graphics</code>-olion <code>fillOval</code>-metodia käyttäen, ympyrän sijaintia tulee käyttää metodin kahtena ensimmäisenä parametrina. Ota mallia Hahmo-esimerkin vastaavasta metodista.
Graphics-olion metodien toimintaa kannattaa tutkia <a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html">Java API:sta.</a> 
</p>

<h4 class="req">Piirtoalusta</h4>

<p>Luo luokka <code>Piirtoalusta</code> joka perii luokan <code>JPanel</code>, mallia voit ottaa esimerkiksi edellisen tehtävän mukana tulleesta piirtoalustasta. Piirtoalusta saa konstruktorin parametrina <code>Kuvio</code>-tyyppisen olion. Korvaa luokan <code>JPanel</code> metodi <code>protected void paintComponent(Graphics g)</code> siten, että siinä kutsutaan ensin yläluokan <code>paintComponent</code>-metodia ja sitten piirtoalustalle asetetun kuvion <code>piirra</code>-metodia.</p>

<p>Muokkaa luokkaa <code>Kayttoliittyma</code> siten, että se saa konstruktorin parametrina <code>Kuvio</code>-tyyppisen olion. Lisää käyttöliittymään Piirtoalusta <code>luoKomponentit(Container container)</code>-metodissa, anna piirtoalustalle konstruktorin parametrina käyttöliittymälle annettu kuvio.</p>

<p>Testaa lopuksi että seuraavalla esimerkkikoodilla ruudulle piirtyy ympyrä.</p>

<pre class="sh_java">
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Ympyra(50, 50, 250));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

<p><img src="img-ohja/kali/liikkuvakuvio-ympyra.png"/></p>



        <h4 class="req">Näppäimistöohjaus</h4>

<p>Laajennetaan piirtoalustaa siten, että kuviota voi liikutella nuolinäppäinten avulla. Luo rajapinnan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/KeyListener.html" target="_blank">KeyListener</a></code> toteuttava luokka <code>NappaimistonKuuntelija</code>. Luokan <code>NappaimistonKuuntelija</code> konstruktorin parametrit ovat luokan <code>Component</code> ilmentymä ja luokan <code>Kuvio</code> ilmentymä.</p>

<p>Luokan Component ilmentymä annetaan näppäimistönkuuntelijalle, jotta voimme päivittää halutun komponentin jokaisen näppäimenpainalluksen jälkeen uudestaan. Komponentin päivittäminen tapahtuu kutsumalla <code>Component</code> luokasta perityvää metodia <code>repaint</code>. Luokka Piirtoalusta on tyyppiä <code>Component</code> koska <code>Component</code> on luokan <code>JPanel</code> perivän luokan yläluokka.</p>

<p>Toteuta rajapinnan <code>KeyListener</code> määrittelemä metodi <code>keyPressed(KeyEvent e)</code> siten, että käyttäjän painaessa nuolta vasemmalle kuvio siirtyy yhden pykälän vasemmalle. Oikealle painettaessa yksi oikealle. Ylös painettaessa yksi ylös, ja alas painettaessa yksi alas. Huomaa että y-akseli kasvaa ikkunan yläosasta alaspäin. Näppäinkoodit nuolinäppäimille ovat <code>KeyEvent.VK_LEFT</code>, <code>KeyEvent.VK_RIGHT</code>, <code>KeyEvent.VK_UP</code>, ja <code>KeyEvent.VK_DOWN</code>. Jätä muut rajapinnan <code>KeyListener</code> vaatimat metodit tyhjiksi.</p>

<p>Kutsu aina Component-luokan <code>repaint</code>-metodia näppäimistönkuuntelutapahtuman lopussa.</p>

<p>Lisää näppäimistönkuuntelija Kayttoliittyma-luokan <code>lisaaKuuntelijat</code>-metodissa. Näppäimistönkuuntelija tulee liittää <code>JFrame</code>-olioon.</p>


        <h4 class="req">Nelio ja Laatikko</h4>


<p>Peri luokasta <code>Kuvio</code> luokat <code>Nelio</code> ja <code>Laatikko</code>. Neliöllä on konstruktori <code>public Nelio(int x, int y, int sivunPituus)</code>, laatikon konstruktori on muotoa <code>public Laatikko(int x, int y, int leveys, int korkeus)</code>. Käytä piirtämisessä graphics-olion <code>fillRect</code>-metodia.</p>

<p>Varmista, että neliöt ja laatikot piirtyvät ja liikkuvat oikein Piirtoalustalla.</p>

<pre class="sh_java">
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Nelio(50, 50, 250));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

<p><img src="img-ohja/kali/liikkuvakuvio-nelio.png"/></p>


<pre class="sh_java">
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Laatikko(50, 50, 100, 300));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

<p><img src="img-ohja/kali/liikkuvakuvio-laatikko.png"/></p>

        <h4 class="req">Koostekuvio</h4>

        <p>Peri luokasta <code>Kuvio</code> luokka <code>Koostekuvio</code>. Koostekuvio sisältää joukon muita kuvioita jotka se tallettaa ArrayList:iin. Koostekuviolla on metodi <code>public void liita(Kuvio k)</code> jonka avulla koostekuvioon voi liittää kuvio-olion. Koostekuviolla ei ole omaa sijaintia ja ei ole merkitystä mitä koostekuvio asettaa perimiensä x- ja y-koordinaatin arvoiksi. Koostekuvio piirtää itsensä pyytämällä osiaan piirtämään itsensä, koostekuvion siirtyminen tapahtuu samoin. Kuviolta peritty metodi <code>siirra</code> on siis ylikirjoitettava!</p>

        <p>Testaa että koostekuviosi piirtyy ja siirtyy oikein, esim. seuraavan koostekuvion avulla:</p>

<pre class="sh_java">
        Koostekuvio rekka = new Koostekuvio();

        rekka.liita(new Laatikko(220, 110, 75, 100));
        rekka.liita(new Laatikko(80, 120, 200, 100));
        rekka.liita(new Ympyra(100, 200, 50));
        rekka.liita(new Ympyra(220, 200, 50));

        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(rekka);
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

<p><img src="img-ohja/kali/liikkuvakuvio-rekka.png"/></p>



        <p>Huomaa miten <b>olioiden vastuut</b> jakautuvat tehtävässä. Jokainen Kuvio on vastuussa itsensä piirtämisestä ja siirtämisestä. Yksinkertaiset kuviot siirtyvät kaikki samalla tavalla. Jokaisen yksinkertaisen kuvion on itse hoidettava piirtymisestään. Koostekuvio siirtää itsensä pyytämällä osiaan siirtymään, samoin hoituu koostekuvion piirtyminen. Piirtoalusta tuntee Kuvio-olion joka siis voi olla mikä tahansa yksinkertainen kuvio tai koostekuvio, kaikki piirretään ja siirretään samalla tavalla. Piirtoalusta siis toimii samalla tavalla kuvion oikeasta tyypistä huolimatta, piirtoalustan ei tarvitse tietää kuvion yksityiskohdista mitään. Kun piirtoalusta kutsuu kuvion metodia <code>piirra</code> tai <code>siirra</code> <b>polymorfismin</b> ansiosta kutsutuksi tulee kuvion todellista tyyppiä vastaava metodi.</p>

        <p>Huomionarvoista tehtävässä on se, että Koostekuvio voi sisältää mitä tahansa Kuvio-olioita, siis myös koostekuvioita! Luokkarakenne mahdollistaakin mielivaltaisen monimutkaisen kuvion muodostamisen ja kuvion siirtely ja piirtäminen tapahtuu aina täsmälleen samalla tavalla.</p>

        <p>Luokkarakennetta on myös helppo laajentaa, esim. perimällä Kuvio-luokasta uusia kuviotyyppejä: kolmio, piste, viiva, ym... Koostekuvio toimii ilman muutoksia myös uusien kuviotyyppien kanssa, samoin piirtoalusta ja käyttöliittymä.</p>

</div>


<h3>Valmiit sovelluskehykset</h3>

<p>Sovelluskehys on ohjelma, joka tarjoaa lähtökohdan ja joukon palveluita jonkin erityisen sovelluksen toteuttamiseen. Yksi tapa laatia sovelluskehys on laatia valmiita palveluita tarjoava luokka, jonka päälle luokan perivät luokat rakentavat erityisen sovelluksen. Sovelluskehykset ovat yleensä hyvin laajoja, ja tarkoitettu johonkin tiettyyn tarkoitukseen, esimerkiksi pelien ohjelmointiin tai web-sovelluskehitykseen. Tutustutaan seuraavasti pikaisesti valmiin sovelluskirjaston käyttöön luomalla sovelluslogiikka Game of Life -pelille.</p>

<div class="tehtavat">
<h3>Game of Life</h3>

<p>Tässä tehtäväsarjassa toteutetaan sovelluslogiikka Game of Life-pelille perimällä valmis sovellusrunko. Sovellusrunko on projektiin erikseen lisätyssä kirjastossa, joten sen lähdekoodit eivät ole nähtävissä.</p>

<p><b>HUOM:</b> tehtävä ei ole erityisen vaikea, mutta tehtävänanto saattaa aluksi vaikuttaa sekavalta. Lue ohje tarkasti uudelleen tai kysy apua jos et pääse alkuun. Tehtävä kannattaa ehdottomasti tehdä, sillä lopputulos on hieno!</p>

<p>Game of Life on matemaatikko John Conway'n kehittelemä yksinkertainen "populaatiosimulaattori", kts. <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life</a>.</p>

<p>Game of Lifen säännöt ovat seuraavat:</p>
<ul>
<li>Jokainen elossa oleva solu, jolla on alle kaksi elossa olevaa naapuria kuolee.</li>
<li>Jokainen elossa oleva solu, jolla on kaksi tai kolme elossa olevaa naapuria elää seuraavaan iteraatioon eli kierrokseen.</li>
<li>Jokainen elossa oleva solu, jolla on yli kolme naapuria kuolee.</li>
<li>Jokainen kuollut solu, jolla on tasan kolme elossa olevaa naapuria muuttuu eläväksi.</li>
</ul>

<p>Abstrakti luokka <code>GameOfLifeAlusta</code> tarjoaa seuraavat toiminnot</p>
<ul>
  <li><b>public GameOfLifeAlusta(int leveys, int korkeus)</b> luo määritellyn kokoisen pelialustan</li>
  <li><b>public boolean[][] getAlusta()</b> tarjoaa pääsyn pelialustaan, joka on totuusarvoista koostuva kaksiulotteinen taulukko &ndash; kuten metodin paluuarvosta voi havaita! Palaamme kaksiulotteiseen taulukkoon tarkemmin sitä tarvitessamme.</li>
  <li><b>public int getLeveys()</b> palauttaa alustan leveyden</li>
  <li><b>public int getKorkeus()</b> palauttaa alustan korkeuden</li>
  <li><b>public void pelaaKierros()</b> simuloi pelikierroksen</li>
</ul>

<p>Luokassa <code>GameOfLifeAlusta</code> on lisäksi määritelty seuraavat abstraktit metodit, <b>jotka sinun tulee toteuttaa</b>.<p>

<ul>
  <li><b>public abstract void muutaElavaksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) eläväksi eli asettaa sille arvon <i>true</i>. Jos koordinaatit ovat alustan ulkopuolella ei tapahdu mitään.</li>
  <li><b>public abstract void muutaKuolleeksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) kuolleeksi eli asettaa sille arvon <i>false</i>. Jos koordinaatit ovat alustan ulkopuolella ei tapahdu mitään.</li>
  <li><b>public abstract boolean onElossa(int x, int y)</b> kertoo onko koordinaatissa (x, y) oleva alkio elossa. Jos koordinaatit ovat alustan ulkopuolella, palautetaan <i>false.</i></li>
  <li><b>public abstract void alustaSatunnaisetPisteet(double todennakoisyysPisteelle)</b> alustaa kaikki alustan alkiot siten, että kukin alkio on elävä todennäköisyydellä <i>todennakoisyysPisteelle.</i> Todennäköisyys annetaan double-arvona suljetulla välillä [0, 1]. Jos metodia kutsutaan arvolla 1, tulee jokaisen alkion olla elävä. Jos taas todennäköisyys on 0, tulee jokaisen alkion olla kuollut.</li>
  <li><b>public abstract int getElossaOlevienNaapurienLukumaara(int x, int y)</b> kertoo elossa olevien naapureiden lukumäärän solulle pisteessä (x, y).</li>
  <li><b>public abstract void hoidaSolu(int x, int y, int elossaOleviaNaapureita)</b> hoitaa solun (x, y) Game of Life -sääntöjen mukaan.</li>
</ul>


<h4>GameOfLife-toteutus, vaihe 1</h4>

<p>Luo pakkaukseen <code>game</code> luokka <code>OmaAlusta</code>, joka perii pakkauksessa <code>gameoflife</code> olevan luokan <code>GameOfLifeAlusta</code>. Huomaa että pakkausta <code>gameoflife</code> ei ole näkyvillä omassa projektissasi, vaan se tulee mukana luokkakirjastona. Toteuta luokalle <code>OmaAlusta</code> konstruktori <code>public OmaAlusta(int leveys, int korkeus)</code>, joka kutsuu yläluokan konstruktoria annetuilla parametreilla:</p>

<pre class="sh_java">
import gameoflife.GameOfLifeAlusta;

public class OmaAlusta extends GameOfLifeAlusta {

    public OmaAlusta(int leveys, int korkeus) {
        super(leveys, korkeus);
    }

    // ..
</pre>

<p>Voit ensin korvata kaikki abstraktit metodit ei-abstrakteilla metodeilla, jotka eivät kuitenkaan vielä tee mitään järkevää. Mutta koska ne eivät ole abstrakteja, tästä luokasta voi luoda ilmentymiä, toisin kuin abstraktista luokasta GameOfLifeAlusta.</p>

<p>Toteuta seuraavat metodit</p>
<ul>
  <li><b>public void muutaElavaksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) eläväksi eli asettaa sille arvon <i>true</i></li>
  <li><b>public void muutaKuolleeksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) kuolleeksi eli asettaa sille arvon <i>false</i></li>
  <li><b>public boolean onElossa(int x, int y)</b> kertoo onko koordinaatissa (x, y) oleva alkio elossa. Jos koordinaatit ovat alustan ulkopuolella, palautetaan <i>false.</i></li>
</ul>

<p><b>Vihje:</b> Pääset yläluokassa olevaan kaksiulotteiseen taulukkoon käsiksi yläluokan tarjoaman metodin <code>getAlusta()</code> avulla. Kaksiulotteisia taulukoita käytetään kuten yksiulotteisia taulukoita, mutta taulukoille annetaan kaksi indeksiä. Ensimmäinen indeksi kertoo leveyskohdan, toinen indeksi korkeuskohdan. Esimerkiksi seuraava ohjelmapätkä luo ensin 10 x 10 -kokoisen taulukon, ja tulostaa sitten taulukon indeksissä 3, 1 olevan arvon.</p>

<pre class="sh_java">
boolean[][] arvot = new boolean[10][10];
System.out.println(arvot[3][1]);
</pre>

<p>Vastaavasti OmaAlusta-luokassa voidaan tulostaa yläluokasta saadun taulukon arvo indeksissä x, y seuraavasti:</p>

<pre class="sh_java">
boolean[][] alusta = getAlusta();
System.out.println(alusta[x][y]);
</pre>

<p>Ja indeksiin x,y voidaan asettaa esim. arvo true seuraavasti:</p>

<pre class="sh_java">
boolean[][] alusta = getAlusta();
alusta[x][y] = true;
</pre>

<p>Tai suoraan käyttämättä apumuuttujaa:</p>

<pre class="sh_java">
getAlusta()[x][y] = true;    
</pre>


<p>Testaa toteutustasi seuraavalla testiohjelmalla.</p>
<pre class="sh_java">
package game;

import gameoflife.komentorivi.KomentoriviGameOfLife;

public class Main {
    public static void main(String[] args) {
        OmaAlusta alusta = new OmaAlusta(7, 5);

        alusta.muutaElavaksi(2, 0);
        alusta.muutaElavaksi(4, 0);

        alusta.muutaElavaksi(3, 3);
        alusta.muutaKuolleeksi(3, 3);

        alusta.muutaElavaksi(0, 2);
        alusta.muutaElavaksi(1, 3);
        alusta.muutaElavaksi(2, 3);
        alusta.muutaElavaksi(3, 3);
        alusta.muutaElavaksi(4, 3);
        alusta.muutaElavaksi(5, 3);
        alusta.muutaElavaksi(6, 2);

        KomentoriviGameOfLife gom = new KomentoriviGameOfLife(alusta);
        gom.pelaa();
    }
}
</pre>
<p>

Tulostuksen pitäisi olla seuraavanlainen:

<pre>
Paina enter jatkaaksesi, muut lopettaa: &lt;enter&gt;

  X X

X     X
 XXXXX

Paina enter jatkaaksesi, muut lopettaa: <font color="red">stop</font>
Kiitos!
</pre>
<p>

<h4>GameOfLife-toteutus, vaihe 2</h4>

<p>Toteuta metodi <b>alustaSatunnaisetPisteet(double todennakoisyysPisteelle)</b>, joka alustaa kaikki alkiot siten, että kukin alkio on elävä todennäköisyydellä <i>todennakoisyysPisteelle</i>. Todennäköisyys annetaan metodille suljetulla välillä [0, 1] olevana double-tyyppisenä parametrina.</p>

<p>Testaa metodia. Arvolla 0.0 ei pitäisi olla yhtään elossa olevaa solua, arvolla 1.0 kaikkien solujen tulisi olla elossa (eli näkyä X-merkkisinä). Arvolla 0.5 noin puolet soluista on eläviä.</p>

<pre class="sh_java">
        OmaAlusta alusta = new OmaAlusta(3, 3);
        alusta.alustaSatunnaisetPisteet(1.0);

        KomentoriviGameOfLife gom = new KomentoriviGameOfLife(alusta);
        gom.pelaa();
</pre>

<pre>
Paina enter jatkaaksesi, muut lopettaa: &lt;enter&gt;

XXX
XXX
XXX
Paina enter jatkaaksesi, muut lopettaa: <font color="red">stop</font>
Kiitos!
</pre>


<h4>GameOfLife-toteutus, vaihe 3</h4>

<p>Toteuta metodi <b>getElossaOlevienNaapurienLukumaara(int x, int y),</b> joka laskee elossa olevien naapurien lukumäärän. Keskellä
taulukkoa olevalla solulla on yhteensä kahdeksan naapuria, reunassa olevalla solulla 5, kulmassa olevalla 3. </p>

<p>Testaa metodia seuraavilla lauseilla (voit keksiä myös muita testitapauksia!):</p>

<pre class="sh_java">
OmaAlusta alusta = new OmaAlusta(7, 5);

alusta.muutaElavaksi(0, 1);
alusta.muutaElavaksi(1, 0);
alusta.muutaElavaksi(1, 2);
alusta.muutaElavaksi(2, 2);
alusta.muutaElavaksi(2, 1);

System.out.println("Elossa naapureita (0,0): " + alusta.getElossaOlevienNaapurienLukumaara(0, 0));
System.out.println("Elossa naapureita (1,1): " + alusta.getElossaOlevienNaapurienLukumaara(1, 1));
</pre>
<p>

Tulostuksen pitäisi olla seuraavanlainen:
<pre>
Elossa naapureita (0,0): 2
Elossa naapureita (1,1): 5
</pre>


<h4>GameOfLife-toteutus, vaihe 4</h4>

<p>Jäljellä on vielä metodin <b>hoidaSolu(int x, int y, int elossaOleviaNaapureita)</b> toteuttaminen. GameOfLife-pelin säännöthän olivat seuraavat:</p>

<ul>
  <li>Jokainen elossa oleva solu, jolla on alle kaksi elossa olevaa naapuria kuolee.</li>
  <li>Jokainen elossa oleva solu, jolla on kaksi tai kolme elossa olevaa naapuria elää seuraavaan iteraatioon eli kierrokseen.</li>
  <li>Jokainen elossa oleva solu, jolla on yli kolme naapuria kuolee.</li>
  <li>Jokainen kuollut solu, jolla on tasan kolme elossa olevaa naapuria muuttuu eläväksi.</li>
</ul>

<p>Toteuta metodi <code>hoidaSolu(int x, int y, int elossaOleviaNaapureita)</code> ylläolevien sääntöjen mukaan. Kannattaa ohjelmoida ja testata yksi sääntö kerrallaan!</p>

<p>Kun olet saanut kaikki valmiiksi, voit testata ohjelman toimintaa seuraavalla graafisella simulaattorilla.</p>

<pre class="sh_java">
package game;

import gameoflife.Simulaattori;

public class Main {

    public static void main(String[] args) {
        OmaAlusta alusta = new OmaAlusta(100, 100);
        alusta.alustaSatunnaisetPisteet(0.7);

        Simulaattori simulaattori = new Simulaattori(alusta);
        simulaattori.simuloi();
    }
}
</pre>

</div>

<div class="tyhja"></div>

<div class="viikkoraja">Viikko 6</div>

<h2>Muutamia hyödyllisiä tekniikoita</h2>

<p>Kurssin lähestyessä loppua katsomme vielä muutamaa hyödyllistä Javan ominaisuutta.</p>

<h3>Säännölliset lausekkeet</h3>

<p>Säännöllinen lauseke määrittelee tiiviissä muodossa joukon characterStringja. Säännöllisiä lausekkeita käytetään muunmuassa characterStringjen oikeellisuuden tarkistamiseen. Tarkastellaan tehtävää, jossa täytyy tarkistaa, onko käyttäjän antama opiskelijanumero oikeanmuotoinen. Opiskelijanumero alkaa characterStringlla "01", jota seuraa 7 numeroa väliltä 0&ndash;9.</p>

<p>Opiskelijanumeron oikeellisuuden voisi tarkistaa esimerkiksi käymällä opiskelijanumeroa esittävän characterStringn läpi merkki merkiltä <code>charAt</code>-metodin avulla. Toinen tapa olisi tarkistaa että ensimmäinen merkki on "0", ja käyttää <code>Integer.parseInt</code> metodikutsua characterStringn muuntamiseen numeroksi. Tämän jälkeen voisi tarkistaa että <code>Integer.parseInt</code>-metodin palauttama luku on pienempi kuin 20000000.</p>

<p>Oikeellisuuden tarkistus säännöllisten lausekkeiden avulla vaatii ensin sopivan säännöllisen lausekkeen määrittelyn. Tämän jälkeen voimme käyttää <code>String</code>-luokan metodia <code>matches</code>, joka tarkistaa vastaako characterString parametrina annettua säännöllistä lauseketta. Opiskelijanumeron tapauksessa sopiva säännöllinen lauseke on <code>"01[0-9]{7}"</code>, ja käyttäjän syöttämän opiskelijanumeron tarkistaminen käy seuraavasti:</p>

<pre class="sh_java">
System.out.print("Anna opiskelijanumero: ");
String numero = reader.nextLine();

if (numero.matches("01[0-9]{7}")) {
    System.out.println("Muoto on oikea.");
} else {
    System.out.println("Muoto ei ole oikea.");
}
</pre>

<p>Käydään seuraavaksi läpi eniten käytettyjä säännöllisten lausekkeiden merkintöjä.</p>

<h4>Pystyviiva eli vaihtoehtoisuus</h4>

<p>Pystyviiva tarkoittaa, että säännöllisen lausekkeen osat ovat vaihtoehtoisia. Esimerkiksi lauseke <code>00|111|0000</code> määrittelee characterStringt <code>00</code>, <code>111</code> ja <code>0000</code>. Metodi <code>matches</code> palauttaa arvon <code>true</code> jos characterString vastaa jotain määritellyistä vaihtoehdoista.</p>

<pre class="sh_java">
    String characterString = "00";
    
    if(characterString.matches("00|111|0000")) {
        System.out.println("characterStringsta löytyi joku kolmesta vaihtoehdosta");
    } else {
        System.out.println("characterStringsta ei löytynyt yhtäkään vaihtoehdoista");
    }
</pre>

<pre>
characterStringsta löytyi joku kolmesta vaihtoehdosta
</pre>

<p>Säännöllinen lauseke <code>00|111|0000</code> vaatii että characterString on täsmälleen määritellyn muotoinen: se ei määrittele <em>"contains"</em>-toiminnallisuutta.</p>

<pre class="sh_java">
    String characterString = "1111";
    
    if(characterString.matches("00|111|0000")) {
        System.out.println("characterStringsta löytyi joku kolmesta vaihtoehdosta");
    } else {
        System.out.println("characterStringsta ei löytynyt yhtäkään vaihtoehdoista");
    }
</pre>

<pre>
characterStringsta ei löytynyt yhtäkään vaihtoehdoista
</pre>

<h4>Sulut, eli characterStringn osaan rajattu vaikutusalue</h4>

<p>Sulkujen avulla voi määrittää, mihin säännöllisen lausekkeen osaan sulkujen sisällä olevat merkinnät vaikuttavat. Jos haluamme sallia characterStringt <code>00000</code> ja <code>00001</code>, voimme määritellä ne pystyviivan avulla muodossa <code>00000|00001</code>. Sulkujen avulla voimme rajoittaa vaihtoehtoisuuden vain osaan characterStringa. Lauseke <code>0000(0|1)</code> määrittelee characterStringt <code>00000</code> ja <code>00001</code>.</p>

<p>Vastaavasti säännöllinen lauseke <code>auto(|n|a)</code> määrittelee sanan auto yksikön nominatiivin (auto), genetiivin (auton), partitiivin (autoa) ja akkusatiivin (auto tai auton).</p>


<pre class="sh_java">
System.out.print("Kirjoita joku sanan auto yksikön taivutusmuoto: ");
String sana = reader.nextLine();

if (sana.matches("auto(|n|a|ssa|sta|on|lla|lta|lle|na|ksi|tta)")) {
    System.out.println("Oikein meni!");
} else {
    System.out.println("Taivutusmuoto ei ole oikea.");
}
</pre>

<h4>Toistomerkinnät</h4>

<p>Usein halutaan, että characterStringssa toistuu jokin tietty alicharacterString. Säännöllisissä lausekkeissa on käytössä seuraavat toistomerkinnät:</p>

<ul>
<li>Merkintä <strong><code>*</code></strong> toisto 0... kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "trolololololo";
    
    if(characterString.matches("trolo(lo)*")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>
</li>

<li>Merkintä <strong><code>+</code></strong> toisto 1... kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "trolololololo";
    
    if(characterString.matches("tro(lo)+")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>

<pre class="sh_java">
    String characterString = "nänänänänänänänä Bätmään!";
    
    if(characterString.matches("(nä)+ Bätmään!")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>
</li>

<li>Merkintä <strong><code>?</code></strong> toisto 0 tai 1 kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "You have to accidentally the whole meme";
    
    if(characterString.matches("You have to accidentally (delete )?the whole meme")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>
</li>

<li>Merkintä <strong><code>{a}</code></strong> toisto <code>a</code> kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "1010";
    
    if(characterString.matches("(10){2}")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>
</li>

<li>Merkintä <strong><code>{a,b}</code></strong> toisto <code>a</code> ... <code>b</code> kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "1";
    
    if(characterString.matches("1{2,4}")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto ei ole oikea.
</pre>
</li>

<li>Merkintä <strong><code>{a,}</code></strong> toisto <code>a</code> ... kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "11111";
    
    if(characterString.matches("1{2,}")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>
</li>
</ul>

<p>Samassa säännöllisessä lausekkeessa voi käyttää myös useampia toistomerkintöjä. Esimerkiksi säännöllinen lauseke <code>5{3}(1|0)*5{3}</code> määrittelee characterStringt, jotka alkavat ja loppuvat kolmella vitosella. Välissä saa tulla rajaton määrä ykkösiä ja nollia.</p>

<h4>Hakasulut, eli merkkiryhmät</h4>

<p>Merkkiryhmän avulla voi määritellä lyhyesti joukon merkkejä. Merkit kirjoitetaan hakasulkujen sisään, ja merkkivälin voi määrittää viivan avulla. Esimerkiksi merkintä <code>[145]</code> tarkoittaa samaa kuin <code>(1|4|5)</code> ja merkintä <code>[2-36-9]</code> tarkoittaa samaa kuin <code>(2|3|6|7|8|9)</code>. Vastaavasti merkintä <code>[a-c]*</code> määrittelee säännöllisen lausekkeen, joka vaatii että characterString sisältää vain merkkejä <code>a</code>, <code>b</code> ja <code>c</code>.</p>

<div class="tehtavat">

<NEXTWEEK></NEXTWEEK>

<h3>Säännölliset lausekkeet</h3>

<p>Harjoitellaan hieman säännöllisten lausekkeiden käyttöä. Tehtävät tehdään oletuspakkauksessa olevaan luokkaan <code>MainProgram</code>.</h3>

<h4 class="req">Viikonpäivä</h4>

<p>Tee säännöllisen lausekkeen avulla luokalle <code>MainProgram</code> metodi <code>public static boolean onViikonpaiva(String characterString)</code>, joka palauttaa <code>true</code> jos sen parametrina saama characterString viikonpäivän lyhenne (ma, ti, ke, to, pe, la tai su).</p>

<p>Esimerkkitulostuksia metodia käyttävästä ohjelmasta:</p>

<pre>
Anna characterString: <font color="red">ti</font>
Muoto on oikea.
</pre>

<pre>
Anna characterString: <font color="red">abc</font>
Muoto ei ole oikea.
</pre>

<h4 class="req">Vokaalitarkistus</h4>

<p>Tee luokalle <code>MainProgram</code> metodi <code>public static boolean kaikkiVokaaleja(String characterString)</code> joka tarkistaa säännöllisen lausekkeen avulla ovatko parametrina olevan characterStringn kaikki merkit vokaaleja. </p>

<p>Esimerkkitulostuksia metodia käyttävästä ohjelmasta:</p>

<pre>
Anna characterString: <font color="red">aie</font>
Muoto on oikea.
</pre>

<pre>
Anna characterString: <font color="red">ane</font>
Muoto ei ole oikea.
</pre>

<h4 class="req">Kellonaika</h4>

<p>Säännölliset lausekkeet sopivat tietynlaisiin tilanteisiin. Joissain tapaukseesa lausekkeista tulee liian monimutkaisia, ja characterStringn "sopivuus" kannattaa tarkastaa muulla tyylillä tai voi olla tarkoituksenmukaista käyttää säännöllisiä lausekkeita vain osaan tarkastuksesta.</p>

<p>Tee luokalle <code>MainProgram</code> metodi <code>public static boolean kellonaika(String characterString)</code>  ohjelma, joka tarkistaa säännöllisen lausekkeen avulla onko parametrina oleva characterString muotoa <code>tt:mm:ss</code> oleva kellonaika (tunnit, minuutit ja sekunnit kaksinumeroisina). Tässä metodissa saat käyttää säännöllisten lausekkeiden lisäksi mitä tahansa muutakin tekniikkaa.</p>

<p>Esimerkkitulostuksia metodia käyttävästä ohjelmasta:</p>

<pre>
Anna characterString: <font color="red">17:23:05</font>
Muoto on oikea.
</pre>

<pre>
Anna characterString: <font color="red">abc</font>
Muoto ei ole oikea.
</pre>

<pre>
Anna characterString: <font color="red">33:33:33</font>
Muoto ei ole oikea.
</pre>

</div>


<h3>Enum eli lueteltu tyyppi</h3>

<p>Toteutimme aiemmin pelikorttia mallintavan luokan <code>Kortti</code> suunilleen seuraavasti:</p>

<pre class="sh_java">
public class Kortti {

    public static final int RUUTU = 0;
    public static final int PATA = 1;
    public static final int RISTI = 2;
    public static final int HERTTA = 3;

    private int arvo;
    private int maa;

    public Kortti(int arvo, int maa) {
        this.arvo = arvo;
        this.maa = maa;
    }

    @Override
    public String toString() {
        return maanNimi() + " "+arvo;
    }

    private String maanNimi() {
        if (maa == 0) {
            return "RUUTU";
        } else if (maa == 1) {
            return  "PATA";
        } else if (maa == 2) {
            return "RISTI";
        }
        return "HERTTA";
    }

    public int getMaa() {
        return maa;
    }
}
</pre>

<p>Kortin maa tallennetaan kortissa olevaan oliomuuttujaan kokonaislukuna. Maan ilmaisemiseen on määritelty luettavuutta helpottavat vakiot. Kortteja ja maita ilmaisevia vakioita käytetään seuraavasti:</p>

<pre class="sh_java">
public static void main(String[] args) {
        Kortti kortti = new Kortti(10, Kortti.HERTTA);

        System.out.println(kortti);

        if (kortti.getMaa() == Kortti.PATA) {
            System.out.println("on pata");
        } else {
            System.out.println("ei ole pata");
        }

}
</pre>

<p>Maan esittäminen numerona on huono ratkaisu, sillä esimerkiksi seuraavat järjenvastaiset tavat käyttää korttia ovat mahdollisia:</p>

<pre class="sh_java">
        Kortti jarjetonKortti = new Kortti(10, 55);

        System.out.println(jarjetonKortti);

        if (jarjetonKortti.getMaa() == 34) {
            System.out.println("kortin maa on 34");
        } else {
            System.out.println("kortin maa on jotain muuta kun 34");
        }

        int maaPotenssiinKaksi = jarjetonKortti.getMaa() * jarjetonKortti.getMaa();

        System.out.println("kortin maa potenssiin kaksi on " + maaPotenssiinKaksi);
</pre>

<p>Jos tiedämme muuttujien mahdolliset arvot ennalta, voimme käyttää niiden esittämiseen <code>enum</code>-tyyppistä luokkaa eli <em>lueteltua tyyppiä</em>. Luetellut tyypit ovat oma luokkatyyppinsä rajapinnan ja normaalin luokan lisäksi. Lueteltu tyyppi määritellään avainsanalla <code>enum</code>. Esimerkiksi seuraava <code>Maa</code>-enumluokka määrittelee neljä vakioarvoa: <code>RUUTU</code>, <code>PATA</code>, <code>RISTI</code> ja <code>HERTTA</code>.</p>

<pre class="sh_java">
public enum Maa {
    RUUTU, PATA, RISTI, HERTTA
}
</pre>

<p>Yksinkertaisimmassa muodossaan <code>enum</code> luettelee pilkulla erotettuina määrittelemänsä vakioarvot. Enumien vakiot on yleensä tapana kirjoittaa kokonaan isoin kirjaimin.</p>

<p>Enum luodaan (yleensä) omaan tiedostoon, samaan tapaan kuin luokka tai rajapinta. NetBeansissa Enumin saa luotua valitsemalla projektin kohdalla <em>new/other/java/java enum</em>. </p>

<p>Seuraavassa luokka <code>Kortti</code> jossa maa esitetään enumin avulla:</p>

<pre class="sh_java">
public class Kortti {

    private int arvo;
    private Maa maa;

    public Kortti(int arvo, Maa maa) {
        this.arvo = arvo;
        this.maa = maa;
    }

    @Override
    public String toString() {
        return maa + " "+arvo;
    }

    public Maa getMaa() {
        return maa;
    }

    public int getArvo() {
        return arvo;
    }
}
</pre>

<p>Kortin uutta versiota käytetään seuraavasti:</p>

<pre class="sh_java">
public class MainProgram {

    public static void main(String[] args) {
        Kortti eka = new Kortti(10, Maa.HERTTA);

        System.out.println(eka);

        if (eka.getMaa() == Maa.PATA) {
            System.out.println("on pata");
        } else {
            System.out.println("ei ole pata");
        }

    }
}
</pre>

<p>Tulostuu:</p>

<pre>
HERTTA 10
ei ole pata
</pre>

<p>Huomaamme, että enumin tunnukset tulostuvat mukavasti! Koska kortin maat ovat nyt tyyppiä <code>Maa</code> ei ylemmän esimerkin "järjenvastaiset" kummallisuudet, esim. "maan korottaminen toiseen potenssiin" onnistu. Oraclella on <code>enum</code>-tyyppiin liittyvä sivusto osoitteessa <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html" target="_blank">http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html</a>.</p>

<h3>Iteraattori</h3>

<p>Tarkastellaan seuraavaa luokkaa <code>Kasi</code>, joka mallintaa tietyssä korttipelissä pelaajan kädessä olevien korttien joukkoa:</p>

<pre class="sh_java">
public class Kasi {
    private ArrayList&lt;Kortti&gt; kortit;

    public Kasi() {
        kortit = new ArrayList&lt;Kortti&gt;();
    }

    public void lisaa(Kortti kortti){
        kortit.add(kortti);
    }

    public void tulosta(){
        for (Kortti kortti : kortit) {
            System.out.println( kortti );
        }
    }
}
</pre>

<p>Luokan metodi <code>tulosta</code> tulostaa jokaisen kädessä olevan kortin tutuksi tullutta "for each"-lausetta käyttämällä. ArrayList ja muut <em>Collection</em>-rajapinnan toteuttavat "oliosäiliöt" toteuttavat rajapinnan <em>Iterable</em>. Rajapinnan <em>Iterable</em> toteuttavat oliot on mahdollista käydä läpi eli "iteroida" esimerkiksi. for each -tyyppisellä komennolla.</p>

<p>Oliosäiliö voidaan käydä läpi myös käyttäen ns. <em>iteraattoria</em>, eli olioa, joka on varta vasten tarkoitettu tietyn oliokokoelman läpikäyntiin. Seuraavassa on iteraattoria käyttävä versio korttien tulostamisesta:</p>

<pre class="sh_java">
public void tulosta() {
    Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

    while ( iteraattori.hasNext() ){
        System.out.println( iteraattori.next() );
    }
}
</pre>

<p>Iteraattori pyydetään kortteja sisältävältä arraylistiltä <code>kortit</code>. Iteraattori on ikäänkuin "sormi", joka osoittaa aina tiettyä listan sisällä olevaa olioa, ensin ensimmäistä ja sitten seuraavaa jne... kunnes "sormen" avulla on käyty jokainen olio läpi.</p>

<p>Iteraattori tarjoaa muutaman metodin. Metodilla <code>hasNext()</code> kysytään onko läpikäytäviä olioita vielä jäljellä. Jos on, voidaan iteraattorilta pyytää seuraavana vuorossa oleva olio metodilla <code>next()</code>. Metodi siis palauttaa seuraavana läpikäyntivuorossa olevan olion ja laittaa iteraattorin eli "sormen" osoittamaan seuraavana vuorossa olevaa läpikäytävää olioa.</p>

<p>Iteraattorin next-metodin palauttama olioviite voidaan ottaa toki talteen myös muuttujaan, eli metodi <code>tulosta</code> voitaisiin muotoilla myös seuraavasti:</p>

<pre class="sh_java">
public void tulosta(){
    Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

    while ( iteraattori.hasNext() ){
        Kortti seuraavanaVuorossa = iteraattori.next();
        System.out.println( seuraavanaVuorossa );
    }
}
</pre>

<p>Teemme metodin jonka avulla kädestä voi poistaa tiettyä arvoa pienemmät kortit:</p>

<pre class="sh_java">
public class Kasi {
    // ...

    public void poistaHuonommat(int arvo) {
        for (Kortti kortti : kortit) {
            if ( kortti.getArvo() &lt; arvo ) {
                kortit.remove(kortti);
            }
        }
    }
}
</pre>

<p>Huomaamme että metodin suoritus aiheuttaa kummallisen virheen:</p>

<pre>
Exception in thread "main" java.util.ConcurrentModificationException
        at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)
        at java.util.AbstractList$Itr.next(AbstractList.java:343)
        at Kasi.poistaHuonommat(Kasi.java:26)
        at MainProgram.main(MainProgram.java:20)
Java Result: 1
</pre>

<p>Virheen syynä on se, että for-each:illa listaa läpikäydessä ei ole sallittua poistaa listalta olioita: komento for-each menee tästä "sekaisin".</p>

<p>Jos listalta halutaan poistaa osa olioista läpikäynnin aikana osa, tulee tämä tehdä iteraattoria käyttäen. Iteraattori-olion metodia <code>remove</code> kutsuttaessa listalta poistetaan siististi se alkio jonka iteraattori palautti edellisellä metodin <code>next</code> kutsulla. Toimiva versio metodista seuraavassa:</p>

<pre class="sh_java">
public class Kasi {
    // ...

    public void poistaHuonommat(int arvo) {
        Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

        while (iteraattori.hasNext()) {
            if (iteraattori.next().getArvo() &lt; arvo) {
                // poistetaan listalta olio jonka edellinen next-metodin kutsu palautti
                iteraattori.remove();   
            }
        }
    }
}
</pre>


<div class="tehtavat">

<h3>Enum ja Iteraattori</h3>

<p>Tehdään ohjelma pienen yrityksen henkilöstön hallintaan.</p>

<h4>Koulutus</h4>

<p>Tee pakkaukseen <code>henkilosto</code> lueteltu tyyppi eli enum <code>Koulutus</code> jolla on tunnukset <code>FT</code> (tohtori), <code>FM</code> (maisteri), <code>LuK</code> (kandidaatti), <code>FilYO</code> (ylioppilas).</p>

<h4>Person</h4>

<p>Tee pakkaukseen <code>henkilosto</code> luokka Luokka <code>Person</code>. Henkilölle annetaan konstruktorin parametrina annettava nimi ja koulutus. Henkilöllä on myös koulutuksen kertova metodi <code>public Koulutus getKoulutus()</code> sekä alla olevan esimerkin mukaista jälkeä tekevä <code>toString</code>-metodi.</p>

<pre class="sh_java">
    Person arto = new Person("Arto", Koulutus.FT);
    System.out.println(arto);
</pre>

<pre>
Arto, FT
</pre>


<h4>Tyontekijat</h4>

<p>Tee pakkaukseen <code>henkilosto</code> luokka Luokka <code>Tyontekijat</code>. Työntekijät-olio sisältää listan Person-olioita. Luokalla on parametriton konstruktori ja seuraavat metodit:</p>

<ul>
  <li><code>public void lisaa(Person lisattava)</code> lisää parametrina olevan henkilön työntekijäksi</li>
  <li><code>public void lisaa(List&lt;Person&gt; lisattavat)</code> lisää parametrina olevan listan henkilöitä työntekijöiksi</li>
  <li><code>public void tulosta()</code> tulostaa kaikki työntekijät</li>
  <li><code>public void tulosta(Koulutus koulutus)</code> tulostaa työntekijät joiden koulutus on sama kuin parametrissa määritelty koulutus</li>
</ul>

<p><strong>HUOM:</strong> Luokan <code>Tyontekijat</code> <code>tulosta</code>-metodit on toteutettava iteraattoria käyttäen!</p>

<h4>Irtisanominen</h4>

<p>Tee luokalle  <code>Tyontekijat</code> metodi <code>public void irtisano(Koulutus koulutus)</code> joka poistaa Työntekijöiden joukosta kaikki henkilöt joiden koulutus on sama kuin metodin parametrina annettu.</p>

<p><strong>HUOM:</strong> toteuta metodi iteraattoria käyttäen!</p>

<p>Seuraavassa esimerkki luokan käytöstä:</p>

<pre class="sh_java">
Public class MainProgram {

    public static void main(String[] args) {
        Tyontekijat yliopisto = new Tyontekijat();
        yliopisto.lisaa(new Person("Matti", Koulutus.FT));
        yliopisto.lisaa(new Person("Pekka", Koulutus.FilYO));
        yliopisto.lisaa(new Person("Arto", Koulutus.FT));

        yliopisto.tulosta();

        yliopisto.irtisano(Koulutus.FilYO);

        System.out.println("==");

        yliopisto.tulosta();
}
</pre>

<p>Tulostuu:</p>

<pre>
Matti, FT
Pekka, FilYO
Arto, FT
==
Matti, FT
Arto, FT
</pre>

</div>

<h3>Toistolauseet ja continue</h3>

<p>Toistolauseissa on komennon <code>break</code> lisäksi käytössä komento <code>continue</code>, joka mahdollistaa seuraavaan toistokierrokseen hyppäämisen.</p>

<pre class="sh_java">
    List&lt;String&gt; nimet = Arrays.asList("Matti", "Pekka", "Arto");
    
    for(String name: nimet) {
        if (nimi.equals("Arto")) {
            continue;
        }

        System.out.println(nimi);
    }
</pre>

<pre>
Matti
Pekka
</pre>

<p>Komentoa <code>continue</code> käytetään esimerkiksi silloin, kun tiedetään että toistolauseessa iteroitavilla muuttujilla on arvoja, joita ei haluta käsitellä lainkaan. Klassinen lähestymistapa olisi if-lauseen käyttö, mutta komento <code>continue</code> mahdollistaa sisennyksiä välttävän, ja samalla ehkä luettavamman lähestymistavan käsiteltävien arvojen välttämiseen. Alla on kaksi esimerkkiä, jossa käydään listalla olevia lukuja läpi. Jos luku on alle 5, se on jaollinen sadalla, tai se on jaollinen neljälläkymmenellä, niin sitä ei tulosteta, muulloin se tulostetaan. </p>

<pre class="sh_java">
    List&lt;Integer&gt; values = Arrays.asList(1, 3, 11, 6, 120);
    
    for(int luku: values) {
        if (luku > 4 && luku % 100 != 0 && luku % 40 != 0) {
            System.out.println(luku);
        }
    }

    for(int luku: values) {
        if (luku &lt; 5) {
            continue;
        }

        if (luku % 100 == 0) {
            continue;
        }

        if (luku % 40 == 0) {
            continue;
        }
        
        System.out.println(luku);
    }
</pre>

<pre>
11
6
11
6
</pre>

<h3>Lisää enumeista</h3>

<p>Luodaan seuraavaksi lueteltuja tyyppejä jotka sisältävät oliomuuttujia ja toteuttavat rajapinnan.</p>

<h4>Luetellun tyypin konstruktorin parametrit</h4>

<p>Luetellut tyypit voivat sisältää oliomuuttujia. Oliomuuttujien arvot tulee asettaa luetellun tyypin määrittelevän luokan sisäisessä konstruktorissa. Enum-tyyppisillä luokilla ei saa olla <code>public</code>-konstruktoria.</p>

<pre class="sh_java">
public enum Vari {
    PUNAINEN("punainen"), // konstruktorin parametrit määritellään vakioarvoja lueteltaessa
    VIHREA("vihreä"),
    SININEN("sininen");

    private String name; // oliomuuttuja

    private Vari(String name) { // konstruktori
        this.name = nimi;
    }

    public String getName() {
        return this.name;
    }
}  
</pre>

<p>Lueteltua tyyppiä <code>Vari</code> voidaan käyttää esimerkiksi seuraavasti:</p>
<pre class="sh_java">
    System.out.println(Vari.VIHREA.getName());
</pre>

<pre>
vihreä
</pre>


<div class="tehtavat">

<h3>Elokuvien suosittelija</h3>

<p>Hiljattain Suomeen rantautunut <a href="https://signup.netflix.com/" target="_blank">Netflix</a> lupasi lokakuussa 2006 miljoona dollaria henkilölle tai ryhmälle, joka kehittäisi ohjelman, joka on 10% parempi elokuvien suosittelussa kuin heidän oma ohjelmansa. Kilpailu ratkesi syyskuussa 2009 (<a href="http://www.netflixprize.com/" target="_blank">http://www.netflixprize.com/</a>).</p>

<p>Rakennetaan tässä tehtävässä ohjelma elokuvien suositteluun. Alla on sen toimintaesimerkki:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");
    Person thomas = new Person("Thomas");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.HUONO);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);
    

    Suosittelija suosittelija = new Suosittelija(arviot);
    System.out.println(thomas + " suositus: " + 
            suosittelija.suositteleElokuva(thomas));
    System.out.println(mikke + " suositus: " + 
            suosittelija.suositteleElokuva(mikke));
</pre>

<pre>
Thomas suositus: Hiljaiset sillat
Mikke suositus: Tuulen viemää
</pre>

<p>Ohjelma osaa suositella elokuvia niiden yleisen arvion perusteella, sekä henkilökohtaisten henkilön antaminen arvioiden perusteella. Lähdetään rakentamaan ohjelmaa.</p>

<h4>Person ja Elokuva</h4>

<p>Luo pakkaus <code>suosittelija.domain</code> ja lisää sinne luokat <code>Person</code> ja <code>Elokuva</code>. Kummallakin luokalla on julkinen konstruktori <code>public <em>Luokka</em>(String name)</code>, sekä metodi <code>public String getName()</code>, joka palauttaa konstruktorissa saadun nimen.</p>

<pre class="sh_java">
    Person henkilo = new Person("Pekka");
    Elokuva elokuva = new Elokuva("Eraserhead");

    System.out.println(henkilo.getName() + " ja " + elokuva.getName());
</pre>

<pre>
Pekka ja Eraserhead
</pre>

<p>Lisää luokille myös <code>public String toString()</code>-metodi, joka palauttaa konstruktorissa parametrina annetun nimen, sekä korvaa metodit <code>equals</code> ja <code>hashCode</code>.</p>

<p>
Korvaa <code>equals</code> siten että samuusvertailu tapahtuu oliomuuttujan <code>nimi</code> perusteella. Katso mallia luvusta 45.1. Luvussa 45.2. on ohje metodin <code>hashCode</code> korvaamiselle. Ainakin HashCode kannattaa generoida automaattisesti luvun lopussa olevan ohjeen mukaan:</p> 

<p>
<em>
NetBeans tarjoaa metodien equals ja hashCode automaattisen luonnin. Voit valita valikosta Source -> Insert Code, ja valita aukeavasta listasta equals() and hashCode(). Tämän jälkeen NetBeans kysyy oliomuuttujat joita metodeissa käytetään.</em>
</p>

<p><strong>Huom:</strong> virheiden etsimisen helpottamiseksi kannattaa ehkä toteuttaa henkilölle ja elokuvalle toString-metodit. Testit eivät niitä vaadi.</p>

<h4>Arvio</h4>

<p>Luo pakkaukseen <code>suosittelija.domain</code> lueteltu tyyppi <code>Arvio</code>. Enum-luokalla <code>Arvio</code> on julkinen metodi <code>public int getArvo()</code>, joka palauttaa arvioon liittyvän arvon. Arviotunnusten ja niihin liittyvien arvosanojen tulee olla seuraavat:</p>

<p>
<table style="padding-left:2em">
  <tr><th>Tunnus</th><th>Arvo</th></tr>
  <tr><td>HUONO</td><td>-5</td></tr>
  <tr><td>VALTTAVA</td><td>-3</td></tr>
  <tr><td>EI_NAHNYT</td><td>0</td></tr>
  <tr><td>NEUTRAALI</td><td>1</td></tr>
  <tr><td>OK</td><td>3</td></tr>
  <tr><td>HYVA</td><td>5</td></tr>
</table>
</p>

<p>Luokkaa voi käyttää seuraavasti:</p>
<pre class="sh_java">
    Arvio annettu = Arvio.HYVA;
    System.out.println("Arvio " + annettu + ", arvo " + annettu.getArvo());
    annettu = Arvio.NEUTRAALI;
    System.out.println("Arvio " + annettu + ", arvo " + annettu.getArvo());
</pre>

<pre>
Arvio HYVA, arvo 5
Arvio NEUTRAALI, arvo 1
</pre>

<h4>ArvioRekisteri, osa 1</h4>

<p>Aloitetaan arvioiden varastointiin liittyvän palvelun toteutus.</p>

<p>Luo pakkaukseen <code>suosittelija</code> luokka <code>ArvioRekisteri</code>, jolla on konstruktori <code>public ArvioRekisteri()</code> sekä seuraavat metodit:</p>

<ul>
  <li><code>public void lisaaArvio(Elokuva elokuva, Arvio arvio)</code> lisää arviorekisteriin parametrina annetulle elokuvalle uuden arvion. Samalla elokuvalla voi olla useita samanlaisiakin arvioita.</li>
  <li><code>public List&lt;Arvio&gt; annaArviot(Elokuva elokuva)</code> palauttaa elokuvalle lisätyt arviot listana.</li>
  <li><code>public Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot()</code> palauttaa mapin, joka sisältää arvioidut elokuvat avaimina. Jokaiseen elokuvaan liittyy lista, joka sisältää elokuvaan lisatyt arviot.</li>
</ul>

<p>Testaa metodien toimintaa seuraavalla lähdekoodilla:</p>

<pre class="sh_java">
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    ArvioRekisteri rekisteri = new ArvioRekisteri();
    rekisteri.lisaaArvio(eraserhead, Arvio.HUONO);
    rekisteri.lisaaArvio(eraserhead, Arvio.HUONO);
    rekisteri.lisaaArvio(eraserhead, Arvio.HYVA);

    rekisteri.lisaaArvio(hiljaisetSillat, Arvio.HYVA);
    rekisteri.lisaaArvio(hiljaisetSillat, Arvio.OK);

    System.out.println("Kaikki arviot: " + rekisteri.elokuvienArviot());
    System.out.println("Arviot Eraserheadille: " + rekisteri.annaArviot(eraserhead));
</pre>

<pre>
Kaikki arviot: {Hiljaiset sillat=[HYVA, OK], Eraserhead=[HUONO, HUONO, HYVA]}
Arviot Eraserheadille: [HUONO, HUONO, HYVA]
</pre>


<h4>ArvioRekisteri, osa 2</h4>

<p>Lisätään seuraavaksi mahdollisuus henkilökohtaisten arvioiden lisääiseen.</p>

<p>Lisää luokkaan <code>ArvioRekisteri</code> seuraavat metodit:</p>

<ul>
  <li><code>public void lisaaArvio(Person henkilo, Elokuva elokuva, Arvio arvio)</code> lisää parametrina annetulle elokuvalle tietyn henkilön tekemän arvion. Sama henkilö voi arvioida tietyn elokuvan vain kertaalleen. Henkilön tekemä arvio tulee myös lisätä kaikkiin elokuviin liittyviin arvioihin.</li>
  <li><code>public Arvio haeArvio(Person henkilo, Elokuva elokuva)</code> palauttaa parametrina annetun henkilön tekemän arvion parametrina annetulle elokuvalle. Jos henkilö ei ole arvioinut kyseistä elokuvaa, palauta arvio <code>Arvio.EI_NAHNYT</code>.</li>
 <li><code>public Map&lt;Elokuva, Arvio&gt; annaPersonnArviot(Person henkilo)</code> palauttaa hajautustaulun, joka sisältää henkilön tekemät arviot. Hajautustaulun avaimena on arvioidut elokuvat, arvoina arvioituihin elokuviin liittyvät arviot.</li> 
 <li><code>public List&lt;Person&gt; arvioijat()</code> palauttaa listan henkilöistä jotka ovat arvioineet elokuvia.</li></ul>

<p>Henkilöiden tekemät arviot kannattanee tallentaa hajautustauluun, jossa avaimena on henkilö. Arvona hajautustaulussa on toinen hajautustaulu, jossa avaimena on elokuva ja arvona arvio.</p>

<p>Testaa paranneltua <code>ArvioRekisteri</code>-luokkaa seuraavalla lähdekoodipätkällä:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.OK);

    System.out.println("Arviot Eraserheadille: " + arviot.annaArviot(eraserhead));
    System.out.println("Matin arviot: " + arviot.annaPersonnArviot(matti));
    System.out.println("Arvioijat: " + arviot.arvioijat());
</pre>

<pre>
Arviot Eraserheadille: [OK, OK]
Matin arviot: {Tuulen viemää=HUONO, Eraserhead=OK}
Arvioijat: [Pekka, Matti]
</pre>

<p>Luodaan seuraavaksi muutama apuluokka arviointien helpottamiseksi.</p>

<h4>PersonComparator</h4>

<p>Luo pakkaukseen <code>suosittelija.comparator</code> luokka <code>PersonComparator</code>. Luokan <code>PersonComparator</code> tulee toteuttaa rajapinta <code>Comparator&lt;Person&gt;</code>, ja sillä pitää olla konstruktori <code>public PersonComparator(Map&lt;Person, Integer&gt; henkiloidenSamuudet)</code>. Luokkaa <code>PersonComparator</code> käytetään myöhemmin henkilöiden järjestämiseen henkilöön liittyvän luvun perusteella.</p>

<p>PersonComparator-luokan tulee mahdollistaa henkilöiden järjestäminen henkilöön liittyvän luvun perusteella.</p>

<p>Testaa luokan toimintaa seuraavalla lähdekoodilla:</p>

<pre class="sh_java">
    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");
    Person thomas = new Person("Thomas");

    Map&lt;Person, Integer&gt; henkiloidenSamuudet = new HashMap&lt;Person, Integer&gt;();
    henkiloidenSamuudet.put(matti, 42);
    henkiloidenSamuudet.put(pekka, 134);
    henkiloidenSamuudet.put(mikke, 8);
    henkiloidenSamuudet.put(thomas, 82);
    
    List&lt;Person&gt; henkilot = Arrays.asList(matti, pekka, mikke, thomas);
    System.out.println("Henkilöt ennen järjestämistä: " + henkilot);

    Collections.sort(henkilot, new PersonComparator(henkiloidenSamuudet));
    System.out.println("Henkilöt järjestämisen jälkeen: " + henkilot);
</pre>

<pre>
Henkilöt ennen järjestämistä: [Matti, Pekka, Mikke, Thomas]
Henkilöt järjestämisen jälkeen: [Pekka, Thomas, Matti, Mikke]
</pre>

<h4>ElokuvaComparator</h4>


<p>Luo pakkaukseen <code>suosittelija.comparator</code> luokka <code>ElokuvaComparator</code>. Luokan <code>ElokuvaComparator</code> tulee toteuttaa rajapinta <code>Comparator&lt;Elokuva&gt;</code>, ja sillä pitää olla konstruktori <code>public ElokuvaComparator(Map&lt;Elokuva, List&lt;Arvio&gt;&gt; arviot)</code>. Luokkaa <code>ElokuvaComparator</code> käytetään myöhemmin elokuvien järjestämiseen niiden arvioiden perusteella.</p>

<p>ElokuvaComparator-luokan tulee tarjota mahdollisuus elokuvien järjestäminen niiden saamien arvosanojen keskiarvon perusteella. Korkeimman keskiarvon saanut elokuva tulee ensimmäisenä, matalimman keskiarvon saanut viimeisenä.</p>

<p>Testaa luokan toimintaa seuraavalla lähdekoodilla:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.HUONO);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);

    Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot = arviot.elokuvienArviot();

    List&lt;Elokuva&gt; elokuvat = Arrays.asList(tuulenViemaa, hiljaisetSillat, eraserhead);
    System.out.println("Elokuvat ennen järjestämistä: " + elokuvat);

    Collections.sort(elokuvat, new ElokuvaComparator(elokuvienArviot));
    System.out.println("Elokuvat järjestämisen jälkeen: " + elokuvat);
</pre>

<pre>
Elokuvat ennen järjestämistä: [Tuulen viemää, Hiljaiset sillat, Eraserhead]
Elokuvat järjestämisen jälkeen: [Hiljaiset sillat, Tuulen viemää, Eraserhead]
</pre>


<h4>Suosittelija, osa 1</h4>

<p>Toteuta pakkaukseen <code>suosittelija</code> luokka <code>Suosittelija</code>. Luokan <code>Suosittelija</code> konstruktori saa parametrinaan <code>ArvioRekisteri</code>-tyyppisen olion. Suosittelija käyttää arviorekisterissä olevia arvioita suositusten tekemiseen.</p>

<p>Toteuta luokalle metodi <code>public Elokuva suositteleElokuva(Person henkilo)</code>, joka suosittelee henkilölle elokuvia.

Toteuta metodi ensin siten, että se suosittelee aina elokuvaa, jonka arvioiden arvosanojen keskiarvo on suurin. Vinkki: Tarvitset parhaan elokuvan selvittämiseen ainakin aiemmin luotua <code>ElokuvaComparator</code>-luokkaa, luokan <code>ArvioRekisteri</code> metodia <code>public Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot()</code>, sekä listaa olemassaolevista elokuvista.</p>

<p>Testaa ohjelman toimimista seuraavalla lähdekoodilla:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikael");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.VALTTAVA);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    Suosittelija suosittelija = new Suosittelija(arviot);
    Elokuva suositeltu = suosittelija.suositteleElokuva(mikke);
    System.out.println("Mikaelille suositeltu elokuva oli: " + suositeltu); 
</pre>

<pre>
Mikaelille suositeltu elokuva oli: Hiljaiset sillat
</pre>

<p>Nyt tekemämme ensimmäinen vaihe toimii oikein ainoastaan henkilöille, jotka eivät ole vielä arvostelleet yhtään elokuvaa. Heidän elokuvamaustaanhan on mahdoton sanoa mitään ja paras arvaus on suositella heille keskimäärin parhaan arvosanan saanutta elokuvaa. </p>

<h4>Suosittelija, osa 2</h4>

<p><em>Huom! Tehtävä on haastava. Kannattaa tehdä ensin muut tehtävät ja palata tähän myöhemmin. Voit palauttaa tehtäväsarjan TMC:hen vaikket saakaan tätä tehtävää tehdyksi, aivan kuten muidenkin tehtävien kohdalla.</em></p>

<p>Valitettavasti tämän osan virhediagnostiikkakaan ei ole samaa luokkaa kuin edellisissä kohdissa.</p>

<p>Jos henkilöt ovat lisänneet omia suosituksia suosituspalveluun, tiedämme jotain heidän elokuvamaustaan. Laajennetaan suosittelijan toiminnallisuutta siten, että se luo henkilökohtaisen suosituksen jos henkilö on jo arvioinut elokuvia. Edellisessä osassa toteutettu toiminnallisuus tulee säilyttää: Jos henkilö ei ole arvioinut yhtäkään elokuvaa, hänelle suositellaan elokuva arvosanojen perusteella.</p>

<p>Henkilökohtaiset suositukset perustuvat henkilön tekemien arvioiden samuuteen muiden henkilöiden tekemien arvioiden kanssa. Pohditaan seuraavaa taulukkoa, missä ylärivillä on elokuvat, ja vasemmalla on arvioita tehneet henkilöt. Taulukon solut kuvaavat annettuja arvioita.</p>

<p>
    <table style="padding-left:2em">
      <tr><th>Person \ Elokuva</th><td>Tuulen viemää</td><td>Hiljaiset sillat</td><td>Eraserhead</td><td>Blues Brothers</td></tr>
      <tr><td>Matti</td><td>HUONO (-5)</td><td>HYVA (5)</td><td>OK (3)</td><td>-</td></tr>
      <tr><td>Pekka</td><td>OK (3)</td><td>-</td><td>HUONO (-5)</td><td>VALTTAVA (-3)</td></tr>
      <tr><td>Mikael</td><td>-</td><td>-</td><td>HUONO (-5)</td><td>-</td></tr>
      <tr><td>Thomas</td><td>-</td><td>HYVA (5)</td><td>-</td><td>HYVA (5)</td></tr>
    </table>
</p>

<p>Kun haluamme hakea Mikaelille sopivaa elokuvaa, tutkimme Mikaelin samuutta kaikkien muiden arvioijien kesken. Samuus lasketaan arvioiden perusteella: samuus on kummankin katsomien elokuvien arvioiden tulojen summa. Esimerkiksi Mikaelin ja Thomasin samuus on 0, koska Mikael ja Thomas eivät ole katsoneet yhtäkään samaa elokuvaa.</p>

<p>Mikaelin ja Pekan samuutta laskettaessa yhteisten elokuvien tulojen summa olisi 25. Mikael ja Pekka ovat katsoneet vain yhden yhteisen elokuvan, ja kumpikin antaneet sille arvosanan huono (-5).</p>

<pre>
-5 * -5 = 25
</pre>

<p>Mikaelin ja Matin samuus on -15. Mikael ja Matti ovat myös katsoneet vain yhden yhteisen elokuvan. Mikael antoi elokuvalle arvosanan huono (-5), Matti antoi sille arvosanan ok (3).</p>

<pre>
-5 * 3 = -15
</pre>

<p>Näiden perusteella Mikaelille suositellaan elokuvia Pekan elokuvamaun mukaan: suosituksena on elokuva Tuulen viemää.</p>


<p>Kun taas haluamme hakea Matille sopivaa elokuvaa, tutkimme Matin samuutta kaikkien muiden arvioijien kesken. Matti ja Pekka ovat katsoneet kaksi yhteistä elokuvaa. Matti antoi Tuulen viemälle arvosanan huono (-5), Pekka arvosanan OK (3). Elokuvalle Eraserhead Matti antoi arvosanan OK (3), Pekka arvosanan huono (-5). Matin ja Pekan samuus on siis -30.</p>

<pre>
-5 * 3 + 3 * -5 = -30
</pre>

<p>Matin ja Mikaelin samuus on edellisestä laskusta tiedetty -15. Samuudet ovat symmetrisia.</p>

<p>Matti ja Thomas ovat katsoneet Tuulen viemää, ja kumpikin antoi sille arvosanan hyvä (5). Matin ja Thomaksen samuus on siis 25.</p>

<pre>
5 * 5 = 25
</pre>

<p>Matille tulee siis suositella elokuvia Thomaksen elokuvamaun mukaan: suosituksena olisi Blues Brothers.</p>

<p>Toteuta yllä kuvattu suosittelumekanismi. Jos henkilölle ei löydy yhtään suositeltavaa elokuvaa, tai henkilö, kenen elokuvamaun mukaan elokuvia suositellaan on arvioinut elokuvat joita henkilö ei ole vielä katsonut huonoiksi, välttäviksi tai neutraaleiksi, palauta metodista <code>suositteleElokuva</code> arvo <code>null</code>. Edellisessä tehtävässä määritellyn lähestymistavan tulee toimia jos henkilö ei ole lisännyt yhtäkään arviota.</p>

<p>Älä suosittele elokuvia, jonka henkilö on jo nähnyt.</p>

<p>Voit testata ohjelmasi toimintaa seuraavalla lähdekoodilla:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");
    Elokuva bluesBrothers = new Elokuva("Blues Brothers");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikael");
    Person thomas = new Person("Thomas");
    Person arto = new Person("Arto");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.HUONO);
    arviot.lisaaArvio(pekka, bluesBrothers, Arvio.VALTTAVA);
    
    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);
    
    arviot.lisaaArvio(thomas, bluesBrothers, Arvio.HYVA);
    arviot.lisaaArvio(thomas, hiljaisetSillat, Arvio.HYVA);

    Suosittelija suosittelija = new Suosittelija(arviot);
    System.out.println(thomas + " suositus: " + suosittelija.suositteleElokuva(thomas));
    System.out.println(mikke + " suositus: " + suosittelija.suositteleElokuva(mikke));
    System.out.println(matti + " suositus: " + suosittelija.suositteleElokuva(matti));
    System.out.println(arto + " suositus: " + suosittelija.suositteleElokuva(arto));
</pre>

<pre>
Thomas suositus: Eraserhead
Mikael suositus: Tuulen viemää
Matti suositus: Blues Brothers
Arto suositus: Hiljaiset sillat
</pre>

<p>Miljoona käsissä? Ei ehkä vielä. Kursseilla Johdatus tekoälyyn ja Johdatus koneoppimiseen opitaan lisää tekniikoita oppivien järjestelmien rakentamiseen.</p>

</div>

<h3>Vaihteleva määrä parametreja metodille</h3>

<p>Olemme tähän mennessä luoneet metodimme siten, että niiden parametrien määrät ovat olleet selkeästi määritelty. Java tarjoaa tavan antaa metodille rajoittamattoman määrän määrätyntyyppisiä parametreja asettamalla metodimäärittelyssä parametrin tyypille kolme pistettä perään. Esimerkiksi metodille <code>public int sum(int... values)</code> voi antaa summattavaksi niin monta <code>int</code>-tyyppistä kokonaislukua kuin käyttäjä haluaa. Metodin sisällä parametrin arvoja voi käsitellä taulukkona.</p>

<pre class="sh_java">
    public int sum(int... values) {
        int sum = 0;
        for (int i = 0; i < values.length; i++) {
            summa += values[i];
        }
        return summa;
    }
</pre>

<pre class="sh_java">
    System.out.println(summa(3, 5, 7, 9));  // values = {3, 5, 7, 9}
    System.out.println(summa(1, 2));        // values = {1, 2}
</pre>

<pre>
24
3
</pre>

<p>Huomaa yllä miten parametrimäärittely <code>int... values</code> johtaa siihen, että metodin sisällä näkyy taulukkotyyppinen muuttuja <code>values</code>.</p>

<p>Metodille voi määritellä vain yhden parametrin joka saa rajattoman määrän arvoja, ja sen tulee olla metodimäärittelyn viimeinen parametri. Esimerkiksi:</p>

<pre class="sh_java">
    public void tulosta(String... characterStringt, int times) // ei sallittu!
    public void tulosta(int times, String... characterStringt) // sallittu!
</pre>

<p>Ennalta määrittelemätöntä parametrien arvojen määrää käytetään esimerkiksi silloin, kun halutaan tarjota rajapinta, joka ei rajoita sen käyttäjää tiettyyn parametrien määrään. Vaihtoehtoinen lähestymistapa on metodimäärittely, jolla on parametrina tietyn tyyppinen lista. Tällöin oliot voidaan asettaa listaan ennen metodikutsua, ja kutsua metodia antamalla lista sille parametrina.</p>

<div class="tehtavat">

<h3>JoustavatHakuehdot</h3>

<p>Muutamassa tehtävässä (mm. ohpen kirjasto ja ohjan sanatutkimus) törmäsimme tilanteeseen jossa houduimme filtteröimään listasta olioita jotain hakuehtoa vastaavat oliot, esim. sanatutkimuksessa metodit <code>zSisaltava, lLoppuiset, palindromit, kaikkiVoksSis</code> tekivät oleellisesti saman asian: kävivät läpi tiedoston sisällön sana kerrallaan ja tarkastivat jokaisen sanan kohdalla päteekö sille tietty ehto ja jos pätee, ottivat sanan talteen. Koska kaikkien metodien ehto oli erilainen, ei toisteisuutta tehtävissä osattu poistaa vaan kaikkien koodi oli ehtoa vaille "copypastea". </p>

<p>Tässä tehtävässä teemme ohjelman, jonka avulla on mahdollista fitlteröidä rivejä <a href="">Project Guttenbergin</a> sivuilta löytyvistä kirjoista. Seuraavassa esimerkkinä Dostojevskin Rikos ja rangaistus. Haluamme, että erilaisia filtteröintiehtoja on monelaisia ja että filtteröinti voi tapahtua myös eri ehtojen kombinaationa. Ohjelman rakenteen pitää myös mahdollistaa uusien ehtojen lisääminen myöhemmin.</p>

<p>Sopiva ratkaisu tilanteeseen filtteröintiehtojen määritteleminen omina rajapinnan <code>Ehto</code>toteuttavina olioina. Seuraavassa rajapinnan määritelmä:</p>

<pre class="sh_java">
public interface Ehto {
    boolean toteutuu(String rivi);
}
</pre>

<p>Seuraavassa eräs rajapinnan toteuttava filtteriluokka:</p>

<pre class="sh_java">
public class SisaltaaSanan implements Ehto {

    String sana;

    public SisaltaaSanan(String sana) {
        this.sana = sana;
    }

    @Override
    public boolean toteutuu(String rivi) {
        return rivi.contains(sana);
    }    
}
</pre>

<p>Luokan oliot ovat siis hyvin yksinkertaisia, ne muistavat konstruktorin parametrina annetun sanan. Olion ainoalta metodilta voi kysyä toteutuuko ehto parametrina olevalle characterStringlle, ja ehdon toteutuminen tarkoittaa olion tapauksessa sisältääkö characterString olion mustaman sanan.</p>

<p>Tehtäväpohjan mukana saat valmiina luokan <code>GutenbergLukija</code> jonka avulla voit tutkia kirjojen rivejä filtteröitynä parametrina annetun hakuehdon perusteella:</p>

<pre class="sh_java">
public class GutenbergLukija {

    private List&lg;String&gt; sanat;

    public GutenbergLukija(String osoite) throws IllegalArgumentException {
        // kirjan verkosta hakeva koodi
    }
    
    public List&lg;String&gt; rivitJoilleVoimassa(Ehto ehto){
        List&lg;String&gt; ehdonTayttavat = new ArrayList&lg;String&gt;();
        
        for (String rivi : sanat) {
            if ( ehto.toteutuu(rivi)) {
                ehdonTayttavat.add(rivi);
            }
        }
        
        return ehdonTayttavat;
    }
}
</pre>

<p>Seuraavassa tulostetaan Rikoksesta ja rangaistuksesta kaikki rivit joilla esiintyy sana "beer":</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new SisaltaaSanan("beer");
        
    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>Kaikki sanat</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>KaikkiRivit</code> joka kelpuuttaa jokaisen rivin.</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new KaikkiRivit();
        
    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>Loppuu huuto- tai kysymysmerkkiin</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>LoppuuHuutoTaiKysymysmerkkiin</code> joka kelpuuttaa ne rivit, joiden viimeinen merkki on huuto- tai kysymysmerkki.</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new LoppuuHuutoTaiKysymysmerkkiin();
        
    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<p><strong>Muistutus:</strong> merkkien vertailu Javassa tapahtuu == operaattorilla:</p>

<pre class="sh_java">
String name = "pekka";

// HUOM: 'p' on merkki eli char p, "p" taas merkkojono jonka ainoa merkki on p
if ( nimi.charAt(0) == 'p' ) {
    System.out.println("alussa p");
} else {
    System.out.println("alussa jokin muu kuin p");
}
</pre>

<h4>Pituus vähintää</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>PituusVahintaan</code> joka oliot kelpuuttavat ne rivit, joiden pituus on vähintään olion konstruktorin parametrina annettu luku.</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new PituusVahintaan(40);
        
    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>molemmat</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>Molemmat</code>. Luokan oliot saavat konstruktorin parametrina kaksi rajapinnan <code>Ehto</code> toteuttavaa olioa. Molemmat-olio kelpuuttavat ne rivit, jotka sen molemmat konstruktorissa saamat ehdot kelpuuttavat.
Seuraavassa tulostetaan kaikki huuto- tai kysymysmerkkiin loppuvat rivit jotka sisältävät sanan "beer".
</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new Molemmat(
                    new LoppuuHuutoTaiKysymysmerkkiin(),
                    new SisaltaaSanan("beer")
                );

    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>negaatio</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>Ei</code>. Luokan oliot saav parametrina rajapinna <code>Ehto</code> toteuttavaavan olioan. Ei-olio kelpuuttavat ne rivit, joita sen parametrina saama ehto ei kelpuuta.
Seuraavassa tulostetaan rivit, joiden pituus vähemmän kuin 10.
</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new Ei( new PituusVahintaan(10) );
      
    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>vähintään yksi</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>VahintaanYksi</code>. Luokan oliot saavat konstruktorin parametrina mielivaltaisen määtän rajapinnan <code>Ehto</code> toteuttavaa olioa, konstruktorissa siis käytetävä vaihtuvanmittaista parametrilistaa. VahintaanYksi-olio kelpuuttavat ne rivit, jotka vähintään yksi sen konstruktoriparametrina saamista ehdoista kelpuuttaa. Seuraavassa tulostetaan rivit jotka sisältävät sanan jonkun sanoista "beer", "milk" tai "oil".
</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new VahintaanYksi(
                    new SisaltaaSanan("beer"),
                    new SisaltaaSanan("milk"),
                    new SisaltaaSanan("oil")
                );

    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<p>Huomaa, että ehtoja voi kombinoida mielivaltaisesti. Seuraavassa ehto, joka hyväksyy rivit joilla on vähintään yksi sanoista "beer", "milk" tai "oil" ja jotka ovat pituudeltaan 20-30 merkkiä.</p>

<pre class="sh_java">
    Ehto sanat = new VahintaanYksi(
                    new SisaltaaSanan("beer"),
                    new SisaltaaSanan("milk"),
                    new SisaltaaSanan("oil")
                );

    Ehto oikeaPituus = new Molemmat(
                         new PituusVahintaan(20),
                         new Ei( new PituusVahintaan(31)),
                       );

    Ehto halutut = new Molemmat(sanat, oikeaPituus);
</pre>

</div>

<h3>StringBuilder</h3>

<p>Olemme tottuneet rakentamaan characterStringja seuraavaan tapaan:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        int[] t = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        System.out.println(muotoile(t));
    }

    public static String muotoile(int[] t) {
        String mj = "{";

        for (int i = 0; i &lt; t.length; i++) {
            mj += t[i];
            if (i != t.length - 1) {
                mj += ", ";
        
            }
        }

        return mj + "}";
    }
</pre>

<p>Tulostus:</p>

<pre>
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
</pre>

<p>Tapa on toimiva mutta ei kovin tehokas. Kuten muistamme, characterStringt ovat <em>immutabeleja</em> eli olioita joita ei voi muuttaa. characterString-operaatioiden tuloksena onkin aina uusi characterString-olio. Eli edellisessäkin esimerkissä syntyi välivaiheena 10 characterString-olioa. Jos syötteen koko olisi isompi, alkaisi välivaiheena olevien olioiden luominen vaikuttaa ohjelman suoritusaikaan ikävällä tavalla.</p>

<div class="tehtavat">
<h3>String builder</h3>

<p>Edellisen kaltaisissa tilanteissa onkin paremi käyttää characterStringn muodostamisessa <code>StringBuilder</code>-olioita. Toisin kuin Stringint, StringBuilderit eivät ole immutabeleja, ja yhtä StringBuilderolioa voi muokata. Tutustu StringBuilderin API-kuvaukseen (löydät sen esim googlaamalla stringbuilder java api 6) ja muuta tehtäväpohjassa oleva metodi <code>public static String muotoile(int[] t)</code> toimimaan StringBuilderia käyttäen seuraavaan tapaan:</p>

<pre>
{
 1, 2, 3, 4, 
 5, 6, 7, 8, 
 9, 10
}
</pre>

<p>Eli aaltosulkeet tulevat omalle rivilleen. Taulukon alkioita tulostetaan 4 per rivi ja rivin ensimmäistä edeltää välilyönti. Pilkun jälkeen ennen seuraavaa numeroa tulee olla tasan yksi välilyönti.</p>

</div>

<h2>Loppuhuipennus</h2>

<p>Kurssi alkaa olla ohi ja on loppuhuipennuksen aika!</p>

<div class="tehtavat">

<h3>Matopeli</h3>


<p>Tässä tehtävässä luodaan rakenteet ja osa toiminnallisuudesta seuraavannäköiseen matopeliin.</p>

    <p><img src="img-ohja/kali/170-matopeli.png"/></p>

<h4>Pala ja Omena</h4>

<p>Luo pakkaukseen <code>matopeli.domain</code> luokka <code>Pala</code>. Luokalla <code>Pala</code> on konstruktori <code>public Pala(int x, int y)</code>, joka saa palan sijainnin parametrina. Lisäksi luokalla <code>Pala</code> on seuraavat metodit.</p>

<ul>
  <li><code>public int getX()</code> palauttaa Palan konstruktorissa saadun x-koordinaatin.</li>
  <li><code>public int getY()</code> palauttaa Palan konstruktorissa saadun y-koordinaatin.</li>
  <li><code>public boolean osuu(Pala pala)</code> palauttaa true jos oliolla on sama x- ja y-koordinaatti kuin parametrina saadulla Pala-luokan ilmentymällä.</li>
  <li><code>public String toString()</code> palauttaa palan sijainnin muodossa <code>(x,y)</code>. Esim. <code>(5,2)</code> kun x-koordinaatin arvo on 5 ja y-koordinaatin arvo on 2.</li>
</ul>

<p>Toteuta pakkaukseen <code>matopeli.domain</code> myös luokka <code>Omena</code>. Peri luokalla Omena luokka <code>Pala</code>.</p>


<h4>Mato</h4>

<p>Toteuta pakkaukseen <code>matopeli.domain</code> luokka <code>Mato</code>. Luokalla <code>Mato</code> on konstruktori <code>public Mato(int alkuX, int alkuY, Suunta alkusuunta)</code>, joka luo uuden madon jonka suunta on parametrina annettu <code>alkusuunta</code>. Mato koostuu listasta <code>Pala</code>-luokan ilmentymiä. Huom: enum <code>Suunta</code> löytyy valmiina pakkauksesta <code>Matopeli</code>.</p>

<p>Mato luodaan yhden palan pituisena, mutta madon "aikuispituus" on kolme. Madon tulee kasvaa yhdellä aina kun se liikkuu. Kun madon pituus on kolme, se kasvaa isommaksi vain syödessään.</p>

<p>Toteuta madolle seuraavat metodit</p>

<ul>
  <li><code>public Suunta getSuunta()</code> palauttaa madon suunnan.</li>
  <li><code>public void setSuunta(Suunta suunta)</code> asettaa madolle uuden suunnan. Mato liikkuu uuteen suuntaan kun metodia <code>liiku</code> kutsutaan seuraavan kerran.</li>
  <li><code>public int getPituus()</code> palauttaa madon pituuden. Madon pituuden tulee olla sama kuin <code>getPalat()</code>-metodikutsun palauttaman listan alkioiden määrä.</li>
  <li><code>public List&lt;Pala&gt; getPalat()</code> palauttaa listan pala-olioita, joista mato koostuu. Palat ovat listalla järjestyksessä, siten että pää sijaitsee listan lopussa.</li>
  <li><code>public void liiku()</code> liikuttaa matoa yhden palan verran eteenpäin.</li>
  <li><code>public void kasva()</code> kasvattaa madon kokoa yhdellä. Madon kasvaminen tapahtuu seuraavan <code>liiku</code>-metodikutsun yhteydessä. Sitä seuraaviin liiku-kutsuihin kasvaminen ei enää vaikuta.</li>
  <li><code>public boolean osuu(Pala pala)</code> tarkistaa osuuko mato parametrina annettuun palaan. Jos mato osuu palaan, eli joku madon pala osuu metodille parametrina annettuun palaan, tulee metodin palauttaa arvo <code>true</code>. Muuten metodi palauttaa arvon <code>false</code>.</li>
  <li><code>public boolean osuuItseensa()</code> tarkistaa osuuko mato itseensä. Jos mato osuu itseensä, eli joku sen pala osuu johonkin toiseen sen palaan, metodi palauttaa arvon <code>true</code>. Muuten metodi palauttaa arvon <code>false</code>.</li>
</ul>

<p>Metodien <code>public void kasva()</code> ja <code>public void liiku()</code> toiminnallisuus tulee toteuttaa siten, että mato kasvaa vasta seuraavalla liikkumiskerralla.</p>

<p>Liikkuminen kannattaa toteuttaa siten, että madolle luodaan liikkuessa aina uusi pala. Uuden palan sijainti riippuu madon kulkusuunnasta: vasemmalle mennessä uuden palan sijainti on edellisen pääpalan sijainnista yksi vasemmalle, eli sen x-koordinaatti on yhtä pienempi. Jos uuden palan sijainti on edellisen pääpalan alapuolella, eli madon suunta on alas, tulee uuden palan y-koordinaatin olla yhtä isompi kuin pääpalan y-koordinaatti (käytämme siis piirtämisestä tuttua koordinaattijärjestelmää, jossa y-akseli on kääntynyt).</p>

<p>Liikkuessa uusi pala lisätään listalle, ja viimeisin poistetaan listan lopusta. Tällöin jokaisen palan koordinaatteja ei tarvitse päivittää erikseen. Toteuta kasvaminen siten, että palaa viimeisintä palaa ei poisteta jos metodia <code>kasva</code> on juuri kutsuttu.</p>

<p>Huom! Kasvata matoa aina sen liikkuessa jos sen pituus on pienempi kuin 3.</p>

<pre class="sh_java">
        Mato mato = new Mato(5, 5, Suunta.OIKEA);
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());
        
        mato.kasva();
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());

        mato.setSuunta(Suunta.VASEN);
        System.out.println(mato.osuuItseensa());
        mato.liiku();
        System.out.println(mato.osuuItseensa());
</pre>

<pre>
[(5,5)]
[(6,5), (5,5)]
[(7,5), (6,5), (5,5)]
[(8,5), (7,5), (6,5)]
[(8,5), (7,5), (6,5)]
[(9,5), (8,5), (7,5), (6,5)]
false
true
</pre>

<h4>Matopeli, osa 1</h4>

<p>Muokataan seuraavaksi pakkauksessa <code>matopeli.peli</code> olevaa matopelin toiminnallisuutta kapseloivaa luokka <code>Matopeli</code>. Matopeli-luokka perii luokan <code>Timer</code>, joka tarjoaa ajastustoiminnallisuuden pelin päivittämiseen. Luokka <code>Timer</code> vaatii toimiakseen <code>ActionListener</code>-rajapinnan toteuttavan luokan. Olemme toteuttaneet luokalla <code>Matopeli</code> rajapinnan <code>ActionListener</code>.</p>

<p>Muokkaa matopelin konstruktorin toiminnallisuutta siten, että konstruktorissa luodaan peliin liittyvä <code>Mato</code>. Luo mato siten, että sijainti riippuu Matopeli-luokan konstruktorissa saaduista parametreista. Madon x-koordinaatin tulee olla <code>leveys / 2</code>, y-koordinaatin <code>korkeus / 2</code> ja suunnan <code>Suunta.ALAS</code>.</p>

<p>Luo konstruktorissa myös omena. Konstruktorissa luotavan omenan sijainnin tulee olla satunnainen, kuitenkin niin että omenan x-koordinaatti on aina välillä <code>[0, leveys[</code>, ja y-koordinaatti välillä <code>[0, korkeus[</code>.</p>

<p>Lisää matopeliin lisäksi seuraavat metodit</p>
<ul>
  <li><code>public Mato getMato()</code> palauttaa matopelin madon.</li>
  <li><code>public void setMato(Mato mato)</code> asettaa matopeliin metodin parametrina olevan madon. Jos metodia <code>getMato</code> kutsutaan madon asetuksen jälkeen, tulee metodin <code>getMato</code> palauttaa viite <em>samaan</em> matoon.</li>
  <li><code>public Omena getOmena</code> palauttaa matopelin omenan.</li>
  <li><code>public void setOmena(Omena omena)</code> asettaa matopeliin metodin parametrina olevan omenan. Jos metodia <code>getOmena</code> kutsutaan omenan asetuksen jälkeen, tulee metodin <code>getOmena</code> palauttaa viite <em>samaan</em> omenaan.</li>
</ul>



<h4>Matopeli, osa 2</h4>

<p>Muokkaa metodin <code>actionPerformed</code>-toiminnallisuutta siten, että metodissa toteutetaan seuraavat askeleet annetussa järjestyksessä.</p>

<ol>
  <li>Liikuta matoa</li>
  <li>Jos mato osuu omenaan, syö omena ja kutsu madon kasva-metodia. Arvo peliin uusi omena.</li>
  <li>Jos mato törmää itseensä, aseta muuttujan <code>jatkuu</code> arvoksi <code>false</code></li>
  <li>Kutsu rajapinnan <code>Paivitettava</code> toteuttavan muuttujan <code>paivitettava</code> metodia <code>paivita</code>.</li>
  <li>Kutsu Timer-luokalta perittyä <code>setDelay</code>-metodia siten, että pelin nopeus kasvaa suhteessa madon pituuteen. Kutsu <code>setDelay(1000 / <em>mato</em>.getPituus());</code> käy hyvin: kutsussa oletetaan että olet määritellyt oliomuuttujan nimeltä <code>mato</code>.</li>
</ol>

<p>Aletaan seuraavaksi rakentamaan käyttöliittymäkomponentteja.</p>

<h4>Näppäimistön kuuntelija</h4>

<p>Toteuta pakkaukseen <code>matopeli.gui</code> luokka <code>Nappaimistonkuuntelija</code>. Luokalla on konstruktori <code>public Nappaimistonkuuntelija(Mato mato)</code>, ja se toteuttaa rajapinnan <code>KeyListener</code>. Korvaa metodi <code>keyPressed</code> siten, että nuolinäppäintä ylös painettaessa madolle asetetaan suunta ylös. Nuolinäppäintä alas painettaessa madolle asetetaan suunta alas, vasemmalle painettaessa suunta vasen, ja oikealle painettaessa suunta oikea.</p>

<h4>Piirtoalusta</h4>

<p>Toteuta pakkaukseen <code>matopeli.gui</code> luokka <code>Piirtoalusta</code>, joka perii luokan <code>JPanel</code>. Piirtoalusta saa konstruktorin parametrina luokan <code>Matopeli</code> ilmentymän sekä int-tyyppisen muuttujan <code>palanSivunPituus</code>. Muuttuja <code>palanSivunPituus</code> kertoo minkä levyinen ja korkuinen yksittäinen pala on.</p>

<p>Korvaa luokalta <code>JPanel</code> peritty metodi <code>paintComponent</code> siten, että piirrät metodissa <code>paintComponent</code> madon ja omenan. Käytä madon piirtämiseen Graphics-olion tarjoamaa <code>fill3DRect</code>-metodia. Madon värin tulee olla valkoinen (<code>Color.WHITE</code>). Omenan piirtämisessä tulee käyttää Graphics-olion tarjoamaa <code>fillOval</code>-metodia. Omenan värin tulee olla punainen (<code>Color.RED</code>).</p>

<p>Toteuta luokalla <code>Piirtoalusta</code> myös rajapinta <code>Paivitettava</code>. Paivitettava-rajapinnan määrittelemän metodin <code>paivita</code> tulee kutsua JPanel-luokan <code>repaint</code>-metodia.</p>

<h4>Kayttoliittyma</h4>

<p>Muuta luokkaa <code>Kayttoliittyma</code> siten, että käyttöliittymä sisältää piirtoalustan. Metodissa <code>luoKomponentit</code> tulee luoda piirtoalustan ilmentymä ja lisätä se container-olioon. Luo metodin <code>luoKomponentit</code> lopussa luokan <code>Nappaimistokuuntelija</code> ilmentymä, ja lisää se frame-olioon.</p>

<p>Lisää luokalle <code>Kayttoliittyma</code> myös metodi <code>public Paivitettava getPaivitettava()</code>, joka palauttaa metodissa <code>luoKomponentit</code> luotavan piirtoalustan.</p>

<p>Voit käynnistää käyttöliittymän <code>Main</code>-luokassa seuraavasti. Ennen pelin käynnistystä odotamme että käyttöliittymä luodaan. Kun käyttöliittymä on luotu, se kytketään matopeliin ja matopeli käynnistetään.</p>

<pre class="sh_java">
        Matopeli matopeli = new Matopeli(20, 20);

        Kayttoliittyma kali = new Kayttoliittyma(matopeli, 20);
        SwingUtilities.invokeLater(kali);

        while (kali.getPaivitettava() == null) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException ex) {
                System.out.println("Piirtoalustaa ei ole vielä luotu.");
            }
        }

        matopeli.setPaivitettava(kali.getPaivitettava());
        matopeli.start();
</pre>

</div>

<h2>Kurssipalaute</h2>

<div class="tehtavat">

<h3>Kurssipalaute</h3>

<p>Olemme saaneet paljon arvokasta palautetta TMC:n kautta. Näin kurssin viimeisenä kysymyksenä haluaisimme koko kurssin sisältöä koskevan palautteen. Anna palaute täyttämällä <a href="https://ilmo.cs.helsinki.fi/kurssit/servlet/Valinta">täältä</a> löytyvälomake. Palaute on anonyymi.</p> 

<p>Jotta saat merkatuksi tämän tehtävän, aja tehtävän TMC-testit ja lähetä tehtävä palvelimelle. </p>

</div>

<div class="viikkoraja">Retired</div>

<h3>Tiedostojen valitseminen käyttöliittymästä</h3>

<p>Silloin tällöin eteen tulee tilanne, jossa käyttäjän pitää pystyä valitsemaan tiedosto tiedostojärjestelmästä. Java tarjoaa tiedostojen valintaan valmiin käyttöliittymäkomponentin <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JFileChooser.html" target="_blank">JFileChooser</a></code>.</p>

<p>JFileChooser poikkeaa tähän mennessä käyttämistämme käyttöliittymäkomponenteista siinä, että se avaa uuden ikkunan. Avautuvan ikkunan ulkonäkö riippuu hieman käyttöjärjestelmästä, esimerkiksi hieman vanhemmassa <a href="http://fedoraproject.org/" target="_blank">Fedora</a>-käyttöjärjestelmässä ikkuna on seuraavannäköinen.</p>

<p><img src="img-ohja/kali/jfilechooser-kuva.png"/></p>

<p>JFileChooser-olio voidaan luoda missä tahansa. Olion metodille <code>showOpenDialog</code> annetaan parametrina käyttöliittymäkomponentti, johon se liittyy, esimerkiksi <code>JFrame</code>-luokan ilmentymä. Metodi <code>showOpenDialog</code> avaa tiedostonvalintaikkunan, ja palauttaa <code>int</code>-tyyppisen statuskoodin riippuen käyttäjän valinnasta. Luokassa <code>JFileChooser</code> on määritelty <code>int</code>-tyyppiset luokkamuuttujat, jotka kuvaavat statuskoodeja. Esimerkiksi onnistuneella valinnalla on arvo <code>JFileChooser.APPROVE_OPTION</code>.</p>

<p>Valittuun tiedostoon pääsee <code>JFileChooser</code>-oliosta käsiksi metodilla <code>getSelectedFile</code>.</p>

<pre class="sh_java">
    JFileChooser chooser = new JFileChooser();

    int valinta = chooser.showOpenDialog(frame);

    if (valinta == JFileChooser.APPROVE_OPTION) {
        File valittu = chooser.getSelectedFile();
        System.out.println("Valitsit tiedoston: " + valittu.getName());
    } else if (valinta == JFileChooser.CANCEL_OPTION) {
        System.out.println("Et valinnut tiedostoa!");
    }
</pre>

<p>Yllä oleva esimerkki avaa valintaikkunan, ja tulostaa valitun tiedoston nimen jos valinta onnistuu. Jos valinta epäonnistuu, ohjelma tulostaa <code>"Et valinnut tiedostoa!"</code>.</p>

<h4>Tiedostojen filtteröinti</h4>

<p>Tiedostojen filtteröinnillä tarkoitetaan vain tietynlaisten tiedostojen näyttämistä tiedostoikkunassa. JFileChooser-oliolle voi asettaa filtterin metodilla <code>setFileFilter</code>. Metodi <code>setFileFilter</code> saa parametrina abstraktin luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/filechooser/FileFilter.html" target="_blank">FileFilter</a></code>-ilmentymän, esimerkiksi luokasta <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/filechooser/FileNameExtensionFilter.html" target="_blank">FileNameExtensionFilter</a></code> tehdyn olion.</p>

<p>Luokka <code>FileNameExtensionFilter</code> mahdollistaa tiedostojen filtteröinnin niiden päätteiden perusteella. Esimerkiksi pelkät <code>txt</code>-päätteiset tekstitiedostot saa näkyviin seuraavasti.</p>

<pre class="sh_java">
    JFileChooser chooser = new JFileChooser();
    chooser.setFileFilter(new FileNameExtensionFilter("Tekstitiedostot", "txt"));

    int valinta = chooser.showOpenDialog(frame);

    if (valinta == JFileChooser.APPROVE_OPTION) {
        File valittu = chooser.getSelectedFile();
        System.out.println("Valitsit tiedoston: " + valittu.getName());
    } else if (valinta == JFileChooser.CANCEL_OPTION) {
        System.out.println("Et valinnut tiedostoa!");
    }
</pre>

<div class="tehtavat">


<NEXTWEEK></NEXTWEEK>
<h3>Nopeustesti</h3>



<p>Luodaan ohjelma, joka mittaa kliksutteluvauhtia. Käyttöliittymä tulee näyttämään esimerkiksi seuraavalta.</p>

<p><img src="img-ohja/kali/169-nopeustesti.png"/></p>

<h4 class="req">Oma luokka JButtonille</h4>

<p>Toteuta pakkaukseen <code>nopeustesti</code> luokka <code>Nappi</code>, joka perii JButtonin. Luokalla <code>Nappi</code> tulee olla konstruktori <code>public Nappi(String text, Color aktiivinen, Color passiivinen)</code>. Konstruktorin parametrina saama characterString <code>text</code> tulee antaa parametrina yläluokan konstruktorille (kutsu <code>super(text)</code>).</p> 

<p>Korvaa luokasta JButton peritty metodi <code>protected void paintComponent(Graphics g)</code> siten, että piirrät metodissa napin kokoisen värillisen ympyrän. Saat napin leveyden ja korkeuden JButton-luokalta perityistä metodeista <code>getWidth()</code> ja <code>getHeight()</code>. Kutsu korvatun metodin alussa yläluokan <code>paintComponent</code>-metodia.</p>

<p>Ympyrän värin tulee riippua Napin tilasta: jos nappi on aktiivinen (metodi <code>isEnabled</code> palauttaa <code>true</code> tulee ympyrän väri olla konstruktorin parametrina saatu <code>aktiivinenVari</code>. Muulloin käytetään väriä <code>passiivinenVari</code>.</p>

<h4 class="req">Perustoiminta</h4>

<p>Toteuta luokkaan <code>Nopeustesti</code> käyttöliittymä, jossa on neljä nappulaa ja teksti. Käytä asettelussa napeille omaa JPanel-alustaa, joka asetetaan BorderLayout-asettelijan keskelle. Teksti tulee BorderLayout-asettelijan alaosaan.</p>

<p>Käytä edellisessä osassa luomaasi <code>Nappi</code>-luokkaa. Napeille tulee antaa konstruktorissa tekstit 1, 2, 3 ja 4.</p>

<h4 class="req">Nappuloiden aktiivisuus</h4>

<p>Vain yhden nappulan kerrallaan tulee olla painettavissa (eli aktiivisena). Voit tehdä nappulasta ei-aktiivisen metodikutsulla <code>nappi.setEnabled(false)</code>. Vastaavasti nappi muutetaan aktiiviseksi kutsulla <code>nappi.setEnabled(true)</code>.</p>

<p>Kun aktiivisena olevaa nappulaa painetaan, tulee käyttöliittymän arpoa uusi aktiivinen nappi.</p>

<h4 class="req">Pisteytys</h4>

<p>Tehdään peliin pisteytys: mitataan 20 painallukseen kuluva aika. Helpoin tapa ajan mittaamiseen on metodin <code>System.currentTimeMillis()</code> kutsuminen. Metodi palauttaa kokonaisluvunu, joka laskee millisekunteja (tuhannesosasekunteja) jostain tietysti ajanhetkestä lähtien. Siispä voit mitata kulunutta aikaa kutsumalla <code>currentTimeMillis</code> pelin alussa ja lopussa ja laskemalla erotuksen.</p>

<p>Toteuta siis seuraava: peli laskee napinpainallusten määrän, ja 20. painalluksen jälkeen asettaa kaikki nappulat epäaktiivisiksi ja näyttää <code>JLabel</code>-komponentissa viestin <code>"Pisteesi: XXXX"</code>, jossa <code>XXXX</code> on painalluksiin kulunut aika (millisekunteina) jaettuna 20:lla. Pienempi pistemäärä on siis parempi.</p>

<h3>Tiedostonnäytin</h3>

<p>Tässä tehtävässä toteutetaan ohjelma, joka lukee käyttäjän valitseman tiedoston ja näyttää sen sisällön käyttöliittymässä.</p>

<p>Ohjelmassa on eroteltu käyttöliittymään ja sovelluslogiikka. Tehtäväpohjassa on valmiina sovelluslogiikan rajapinta <code>TiedostonLukija</code> sekä käyttöliittymäluokan runko <code>Kayttoliittyma</code>.</p>

<h4>Käyttöliittymän rakentaminen</h4>

<p>Täydennä käyttöliittymäluokan metodi <code>luoKomponentit</code>. Ohjelma tarvitsee toimiakseen kolme käyttöliittymäkomponenttia:</p>

<ul>
  <li><strong>JButton</strong>-nappi, jossa on teksti &quot;Valitse tiedosto...&quot;</li>
  <li><strong>JTextArea</strong>-tekstieditorin avulla näytetään tiedoston sisältö, komponentin editointimahdollisuus tulee kytkeä pois päältä metodilla <code>setEditable</code>. <code>JTextArea</code> eroaa <code>JTextField</code>-komponentista siten, että <code>JTextArea</code>-komponentissa voi olla tekstiä useammalla rivillä.</li>
  <li><strong>JLabel</strong>-tietokenttä, joka sisältää näytettävän tiedoston nimen (ilman polkua!)</li>
</ul>

<p>Koska tässä tehtävässä on vain kolme aseteltavaa komponenttia, riittävät asetteluun <code>BorderLayout</code>-asettelijan vaihtoehdot: <code>BorderLayout.NORTH</code>, <code>BorderLayout.CENTER</code> ja <code>BorderLayout.SOUTH</code>. Käyttöliittymäkomponentti <code>JTextArea</code> kannattaa sijoittaa keskelle, jotta se saa mahdollisimman paljon tilaa tekstin näyttämiselle.</p>

<p>Käyttöliittymän pitäisi näyttää suunnilleen seuraavalta. Alla olevassa esimerkissä <code>JLabel</code>-oliossa ei ole mitään tekstiä.</p>

    <p><img src="img-ohja/kali/161-tiedostonnaytin-alku.png"/></p>


<h4>Tiedoston lukeminen</h4>

<p>Luo pakkaukseen <code>tiedostonnaytin.sovelluslogiikka</code> luokka <code>OmaTiedostonLukija</code>, joka toteuttaa rajapinnan <code>TiedostonLukija</code>. Rajapinnassa on yksi metodi, <code>lueTiedosto</code>, joka lukee sille annetun tiedoston kokonaisuudessaan characterStringon ja palauttaa tämän characterStringn.</p>

<p>Rajapinnan koodi:</p>

<pre class="sh_java">
package tiedostonnaytin.sovelluslogiikka;

import java.io.File;

public interface TiedostonLukija {
    String lueTiedosto(File tiedosto);
}
</pre>

<p><b>Huom:</b> Palautettavassa characterStringssa tulee säilyttää myös rivinvaihdot <code>"\n"</code>. Esimerkiksi <code>Scanner</code>-lukijan metodi <code>nextLine()</code> poistaa palauttamistaan characterStringista rivinvaihdot, joten joudut joko lisäämään ne takaisin tai lukemaan tiedostoa eri tavalla.</p>

<h4>Käyttöliittymän kytkeminen sovelluslogiikkaan</h4>

<p>Viimeisessä tehtävän osassa toteutetaan käyttöliittymän <code>JButton</code>-napille tapahtumankuuntelija. Saat itse päättää luokalle sopivan nimen.</p>

<p>Tapahtumankuuntelijan tehtävänä on näyttää <code>JFileChooser</code>-tiedostonvalintaikkuna kun <code>JButton</code>-nappia painetaan. Kun käyttäjä valitsee tiedoston, tulee tapahtumankuuntelijan lukea tiedoston sisältö ja näyttää se <code>JTextArea</code>-kentässä. Tämän jälkeen tapahtumankuuntelijan tulee vielä päivittää <code>JLabel</code>-kenttään näytetyn tiedoston nimi (ilman tiedostopolkua).</p>

<p>JFileChooser-olion metodille <code>showOpenDialog</code> tulee antaa parametrina <code>Kayttoliittyma</code>-luokassa oleva <code>JFrame</code>-ikkunaolio. Jos käyttäjä valitsee tiedoston, tulee tiedosto lukea tapahtumankuuntelijassa <code>Kayttoliittyma</code>-luokassa määriteltyä <code>TiedostonLukija</code>-oliota apuna käyttäen. Kannattaa luoda tapahtumankuuntelija siten, että sille annetaan konstruktorissa kaikki tarvitut oliot.</p>

<p>Huomaa, että valintaikkunan voi myös sulkea valitsematta tiedostoa!</p>

<!--
<p><code>JButton</code>-nappiin tulee siis liittää <code>ActionListener</code>-rajapinnan toteuttava tapahtumankuuntelija, joten tehtävässä täytyy luoda tätä varten uusi luokka. <code>JFileChooser</code> palauttaa käyttäjän valitsemaa operaatiota vastaavan paluuarvon sekä viitteen valittuun tiedostoon, jos käyttäjä valitsi tiedoston (eikä peruuttanut valintaa).</p>

<p>JFileChooser-olion metodille <code>showOpenDialog</code> tulee antaa parametrina <code>Kayttoliittyma</code>-luokassa oleva <code>JFrame</code>-ikkunaolio. Jos käyttäjä valitsee tiedoston, tulee tiedosto lukea tapahtumankuuntelijassa <code>Kayttoliittyma</code>-luokassa määriteltyä <code>TiedostonLukija</code>-oliota apuna käyttäen. Kannattaa luoda tapahtumankuuntelija siten, että sille annetaan konstruktorissa tarvitut oliot.</p>

<p>Kun käyttäjä valitsee tiedoston, tulee <code>JTextArea</code>-kentän tekstisisällöksi asettaa tiedoston sisältö.</p>-->

<p>Kun tiedosto on avattu, tulee käyttöliittymän näyttää esimerkiksi seuraavalta.</p>

    <p><img src="img-ohja/kali/161-tiedostonnaytin-avattu.png"/></p>

</div>


<div class="tehtavat">



<h3>Tekstiseikkailu</h3>


  <p>Tehtäväsarjassa tehdään laajennettava tekstiseikkailupelin runko. Seikkailu koostuu <em>kohdista</em>, joissa jokaisessa ruudulle tulee tekstiä. Kohdat voivat olla joko välivaiheita, kysymyksiä, tai monivalintakohtia. Monivalinta-tyyppisen kohdan näyttämä teksti voi olla esimerkiksi seuraavanlainen:</p>

<pre>
Huoneessa on kaksi ovea. Kumman avaat?

1. Vasemmanpuoleisen.
2. Oikeanpuoleisen.
3. Juoksen pakoon.
</pre>

  <p>Käyttäjä vastaa kohdassa esitettävään tekstiin. Yllä olevaan tekstiin voi vastata <code>1</code>, <code>2</code> tai <code>3</code>, ja vastauksesta riippuu, minne käyttäjä siirtyy seuraavaksi.</p>

  <p>Peliin tullaan toteuttamaan kohtia kuvaava rajapinta ja tekstikäyttöliittymä, jonka kautta peliä pelataan.</p>

  <p><em>Huom!</em> Toteuta kaikki tehtävän vaiheet pakkaukseen "seikkailu"</p>

  <h4 class="req">Kohta ja Välivaihe</h4>

  <p>Pelissä voi olla hyvinkin erilaisia kohtia, ja edellä olleessa esimerkissä ollut monivalinta on vain eräs vaihtoehto.</p>

  <p>Toteuta kohdan käyttäytymistä kuvaava rajapinta <code>Kohta</code>. Rajapinnalla <code>Kohta</code> tulee olla metodi <code>String teksti()</code>, joka palauttaa kohdassa tulostettavan tekstin. Metodin <code>teksti</code> lisäksi kohdalla tulee olla metodi <code>Kohta seuraavaKohta(String vastaus)</code>, jonka toteuttavat luokat palauttavat seuraavan kohdan vastauksen perusteella.</p>

  <p>Toteuta tämän jälkeen yksinkertaisin tekstiseikkailun kohta, eli ei-interaktiivinen tekstiruutu, josta pääsee etenemään millä tahansa syötteellä. Toteuta ei-interaktiivista tekstiruutua varten luokka <code>Valivaihe</code>, jolla on seuraavanlainen API.</p>

  <p>
    <ul>
      <li> Luokka toteuttaa rajapinnan <code>Kohta</code>. </li>
      <li> Konstruktori ottaa parametrikseen käyttäjälle näytettävän tekstin. </li>
      <li> <code>public String teksti()</code>-metodi palauttaa konstruktorissa annetun tekstin sekä rivin <code>"(jatka painamalla enteriä)"</code>. (Rivinvaihto saadaan aikaan merkillä "\n".)</li>
      <li> <code>public void asetaSeuraava(Kohta seuraava)</code>-metodilla voidaan asettaa <code>Kohta</code>-olio, jonka <code>seuraavaKohta(String vastaus)</code> aina palauttaa (vastauksesta riippumatta). </li>
    </ul>
  </p>

  <p>Testaa ohjelmaasi seuraavalla esimerkillä:</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    Valivaihe alkuteksti = new Valivaihe("Olipa kerran ohjelmoija.");
    Valivaihe johdanto = new Valivaihe("Joka alkoi ohjelmoimaan Javalla.");
    alkuteksti.asetaSeuraava(johdanto);

    Kohta nykyinen = alkuteksti;
    System.out.println(nykyinen.teksti());

    nykyinen = nykyinen.seuraavaKohta(reader.nextLine());
    if (nykyinen == null) {
        System.out.println("Virhe ohjelmassa!");
    }

    System.out.println(nykyinen.teksti());

    nykyinen = nykyinen.seuraavaKohta(reader.nextLine());
    if (nykyinen != null) {
        System.out.println("Virhe ohjelmassa!");
    }
</pre>

<pre>
Olipa kerran ohjelmoija.
(jatka painamalla enteriä)

Joka alkoi ohjelmoimaan Javalla.
(jatka painamalla enteriä)

</pre>


<h4>Käyttöliittymä</h4>

  <p>Pelin käyttöliittymä (luokka <code>Kayttoliittyma</code>) saa konstruktorin parametrina <code>Scanner</code>-olion ja <code>Kohta</code>-rajapinnan toteuttavan pelin aloittavan olion. Luokka tarjoaa metodin <code>public void start()</code>, joka käynnistää pelin suorituksen.</p>

  <p>Käyttöliittymä käsittelee kaikkia kohtia <code>Kohta</code>-rajapinnan kautta. Käyttöliittymän tulee jokaisessa kohdassa kysyä kohtaan liittyvältä metodilta <code>teksti</code> tekstiä, joka käyttäjälle näytetään. Tämän jälkeen käyttöliittymä kysyy käyttäjältä vastauksen, ja antaa sen parametrina kohta-olion metodille <code>seuraavaKohta</code>. Metodi <code>seuraavaKohta</code> palauttaa vastauksen perusteella seuraavan kohdan, johon pelin on määrä siirtyä. Peli loppuu, kun metodi <code>seuraavaKohta</code> palauttaa arvon <code>null</code>.</p>

  <p>Koska pääohjelma tulee käyttämään kohtia vain <code>Kohta</code>-rajapinnan kautta, voidaan peliin lisätä vaikka minkälaisia kohtia pääohjelmaa muuttamatta. Riittää tehdä uusia <code>Kohta</code>-rajapinnan toteuttavia luokkia.</p>

  <p>Toteuta luokka <code>Kayttoliittyma</code>, ja testaa sen toimintaa seuraavalla esimerkillä</p>

<pre class="sh_java">
        Scanner lukija = new Scanner(System.in);
        Valivaihe alku = new Valivaihe("Olipa kerran ohjelmoija.");
        Valivaihe johdanto = new Valivaihe("Joka alkoi ohjelmoimaan Javalla.");
        Valivaihe loppu = new Valivaihe("Ja päätti muuttaa Helsinkiin.");

        alku.asetaSeuraava(johdanto);
        johdanto.asetaSeuraava(loppu);

        new Kayttoliittyma(lukija, alku).start();
</pre>


<pre>
Olipa kerran ohjelmoija.
(jatka painamalla enteriä)
&gt;

Joka alkoi ohjelmoimaan Javalla.
(jatka painamalla enteriä)
&gt;

Ja päätti muuttaa Helsinkiin.
(jatka painamalla enteriä)
&gt;

</pre>

  <p>Käytä seuraavaa metodia käyttöliittymän <code>start</code>-metodina. Yritä piirtää paperille mitä käy kun käyttöliittymä käynnistetään.</p>

<pre class="sh_java">
    public void start() {
        Kohta nykyinen = alkukohta;

        while (nykyinen != null) {
            System.out.println(nykyinen.teksti());
            System.out.print("&gt; ");
            String vastaus = reader.nextLine();

            nykyinen = nykyinen.seuraavaKohta(vastaus);
            System.out.println("");
        }
    }
</pre>

  <p>Käyttöliittymän <code>start</code>-metodi sisältää siis toistolauseen, jossa ensin tulostetaan käsiteltävän kohdan teksti. Tämän jälkeen kysytään käyttäjältä syötettä. Käyttäjän syöte annetaan vastauksena käsiteltävän kohdan <code>seuraavaKohta</code>-metodille. Metodi <code>seuraavaKohta</code> palauttaa kohdan, jota käsitellään seuraavalla toiston kierroksella. Jos palautettu kohta oli <code>null</code>, lopetetaan toisto.</p>

    <h4>Kysymyksiä</h4>

    <p>Tekstiseikkailussa voi olla kysymyksiä, joihin on annettava oikea vastaus ennen kuin pelaaja pääsee eteenpäin. Tee luokka <code>Kysymys</code> seuraavasti:</p>

    <p>
      <ul>
        <li> Luokka toteuttaa <code>Kohta</code>-rajapinnan. </li>
        <li> Konstruktori saa parametreina kysymystekstin ja oikean vastauksen. </li>
        <li> Seuraavan kohdan voi asettaa <code>asetaSeuraava</code>-metodilla. </li>
        <li> Jos <code>seuraavaKohta</code>-metodia kutsutaan oikealla vastauksella, metodi palauttaa seuraavan kohdan, muuten metodi ei päästä etenemään ja palauttaa arvon <code>this</code>, eli viitteen tähän olioon. </li>
      </ul>
    </p>

    <p>Luokkaa voi testata seuraavalla pääohjelmalla:</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    Kysymys alku = new Kysymys("Minä vuonna Javan ensimmäinen versio julkaistiin?", "1995");
    Valivaihe hyva = new Valivaihe("Hyvä! Lisätietoa: Javan alkuperäinen ideoija on James Gosling.");

    alku.asetaSeuraava(hyva);

    new Kayttoliittyma(lukija, alku).start();
</pre>

<pre>
Minä vuonna Javan ensimmäinen versio julkaistiin?
&gt; <font color="red">2000</font>

Minä vuonna Javan ensimmäinen versio julkaistiin?
&gt; <font color="red">1995</font>

Hyvä! Lisätietoa: Javan alkuperäinen ideoija on James Gosling.
(jatka painamalla enteriä)
&gt;
</pre>



<h4 class="req">Monivalintakysymykset</h4>

    <p>Tällä hetkellä tekstiseikkailu tukee välivaiheita ja yksinkertaisia kysymyksiä. Tekstiseikkailu on siis lineaarinen, eli lopputulokseen ei voi käytännössä vaikuttaa. Lisätään seikkailuun monivalintakysymyksiä, joiden avulla pelin kehittäjä voi luoda vaihtoehtoista toimintaa.</p>

    <p>Esimerkki vaihtoehtoisesta toiminnasta:</p>

<pre>
Kello on 13:37 ja päätät mennä syömään. Minne menet?
1. Exactumiin
2. Chemicumiin
&gt; <font color="red">1</font>

Ruoka on loppu :(
(jatka painamalla enteriä)
&gt;
</pre>


<pre>
Kello on 13:37 ja päätät mennä syömään. Minne menet?
1. Exactumiin
2. Chemicumiin
&gt; <font color="red">2</font>

Mainio valinta!
(jatka painamalla enteriä)
&gt;
</pre>

    <p>Toteuta luokka <code>Monivalinta</code>, jonka API on seuraavanlainen</p>

    <p>
      <ul>
        <li> Toteuttaa rajapinnan <code>Kohta</code>. </li><br/>
        <li> <code>public Monivalinta(String teksti)</code></li> Luokan konstruktori saa parametrina näytettävän tekstin. <br/>
        <li> <code>public void lisaaVaihtoehto(String valinta, Kohta seuraava)</code></li> Lisää vaihtoehdon ja siihen liittyvän seuraavan kohdan. Yhdessä monivalintakysymyksessä voi olla rajaton määrä vaihtoehtoja.<br/>
        <li> <code>public String teksti()</code></li> Palauttaa characterStringna sekä konstruktorissa annetun perustekstin että kaikki valintavaihtoehdot. Valintavaihtoehdot tulee olla eritelty numeroilla.<br/>
        <li> <code>public Kohta seuraavaKohta(String valinta)</code></li> Palauttaa käyttäjän valitsemaa vaihtoehtoa vastaavan kohdan. Käyttäjä valitsee aina kirjoittamalla numeron. Huom! Voit muuttaa characterStringn numeroksi luokan <code>Integer</code> luokkametodilla <code>parseInt</code>. <br/>
      </ul>
    </p>


    <p>Testaa ohjelmasi toimintaa seuraavalla pääohjelmalla:</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    Monivalinta lounas = new Monivalinta("Kello on 13:37 ja päätät mennä syömään. Minne menet?");
    Monivalinta chemicum = new Monivalinta("Lounasvaihtoehtosi ovat seuraavat:");

    Valivaihe exactum = new Valivaihe("Exactumista on kaikki loppu, joten menet Chemicumiin.");

    exactum.asetaSeuraava(chemicum);

    lounas.lisaaVaihtoehto("Exactumiin", exactum);
    lounas.lisaaVaihtoehto("Chemicumiin", chemicum);

    Valivaihe nom = new Valivaihe("Olipas hyvää");

    chemicum.lisaaVaihtoehto("Punajuurikroketteja, ruohosipuli-soijajogurttikastiketta", nom);
    chemicum.lisaaVaihtoehto("Jauhelihakebakot, paprikakastiketta", nom);
    chemicum.lisaaVaihtoehto("Mausteista kalapataa", nom);

    new Kayttoliittyma(lukija, lounas).start();
</pre>

<pre>
Kello on 13:37 ja päätät mennä syömään. Minne menet?
1. Exactumiin
2. Chemicumiin
&gt; <font color="red">1</font>

Exactumista on kaikki loppu, joten menet Chemicumiin.
(jatka painamalla enteriä)
&gt;

Lounasvaihtoehtosi ovat seuraavat:
1. Punajuurikroketteja, ruohosipuli-soijajogurttikastiketta
2. Jauhelihakebakot, paprikakastiketta
3. Mausteista kalapataa
&gt; <font color="red">2</font>

Olipas hyvää
(jatka painamalla enteriä)
&gt;

</pre>

    <p><em>Luokan <code>Monivalinta</code> sisäinen toteutus saattaa olla haastava. Kannattaa esimerkiksi käyttää listaa vastausvaihtoehtojen (characterStringjen) tallentamiseen, ja hajautustaulua kohtien tallentamiseen valintavaihtoehdon indeksillä. </em></p>

</div>


<div class="tehtavat">

  <h3>Tilastot kuntoon</h3>

  <p>NHL:ssä pidetään pelaajista yllä monenlaisia tilastotietoja. Teemme nyt oman ohjelman NHL-pelaajien tilastojen hallintaan.</p>

<h4>Pelaajalistan tulostus</h4>

  <p>Tee luokka <code>Pelaaja</code>, johon voidaan tallettaa pelaajan nimi, joukkue, pelatut ottelut, maalimäärä, ja syöttömäärä. Luokalla tulee olla konstruktori, joka saa edellämainitut tiedot edellä annetussa järjestyksessä.</p>

  <p>Tee kaikille edelläminituille arvoille myös ns. getterimetodit, jotka palauttavat arvot:</p>

<ul>
  <li><code>String getName</code></li>
  <li><code>String getJoukkue</code></li>
  <li><code>int getOttelut</code></li>
  <li><code>int getMaalit</code></li>
  <li><code>int getSyotot</code></li>
  <li><code>int getPisteet</code> - laskee kokonaispistemäärän eli maalien ja syöttöjen summan</li>
</ul>

<p>Talleta seuraavat pelaajat ArrayList:iin ja tulosta listan sisältö:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        ArrayList&lt;Pelaaja&gt; pelaajat = new ArrayList&lt;Pelaaja&gt;();
        pelaajat.add(new Pelaaja("Alex Ovechkin", "WSH", 71, 28, 46));
        pelaajat.add(new Pelaaja("Dustin Byfuglien", "ATL", 69, 19, 31));
        pelaajat.add(new Pelaaja("Phil Kessel", "TOR", 70, 28, 24));
        pelaajat.add(new Pelaaja("Brendan Mikkelson", "ANA, CGY", 23, 0, 2));
        pelaajat.add(new Pelaaja("Matti Luukkainen", "SaPKo", 1, 0, 0 ));

        for (Pelaaja pelaaja : pelaajat) {
            System.out.println(pelaaja);
        }
    }
</pre>

<p>Pelaajan <code>toString()</code>-metodin muodostaman tulostuksen tulee olla seuraavassa muodossa:</p>

<pre>
Alex Ovechkin WSH 71 28 + 46 = 74
Dustin Byfuglien ATL 69 19 + 31 = 50
Phil Kessel TOR 70 28 + 24 = 52
Brendan Mikkelson ANA, CGY 23 0 + 2 = 2
Matti Luukkainen SaPKo 1 0 + 0 = 0
</pre>

  <p>Ensin siis nimi, sitten joukkue, jonka jälkeen ottelut, maalit, plusmerkki, syötöt, yhtäsuuruusmerkki ja kokonaispisteet eli maalien ja syöttöjen summa.</p>

<h4>Tulostuksen siistiminen</h4>

  <p>Tee <code>Pelaaja</code>-luokkaan metodi <code>toSiisticharacterString()</code>, joka palauttaa samat tiedot siististi aseteltuna siten, että jokaiselle muuttujalle on varattu tietty määrä tilaa tulostuksessa.</p>

<p>Tulostuksen tulee näyttää seuraavalta:</p>

<pre>
Alex Ovechkin             WSH             71  28 + 46 = 74
Dustin Byfuglien          ATL             69  19 + 31 = 50
Phil Kessel               TOR             70  28 + 24 = 52
Brendan Mikkelson         ANA, CGY        23   0 +  2 =  2
Matti Luukkainen          SaPKo            1   0 +  0 =  0
</pre>

  <p>Nimen jälkeen joukkueen nimien täytyy alkaa samasta kohdasta. Saat tämän aikaan esim. muotoilemalla nimen tulostuksen yhteydessä seuraavasti:</p>

<pre class="sh_java">
String nameJaTyhjaa = String.format("%-25s", nimi);
</pre>

  <p>Komento tekee characterStringn <code>nimiJaTyhjaa</code> joka alkaa characterStringn <code>nimi</code> sisällöllä ja se jälkeen tulee välilyöntejä niin paljon että characterStringn pituudeksi tulee 25. Joukkueen nimi tulee vastaavalla tavalla tulostaa 14 merkin pituisena characterStringna. Tämän jälkeen on otteluiden määrä (2 merkkiä), jota seuraa 2 välilyöntiä. Tämän jälkeen on maalien määrä (2 merkkiä), jota seuraa characterString " + ". Tätä seuraa syöttöjen määrä (2 merkkiä), characterString " = ", ja lopuksi yhteispisteet (2 merkkiä).</p>

  <p>Lukuarvot eli ottelu-, maali-, syöttö- ja pistemäärä muotoillaan kahden merkin mittaisena, eli lukeman 0 sijaan tulee tulostua välilyönti ja nolla. Seuraava komento auttaa tässä:</p>

<pre class="sh_java">
String maalitMerkkeina = String.format("%2d", maalit);
</pre>

<h4>Pistepörssin tulostus</h4>

  <p>Lisää luokalle Pelaaja rajapinta <code>Comparable&lt;Pelaaja&gt;</code>, jonka avulla pelaajat voidaan järjestää kokonaispistemäärän mukaiseen <em>laskevaan</em> järjestykseen. Järjestä pelaajat Collections-luokan avulla ja tulosta pistepörssi:</p>

<pre class="sh_java">
        Collections.sort(pelaajat);

        System.out.println("NHL pistepörssi:\n");
        for (Pelaaja pelaaja : pelaajat) {
            System.out.println(pelaaja);
        }
</pre>

<p>
Tulostuu:
</p>

<pre>
NHL pistepörssi:

Alex Ovechkin             WSH           71  28 + 46 = 74
Phil Kessel               TOR           70  28 + 24 = 52
Dustin Byfuglien          ATL           69  19 + 31 = 50
</pre>

  <p>Ohjeita tähän tehtävään materiaalissa.</p>

<h4>Kaikkien pelaajien tiedot</h4>

  <p>Tilastomme on vielä hieman vajavainen, siinä on vaan muutaman pelaajan tiedot (ja nekin vastaavat 16.3. tilannetta). Kaikkien tietojen syöttäminen käsin olisi kovin vaivalloista. Onneksemme internetistä osoitteesta <code>http://nhlstatistics.herokuapp.com/players.txt</code> löytyy päivittyvä, koneen luettavaksi tarkoitettu lista pelaajatiedoista.</p>

  <p><b>Huom:</b> kun menet osoitteeseen ensimmäistä kertaa, sivun latautuminen kestää muutaman sekunnin (sivu pyörii virtuaalipalvelimella joka sammutetaan jos sivua ei ole hetkeen käytetty). Sen jälkeen sivu toimii nopeasti.</p>

  <p>Datan lukeminen internetistä on helppoa. Projektissasi on valmiina luokka <code>Tilasto</code>, joka lataa annetun verkkosivun.</p>

<pre class="sh_java">
import java.io.InputStream;
import java.net.URL;
import java.util.Scanner;

public class Tilasto {
    private static final String OSOITE =
            "http://nhlstatistics.herokuapp.com/players.txt";

    private Scanner lukija;

    public Tilasto() {
        this(OSOITE);
    }

    public Tilasto(String osoite) {
        try {
            URL url = new URL(osoite);
            lukija = new Scanner(url.openStream());
        } catch (Exception ex) {
        }
    }

    public Tilasto(InputStream in) {
        try {
            lukija = new Scanner(in);
        } catch (Exception ex) {
        }
    }

    public boolean onkoRivejaJaljella() {
        return reader.hasNextLine();
    }

    public String annaSeuraavaRivi() {
        String rivi = reader.nextLine();
        return rivi.trim();
    }
}
</pre>

  <p><code>Tilasto</code>-luokka lukee pelaajien tilastotiedot internetistä. Metodilla <code>annaSeuraavaRivi()</code> saadaan selville yhden pelaajan tiedot. Tietoja on tarkoitus lukea niin kauan kuin pelaajia riittää, tämä voidaan tarkastaa metodilla <code>onkoRivejaJaljella()</code> </p>

  <p>Kokeile että ohjelmasi onnistuu tulostamaan <code>Tilasto</code>-luokan hakemat tiedot:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Tilasto tilasto = new Tilasto();

        while (tilasto.onkoRivejaJaljella()) {
            String pelaajaRivina = tilasto.annaSeuraavaRivi();
            System.out.println(pelaajaRivina);
        }
    }
</pre>

  <p>Tulostus on seuraavan muodoinen:</p>

<pre>
Evgeni Malkin;PIT;62;39;46;54 <br/>

Steven Stamkos;TBL;70;50;34;64 <br/>

Claude Giroux;PHI;66;26;56;27 <br/>

Jason Spezza;OTT;72;29;46;30 <br/>
// ... ja yli 800:n muun pelaajan tiedot
</pre>

  <p><b>Huom:</b> tulostuksen alussa ja lopussa ja jokaisen pelaajan välissä on html-tägejä, esim. &lt;br/&gt; joka aiheuttaa www-sivulle rivin vaihtumisen.</p>

  <p>Tulostuksessa pelaajan tiedot on erotettu toisistaan puolipisteellä. Ensin nimi, sitten joukkue, ottelut, maalit, syötöt ja laukaukset.</p>

  <p>Pelaajaa vastaava characterString on siis yksittäinen characterString. Saat pilkottua sen osiin <code>split</code>-komennolla seuraavasti:</p>

<pre class="sh_java">
        while (tilasto.onkoRivejaJaljella()) {
            String pelaajaRivina = tilasto.annaSeuraavaRivi();
            String[] pelaajaOsina = pelaajaRivina.split(";");
            for (int j = 0; j < pelaajaOsina.length; j++) {
                System.out.print(pelaajaOsina[j] + " ");
            }
            System.out.println("");
        }
</pre>

  <p>Kokeile että tämä toimii. Saat tästä tehtävästä pisteet seuraavan tehtävän yhteydessä.</p>

  <h4>Kaikkien pelaajien pistepörssi</h4>

  <p>Tee kaikista <code>Tilasto</code>-luokan hakemien pelaajien tiedoista Pelaaja-olioita ja lisää ne ArrayListiin. Lisää tehtävään luokka <code>PelaajatTilastosta</code>. Käytä alla olevaa koodia luokan runkona.</p>

<pre class="sh_java">
import java.util.ArrayList;

public class PelaajatTilastosta {
    public ArrayList&lt;Pelaaja&gt; haePelaajat(Tilasto tilasto) {
        ArrayList&lt;Pelaaja&gt; pelaajat = new ArrayList&lt;Pelaaja&gt;();
        while (tilasto.onkoRivejaJaljella()) {
            String pelaajaRivina = tilasto.annaSeuraavaRivi();
            String[] pelaajaOsina = pelaajaRivina.split(";");

            // Lisätään uusi pelaaja vain, jos syötteessä on kenttiä riittävästi
            if (pelaajaOsina.length &gt; 4) {
                int ottelut = Integer.parseInt(pelaajaOsina[2].trim());
                // Täydennä koodia lukemalla kaikki pelaajaOsina-taulukon kentät uuteen Pelaaja-olioon
                // ...
                // pelaajat.add(new Pelaaja( ... ));
            }
        }

        return pelaajat;
    }
}
</pre>

  <p>Tehtävänäsi on täydentää runkoa siten, että jokaisesta luetusta rivistä luodaan pelaaja, joka lisätään pelaajat-listaan. Huom! <code>Tilasto</code>-luokka palauttaa characterStringja, joten joudut muuntamaan characterStringja myös numeroiksi. Esimerkiksi numeromuotoinen <code>ottelut</code> on muutettava <code>int</code>:iksi <code>Integer.parseInt</code>-metodilla.</p>

  <p>Jos characterStringn metodi <code>split</code> ei ole tuttu, se jakaa characterStringn useampaan osaan annetun merkin kohdalta. Esimerkiksi komento <code>characterString.split(";");</code> palauttaa characterStringsta taulukon, jossa alkuperäisen characterStringn puolipisteellä erotetut osat ovat kukin omassa taulukon indeksissä.</p>

  <p>Voit käyttää testauksen apuna seuraavaa pääohjelmaa:</p>

<pre class="sh_java">
        Tilasto tilasto = new Tilasto();

        PelaajatTilastosta pelaajienHakija = new PelaajatTilastosta();
        ArrayList&lt;Pelaaja&gt; pelaajat = pelaajienHakija.haePelaajat(tilasto);

        for (Pelaaja pelaaja : pelaajat) {
            System.out.println( pelaaja );
        }
</pre>

<h4>Maali ja syöttöpörssi</h4>

  <p>Haluamme tulostaa myös maalintekijäpörssin eli pelaajien tiedot maalimäärän mukaan järjestettynä sekä syöttöpörssin. <a href="http://www.nhl.com/ice/app?component=completePointLeadersList&page=statshome&service=direct">NHL:n</a> kotisivu tarjoaa tämänkaltaisen toiminnallisuuden, eli selaimessa näytettävä lista on mahdollista saada järjestettyä halutun kriteerin mukaan.</p>

  <p>Edellinen tehtävä määritteli pelaajien suuruusjärjestyksen perustuvan kokonaispistemäärään. Luokalla voi olla vain yksi <code>compareTo</code>-metodi, joten joudumme muunlaisia järjestyksiä saadaksemme turvautumaan muihin keinoihin.</p>

        <p>Vaihtoehtoiset järjestämistavat toteutetaan erillisten luokkien avulla. Pelaajien vaihtoehtoisten järjestyksen määräävän luokkien tulee toteuttaa <code>Comparator&lt;Pelaaja&gt;</code>-rajapinta. Järjestyksen määräävän luokan olio vertailee kahta parametrina saamaansa pelaajaa. Metodeja on ainoastaan yksi <code>compare(Pelaaja p1, Pelaaja p2)</code>, jonka tulee palauttaa negatiivinen arvo, jos pelaaja <code>p1</code> on järjestyksessä ennen pelaajaa <code>p2</code>, positiivinen arvo jos <code>p2</code> on järjestyksessä ennen
<code>p1</code>:stä ja 0 muuten.</p>

  <p>Periaatteena on luoda jokaista järjestämistapaa varten oma vertailuluokka, esim. maalipörssin järjestyksen määrittelevä luokka:</p>

<pre class="sh_java">
import java.util.Comparator;

public class Maali implements Comparator&lt;Pelaaja&gt; {
    public int compare(Pelaaja p1, Pelaaja p2) {
        // maalien perusteella tapahtuvan vertailun koodi tänne
    }
}
</pre>

  <p>Tee <code>Comparator</code>-rajapinnan toteuttavat luokat <code>Maali</code> ja <code>Syotto</code>, ja niille vastaavat maali- ja syöttöpörssien generoimiseen sopivat sopivat vertailufunktiot.</p>

  <p>Järjestäminen tapahtuu edelleen luokan <code>Collections</code> metodin <code>sort</code> avulla. Metodi saa nyt toiseksi parametrikseen järjestyksen määräävän luokan olion:</p>

<pre class="sh_java">
Maali maalintekijat = new Maali();
Collections.sort(pelaajat, maalintekijat);
System.out.println("NHL parhaat maalintekijät\n");

// tulostetaan maalipörssi
</pre>

  <p>Järjestyksen määrittelevä olio voidaan myös luoda suoraan sort-kutsun yhteydessä:</p>

<pre class="sh_java">
Collections.sort(pelaajat, new Maali());
System.out.println("NHL parhaat maalintekijät\n");

// tulostetaan maalipörssi
</pre>

  <p>Kun sort-metodi saa järjestyksen määrittelevän olion parametrina, se käyttää olion <code>compareTo()</code>-metodia pelaajia järjestäessään.</p>


</div>

<div class="tehtavat">

  <h3>Olioiden samuus</h3>

<p>
<b>pois?</b>
</p>

  <p>Kaikki oliot ovat tyyppiä <code>Object</code>, joten minkä tahansa tyyppisen olion voi antaa parametrina <code>Object</code>-tyyppisiä parametreja vastaanottavalle metodille.</p>

  <p>Tehtävän mukana tulee rajapinta <code>Vertaaja</code>. Toteuta pakkaukseen <code>samuus</code> luokka <code>OlioidenVertaaja</code>, joka toteuttaa rajapinnan <code>Vertaaja</code>. Metodien tulee toimia seuraavasti:</p>

  <ul>
    <li><strong>public boolean samaOlio(Object o1, Object o2)</strong> metodi palauttaa true, mikäli parametrina saatujen olioiden viitteet ovat samat, muutoin metodi palauttaa false. Olioiden viitteiden samuutta vertaillaan &quot;==&quot;-ilmaisulla.</li>
    <li><strong>public boolean vastaavat(Object o1, Object o2)</strong> metodi palauttaa true, mikäli parametrina saadut oliot ovat samanlaiset. Muutoin metodi palauttaa false. Käytä tässä vertailussa <code>equals</code>-metodia. Tarkemmin <code>equals</code>-metodin toiminnasta <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#equals(java.lang.Object)">Javan Object luokan APIsta</a>. Huomaa, että <code>equals</code>-metodin toiminta riippuu siitä, onko verrattavan olion luokka korvannut <code>Object</code>-luokassa määritellyn <code>equals</code>-metodin. </li>
    <li><strong>public boolean samacharacterStringEsitys(Object o1, Object o2)</strong> metodi palauttaa true, mikäli parametrina saatujen olioiden characterStringesitykset (metodin <code>toString</code>-palauttamat characterStringt) ovat samat. Muutoin metodi palauttaa false.</li>
  </ul>

  <p>Tehtävän mukana tulee luokka <code>Person</code>, jossa <code>equals</code>- ja <code>compareTo</code>-metodit on korvattu. Kokeile toteuttamiesi metodien toimintaa seuraavalla esimerkkikoodilla.</p>

<pre class="sh_java">
   OlioidenVertaaja vertaaja = new OlioidenVertaaja();
   Person henkilo1 = new Person("221078-123X", "Pekka", "Helsinki");
   Person henkilo2 = new Person("221078-123X", "Pekka", "Helsinki");  // täysin samansisältöinen kuin eka
   Person henkilo3 = new Person("110934-123X", "Pekka", "Helsinki");  // eri pekka vaikka asuukin helsingissä

   System.out.println(vertaaja.samaOlio(henkilo1, henkilo1));
   System.out.println(vertaaja.samaOlio(henkilo1, henkilo2));
   System.out.println(vertaaja.vastaavat(henkilo1, henkilo2));
   System.out.println(vertaaja.vastaavat(henkilo1, henkilo3));
   System.out.println(vertaaja.samacharacterStringEsitys(henkilo1, henkilo2));

   Person henkilo4 = new Person("221078-123X", "Pekka", "Savonlinna"); // henkilo1:n pekka mutta asuinpaikka muuttuu

   System.out.println(vertaaja.samaOlio(henkilo1, henkilo4));
   System.out.println(vertaaja.vastaavat(henkilo1, henkilo4));
   System.out.println(vertaaja.samacharacterStringEsitys(henkilo1, henkilo4));
</pre>

  <p>Ylläolevan koodin tulostuksen pitäisi olla seuraava:</p>

<pre>
true
false
true
false
true
false
true
false
</pre>


<h3>Kuviot</h3>

    <p>Tehtäväpohjan mukana tulee luokat <code>Ympyra</code>, <code>Suorakulmio</code> ja <code>TasasivuinenKolmio</code>. Luokat liittyvät samaan aihepiiriin, ja niillä on hyvin paljon yhteistä toiminnallisuutta. Tutustu luokkiin ennenkuin lähdet tekemään, jolloin hahmotat tarkemmin syyt muutoksille. Jos huomaat että luokissa on alustavasti sisennys hieman pielessä, kannattaa sisennys hoitaa kuntoon luettavuuden helpottamiseksi.</p>

    <h4>Kuvio</h4>

    <p>Toteuta pakkaukseen <code>kuviot</code> abstrakti luokka <code>Kuvio</code>, jossa on kuvioihin liittyvää toiminnallisuutta. Luokan kuvio tulee sisältää konstruktori <code>public Kuvio(int x, int y)</code>, metodit <code>public int getX()</code>, <code>public int getY()</code>, sekä abstraktit metodit <code>public abstract double pintaAla()</code> ja <code>public abstract double piiri()</code>.</p>


    <h4>Ympyra perii kuvion</h4>

    <p>Muuta luokan <code>Ympyra</code> toteutusta siten, että se perii luokan <code>Kuvio</code>. Luokan <code>Ympyra</code> ulkoinen toiminnallisuus ei saa muuttua, eli sen tulee tarjota samat metodit kuin aiemminkin -- joko luokan <code>Kuvio</code> avulla tai itse. Muistathan että konstruktorikutsun <code>super</code> avulla voit käyttää yliluokan konstruktoria. Kun metodi <code>public int getX()</code> on toteutettu jo yliluokassa se ei tarvitse erillistä toteutusta luokassa <code>Ympyra</code>.</p>

<pre class="sh_java">
        Kuvio kuvio = new Ympyra(10, 10, 15);
        System.out.println("X " + kuvio.getX());
        System.out.println("Y " + kuvio.getY());
        System.out.println("Pinta-ala " + kuvio.pintaAla());
        System.out.println("Piiri " + kuvio.piiri());
</pre>

<pre>
X 10
Y 10
Pinta-ala 706.85834...
Piiri 94.24777...
</pre>

    <h4>Suorakulmio ja Tasakylkinen kolmio perii kuvion</h4>

    <p>Muuta luokkien <code>Suorakulmio</code> ja <code>TasakylkinenKolmio</code> toteutusta siten, että ne perivät luokan <code>Kuvio</code>. Luokkien ulkoinen toiminnallisuus ei saa muuttua, eli niiden tulee tarjota samat metodit kuin aiemminkin -- joko luokan <code>Kuvio</code> avulla tai itse.</p>

<pre class="sh_java">
        Kuvio kuvio = new Suorakulmio(10, 10, 15, 15);
        System.out.println("X " + kuvio.getX());
        System.out.println("Y " + kuvio.getY());
        System.out.println("Pinta-ala " + kuvio.pintaAla());
        System.out.println("Piiri " + kuvio.piiri());
        System.out.println("");

        kuvio = new TasakylkinenKolmio(10, 10, 15);
        System.out.println("X " + kuvio.getX());
        System.out.println("Y " + kuvio.getY());
        System.out.println("Pinta-ala " + kuvio.pintaAla());
        System.out.println("Piiri " + kuvio.piiri());
</pre>

<pre>
X 10
Y 10
Pinta-ala 225.0
Piiri 60.0

X 10
Y 10
Pinta-ala 97.42785...
Piiri 45.0
</pre>


</div>



<h3>TreeMap</h3>

        <p>Joukkojen järjestyksessä pitäminen onnistuu <code>Set</code> rajapinnan toteuttavan <code>TreeSet</code>-olion avulla. Aiemmassa <code>Tehtavakirjanpito</code>-esimerkissä henkilökohtaiset tehtäväpisteet tallennettiin <code>Map</code>-rajapinnan toteuttavaan <code>HashMap</code>-olioon. Kuten <code>HashSet</code>, <code>HashMap</code> ei pidä alkioita järjestyksessä. Rajapinnasta <code>Map</code> on olemassa toteutus <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html" target="_blank">TreeMap</a></code>, jossa hajautustaulun avaimia pidetään järjestyksessä. Muutetaan <code>Tehtavakirjanpito</code>-luokkaa siten, että henkilökohtaiset pisteet tallennetaan <code>TreeMap</code>-tyyppiseen hajautustauluun.</p>

<pre class="sh_java">
public class Tehtavakirjanpito {
    private Map&lt;String, Set&lt;Integer&gt;&gt; tehdytTehtavat;

    public Tehtavakirjanpito() {
        this.tehdytTehtavat = new TreeMap&lt;String, Set&lt;Integer&gt;&gt;();
    }

    public void lisaa(String kayttaja, int tehtava) {
        if (!this.tehdytTehtavat.containsKey(kayttaja)) {
            this.tehdytTehtavat.put(kayttaja, new TreeSet&lt;Integer&gt;());
        }

        Set&lt;Integer&gt; tehdyt = this.tehdytTehtavat.get(kayttaja);
        tehdyt.add(tehtava);
    }

    public void tulosta() {
        for (String kayttaja: this.tehdytTehtavat.keySet()) {
            System.out.println(kayttaja + ": " + this.tehdytTehtavat.get(kayttaja));
        }
    }
}
</pre>

        <p>Muunsimme samalla <code>Set</code>-rajapinnan toteutukseksi <code>TreeSet</code>-luokan. Huomaa että koska olimme käyttäneet rajapintoja, muutoksia tuli hyvin pieneen osaan koodista. Etsi kohdat jotka muuttuivat!</p>

        <p>Käyttäjäkohtaiset tehtävät voidaan nyt tulostaa järjestyksessä.</p>

<pre class="sh_java">
        Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
        kirjanpito.lisaa("Mikael", 3);
        kirjanpito.lisaa("Mikael", 4);
        kirjanpito.lisaa("Mikael", 3);
        kirjanpito.lisaa("Mikael", 3);

        kirjanpito.lisaa("Pekka", 4);
        kirjanpito.lisaa("Pekka", 4);

        kirjanpito.lisaa("Matti", 1);
        kirjanpito.lisaa("Matti", 2);

        kirjanpito.tulosta();
</pre>

<pre>
Matti: [1, 2]
Mikael: [3, 4]
Pekka: [4]
</pre>


    <p>Luokka <code>TreeMap</code> vaatii että <em>avaimena</em> käytetyn luokan tulee toteuttaa <code>Comparable</code>-rajapinta. Jos luokka ei toteuta rajapintaa <code>Comparable</code>, voidaan luokalle <code>TreeMap</code> antaa konstruktorin parametrina <code>Comparator</code>-luokan toteuttama olio aivan kuten <code>TreeSet</code>-luokalle.</p>



<div class="tehtavat">



  <h3>Sähköposteja</h3>

  <p>Tehtävänäsi on toteuttaa sähköpostiohjelmaan komponentti, joka säilöö viestejä. Tehtäväpohjan mukana tulee luokka <code>Sahkoposti</code>, joka esittää sähköpostiviestiä. Luokalla <code>Sahkoposti</code> on oliomuuttujat:</p>

  <p>
    <ul>
      <li>saapumisaika (yksinkertaisesti kokonaisluku)</li>
      <li>lähettäjä</li>
      <li>otsikko</li>
      <li>sisältö</li>
    </ul>
  </p>

  <p>Toteutetaan tässä luokka <code>Viestivarasto</code>, joka tarjoaa sähköpostien hallintaan liittyviä toimintoja.</p>

  <h4>Viestivarasto, lisääminen ja hakeminen</h4>

<p>Luo pakkaukseen <code>posti</code> luokka <code>Viestivarasto</code>, ja lisää sille seuraavat metodit:</p>

<p>
  <ul>
    <li><code>public void lisaa(Sahkoposti s)</code> lisää viestin</li>
    <li><code>public Sahkoposti hae(String otsikko)</code> palauttaa viestin jolla on annettu otsikko tai <em>null</em> jos sellaista ei ole. </li>
  </ul>
</p>

<p>Voit olettaa että millään kahdella viestillä ei ole samaa otsikkoa.</p>



  <h4>Ajan perusteella hakeminen</h4>

  <p>Lisää luokkaan <code>Viestivarasto</code> seuraavat metodit</p>

<p>
  <ul>
    <li><code>public Sahkoposti hae(int aika)</code> palauttaa viestin joka saapui annettuun aikaan tai <em>null</em> jos sellaista ei ole. Voit olettaa että millään kahdella viestillä ei ole samaa saapumisaikaa.</li>
    <li><code>public Sahkoposti haeUusinViesti()</code> hakee uusimman viestin (eli sen jonka saapumisaika on isoin) ai <em>null</em> jos sellaista ei ole.</li>
    <li><code>public Sahkoposti haeUusinViesti(int ylaraja)</code> hakee uusimman viestin joka ei ole saapunut annetun ajan <code>ylaraja</code> jälkeen. Metodi palauttaa <em>null</em> jos tällaista viestiä ei ole.</li>
  </ul>
</p>

  <p><em>Huom!</em> Kannattaa käyttää kahta erillistä rakennetta viestien tallentamiseen. Otsikon perusteella tallentamiseen voit käyttää <code>HashMap</code>pia, ja viestien tallentamiseen ajan mukaan <code>TreeMap</code>pia. Näin saat toteutettua hae-operaatiot tehokkaasti. Tutustu myös <code>TreeMap</code>in metodeihin <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html#lastKey()" target="_blank">lastKey()</a></code> ja <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html#floorKey()" target="_blank">floorKey()</a></code>.</p>

</div>


<h2>Ohjelmien automaattinen testaaminen</h2>

<p><em>Errare humanum est</em></p>

<p>Ihminen on erehtyväinen ja paraskin ohjelmoija tekee virheitä. Ohjelman kehitysvaiheessa tapahtuvien virheiden lisäksi huomattava osa virheistä syntyy olemassa olevaa ohjelmaa muokattaessa. Ohjelman muokkauksen aikana tehdyt virheet eivät välttämättä näy muokattavassa osassa, vaan voivat ilmaantua välillisesti erillisessä osassa ohjelmaa: osassa, joka käyttää muutettua osaa.</p>

<p>Ohjelmien automaattinen testaaminen tarkoittaa toistettavien testien luomista. Testeillä varmistetaan että ohjelma toimii halutusti, ja että ohjelma säilyttää toiminnallisuutensa myös muutosten jälkeen. Sanalla <em>automaattinen</em> painotetaan sitä, että luodut testit ovat toistettavia ja että ne voidaan suorittaa aina haluttaessa -- ohjelmoijan ei tarvitse olla läsnä testejä suoritettaessa.</p>

<p>Otimme aiemmin askeleita kohti testauksen automatisointia antamalla Scanner-oliolle parametrina characterStringn, jonka se tulkitsee käyttäjän näppäimistöltä antamaksi syötteeksi. Automaattisessa testaamisessa testaaminen viedään viedä pidemmälle: koneen tehtävänä on myös tarkistaa että ohjelman tuottama vastaus on odotettu.</p>

<p>Automaattisen testauksen tällä kurssilla painotettu osa-alue on <em>yksikkötestaus</em>, jossa testataan ohjelman pienten osakokonaisuuksien -- metodien ja luokkien -- toimintaa. Yksikkötestaamiseen käytetään Javalla yleensä <a href="http://www.junit.org" target="_blank">JUnit</a>-testauskirjastoa.</p>

<h3>Pino ja automaattiset testit</h3>

<p>Pino on kaikille ihmisille tuttu asia. Esimerkiksi ravintola Unicafessa lautaset ovat yleensä pinossa. Pinon päältä voi ottaa lautasen ja pinon päälle voi lisätä lautasia. On myös helppo selvittää onko pinossa vielä lautasia jäljellä.</p>

<p>Pino on myös ohjelmoinnissa usein käytetty aputietorakenne. Rajapintana lukuja sisältävä pino näyttää seuraavalta.</p>

<pre class="sh_java">
public interface Pino {
    boolean tyhja();
    boolean taynna();
    void pinoon(int luku);
    int pinosta();
    int huipulla();
    int lukuja();
}
</pre>

<p>Rajapinnan määrittelemien metodien on tarkoitus toimia seuraavasti:</p>

<ul>
  <li><code>public boolean tyhja()</code> palauttaa true jos pino on tyhjä</li>
  <li><code>public boolean taynna()</code> palauttaa true jos pino on täynnä</li>
  <li><code>public void pinoon(int luku)</code> laittaa parametrina olevan luvun pinon päälle</li>
  <li><code>public int huipulla()</code> kertoo pinon huipulla olevan alkion</li>
  <li><code>public int pinosta()</code> poistaa ja palauttaa pinon päällä olevan alkion</li>
  <li><code>public int lukuja()</code> kertoo pinossa olevien lukujen määrän</li>
  <li><code>public int tilaa()</code> kertoo pinon vapaan tilan määrän</li>
</ul>

<p>Toteutetaan rajapinnan <code>Pino</code> toteuttava luokka <code>OmaPino</code>, johon talletetaan lukuja. Pinoon mahtuvien lukujen määrä annetaan pinon konstruktorissa. Toteutamme pinon hieman aiemmasta poikkeavasti -- emme testaa ohjelmaa pääohjelman avulla, vaan  käytämme pääohjelman sijasta automatisoituja JUnit-testejä ohjelman testaamiseen.</p>

<h4 class="req">Tutustuminen JUnitiin</h4>

<p>NetBeansissa olevat ohjelmamme ovat tähän asti sijainneet aina <em>Source Packages</em>issa tai sen sisällä olevissa pakkauksissa. Ohjelman lähdekoodit tulevat aina kansioon <em>Source Packages</em>. Automaattisia testejä luodessa testit luodaan valikon <em>Test Packages</em> alle. Uusia JUnit-testejä voi luoda valitsemalla projektin oikealla hiirennapilla ja valitsemalla avautuvasta valikosta <code>New -> JUnit Test...</code>. Jos vaihtoehto JUnit test ei näy listassa, löydät sen valitsemalla <em>Other</em>.</p>

<p><img src="img-ohja/testaus/new-junit-test.png"/></p>

<p>JUnit-testit sijaitsevat luokassa. Uutta testitiedostoa luodessa ohjelma pyytää testitiedoston nimen. Tyypillisesti nimeksi annetaan testattavan luokan tai toiminnallisuuden nimi. Luokan nimen tulee aina päättyä sanaan <code>Test</code>. Esimerkiksi alla luodaan testiluokka <code>PinoTest</code>, joka sijaitsee pakkauksessa <code>pino</code>. NetBeans haluaa luoda käyttöömme myös valmista runkoa testiluokalle -- joka käy hyvin.</p>

<p><img src="img-ohja/testaus/pinotest.png"/></p>

<p>Jos NetBeans kysyy minkä JUnit-version haluat käyttöösi, valitse <code>JUnit 4.x</code>.</p>

<p><img src="img-ohja/testaus/junit4.png"/></p>

<p>Kun testiluokka <code>PinoTest</code> on luotu, näkyy se projektin valikon <em>Test Packages</em> alla.</p>

<p><img src="img-ohja/testaus/pinotest-luotu.png"/></p>

<p>Luokka <code>PinoTest</code> näyttää aluksi seuraavalta</p>

<pre class="sh_java">
package pino;

import org.junit.*;
import static org.junit.Assert.*;

public class PinoTest {

    public PinoTest() {
    }

    @BeforeClass
    public static void setUpClass() throws Exception {
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
    }

    @Before
    public void setUp() {
    }

    @After
    public void tearDown() {
    }
    // TODO add test methods here.
    // The methods must be annotated with annotation @Test. For example:
    //
    // @Test
    // public void hello() {}
}
</pre>

<p>Meille oleellisia osia luokassa <code>PinoTest</code> ovat metodit <code>public void setUp</code>, jonka yläpuolella on merkintä <code>@Before</code>, ja kommentoitu metodipohja <code>public void hello()</code>, jonka yläpuolella on merkintä <code>@Test</code>. Metodit, joiden yläpuolella on merkintä <code>@Test</code> ovat ohjelman toiminnallisuutta testaavia testimetodeja. Metodi <code>setUp</code> taas suoritetaan ennen jokaista testiä.</p>

<p>Muokataan luokkaa <code>PinoTest</code> siten, että sillä testataan rajapinnan <code>Pino</code> toteuttamaa luokkaa <code>OmaPino</code>. Älä välitä vaikkei luokkaa <code>OmaPino</code> ole vielä luotu. Pino on testiluokan oliomuuttuja, joka alustetaan ennen jokaista testiä metodissa <code>setUp</code>.</p>

<pre class="sh_java">
package pino;

import org.junit.*;
import static org.junit.Assert.*;

public class PinoTest {

    Pino pino;

    @Before
    public void setUp() {
        pino = new OmaPino(3);
    }

    @Test
    public void alussaTyhja() {
        assertTrue(pino.tyhja());
    }

    @Test
    public void lisayksenJalkeenEiTyhja() {
        pino.pinoon(5);
        assertFalse(pino.tyhja());
    }

    @Test
    public void lisattyAlkioTuleePinosta() {
        pino.pinoon(3);
        assertEquals(3, pino.pinosta());
    }

    @Test
    public void lisayksenJaPoistonJalkeenPinoOnTaasTyhja() {
        pino.pinoon(3);
        pino.pinosta();
        assertTrue(pino.tyhja());
    }

    @Test
    public void lisatytAlkiotTulevatPinostaOikeassaJarjestyksessa() {
        pino.pinoon(1);
        pino.pinoon(2);
        pino.pinoon(3);

        assertEquals(3, pino.pinosta());
        assertEquals(2, pino.pinosta());
        assertEquals(1, pino.pinosta());
    }

    @Test
    public void tyhjennyksenJalkeenPinoonLaitettuAlkioTuleeUlosPinosta() {
        pino.pinoon(1);
        pino.pinosta();

        pino.pinoon(5);

        assertEquals(5, pino.pinosta());
    }

    // ...
}
</pre>

<p>Jokainen testi, eli merkinnällä <code>@Test</code> varustettu metodi, alkaa tilanteesta, jossa on luotu uusi tyhjä pino. Jokainen yksittäinen @Test-merkitty metodi on oma testinsä. Yksittäisellä testimetodilla testataan aina yhtä pientä osaa pinon toiminnallisuudesta. Testit suoritetaan toisistaan täysin riippumattomina, eli jokainen testi alkaa "puhtaaltä pöydältä", <code>setUp</code>-metodin alustamasta tilanteesta.</p>

<p>Yksittäiset testit noudattavat aina samaa kaavaa. Ensin luodaan tilanne jossa tapahtuvaa toimintoa halutaan testata, sitten tehdään testattava toimenpide, ja lopuksi tarkastetaan onko tilanne odotetun kaltainen. Esimerkiksi seuraava testi testaa että lisäyksen ja poiston jälkeen pino on taas tyhjä -- huomaa myös kuvaava testimetodin nimentä:</p>

<pre class="sh_java">
    @Test
    public void lisayksenJaPoistonJalkeenPinoOnTaasTyhja() {
        pino.pinoon(3);
        pino.pinosta();
        assertTrue(pino.tyhja());
    }
</pre>

<p>Ylläoleva testi testaa toimiiko metodi <code>tyhja()</code> jos pino on tyhjennetty. Ensin laitetaan pinoon luku metodilla <code>pinoon</code>, jonka jälkeen pino tyhjennetään kutsumalla metodia <code>pinosta()</code>. Tällöin on saatu aikaan tilanne jossa pinon <em>pitäisi</em> olla tyhjennetty. Viimeisellä rivillä testataan, että pinon metodi <code>tyhja()</code> palauttaa arvon <code>true</code> testausmetodilla <code>assertTrue()</code>. Jos metodi <code>tyhja()</code> ei palauta arvoa <code>true</code> näemme testejä suorittaessa virheen. </p>

<p>Jokainen testi päättyy jonkun <code>assert</code>-metodin kutsuun. Esimerkiksi metodilla <code>assertEquals()</code> voidaan varmistaa onko metodin palauttama luku tai characterString haluttu, ja metodilla <code>assertTrue()</code> varmistetaan että metodin palauttama arvo on <code>true</code>. Erilaiset <code>assert</code>-metodit saadaan käyttöön luokan alussa olevalla määrittelyllä <code>import static org.junit.Assert.*;</code>.

<p>Testit suoritetaan joko painamalla <em>alt</em> ja <em>F6</em> tai valitsemalla <em>Run -> Test project</em>. (Macintosh-koneissa tulee painaa <em>ctrl</em> ja <em>F6</em>). Punainen väri ilmaisee että testin suoritus epäonnistui -- testattava toiminnallisuus ei toiminut kuten toivottiin. Vihreä väri kertoo että testin testaama toiminnallisuus toimi kuten haluttiin.</p>

<h4 class="req">Luokan OmaPino toteutus</h4>

<p>Pinon toteuttaminen testien avulla tapahtuisi askel kerrallaan siten, että lopulta kaikki testit toimivat. Ohjelman rakentaminen aloitetaan yleensä hyvin varovasti. Rakennetaan ensin luokka <code>OmaPino</code> siten, että ensimmäinen testi <em>alussaTyhja</em> alkaa toimimaan. Älä tee mitään kovin monimutkaista, "quick and dirty"-ratkaisu kelpaa näin alkuun. Kun testi menee läpi (eli näyttää vihreää), siirry ratkaisemaan seuraavaa kohtaa.</p>

<p>Testi <em>alussaTyhja</em> menee läpi aina kun palautamme arvon <code>true</code> metodista <code>tyhja</code>.</p>

<pre class="sh_java">
package pino;

import java.util.ArrayList;
import java.util.List;

public class OmaPino implements Pino {

    public OmaPino(int maksimikoko) {
    }

    @Override
    public boolean tyhja() {
        return true;
    }

    // tyhjät metodirungot
</pre>

<p>Siirrytään ratkaisemaan kohtaa <em>lisayksenJalkeenEiTyhja</em>. Tarvitsemme toteutuksen metodille <code>pinoon</code>. Yksi lähestymistapa on muokata luokkaa <code>OmaPino</code> siten, että se sisältää taulukon. Taulukkoa käytetään, että pinottavat values talletetaan pinon taulukkoon yksi kerrallaan. Seuraava kuvasarja selkeyttää taulukossa olevien alkioiden pinoon laittamista ja pinosta ottamista.</p>

<pre>
<font color ="red">pino = new OmaPino(4);</font>

  0   1   2   3
-----------------
|   |   |   |   |
-----------------
alkioita: 0

<font color ="red">pino.pinoon(5);</font>

  0   1   2   3
-----------------
| 5 |   |   |   |
-----------------
alkiota: 1

<font color ="red">pino.pinoon(3);</font>

  0   1   2   3
-----------------
| 5 | 3 |   |   |
-----------------
alkiota: 2

<font color ="red">pino.pinoon(7);</font>

  0   1   2   3
-----------------
| 5 | 3 | 7 |   |
-----------------
alkiota: 3

<font color ="red">pino.pinosta();</font>

  0   1   2   3
-----------------
| 5 | 3 |   |   |
-----------------
alkiota: 2
</pre>

<p>Ohjelman tulee siis muistaa kuinka monta alkiota pinossa on. Uusi alkio laitetaan jo pinossa olevien perään. Alkion poisto aiheuttaa sen, että taulukon viimeinen käytössä ollut paikka vapautuu ja alkiomäärän muistavan muuttujan arvo pienenee.</p>

<p>Luokan <code>OmaPino</code> toteutusta jatketaan askel kerrallaan kunnes kaikki testit menevät läpi. Jossain vaiheessa ohjelmoija todennäköisesti huomaisi, että taulukko kannattaa vaihtaa <code>ArrayList</code>-rakenteeksi.</p>

<p>Huomaat todennäköisesti ylläolevan esimerkin luettuasi että olet jo tehnyt hyvin monta testejä käyttävää ohjelmaa. Osa TMC:n toiminnallisuudesta rakentuu JUnit-testien varaan, ongelmat ovat varsinkin kurssin alkupuolella pilkottu pieniin testeihin, joiden avulla ohjelmoijaa on ohjattu eteenpäin. TMC:n mukana tulevat testit ovat kuitenkin usein monimutkaisempia kuin ohjelmien normaalissa automaattisessa testauksessa niiden tarvitsee olla. TMC:ssä ja kurssilla käytettävien testien kirjoittajien tulee muunmuassa varmistaa luokkien olemassaolo, jota normaalissa automaattisessa testauksessa harvemmin tarvitsee tehdä.</p>

<p>Harjoitellaan seuraavaksi ensin testien lukemista, jonka jälkeen kirjoitetaan muutama testi.</p>

<div class="tehtavat" id="viikko11">



  <h3>Tehtävälista</h3>

  <p>Tehtäväpohjassa on rajapinnan <code>Tehtavalista</code> toteuttava luokka <code>MuistiTehtavalist</code>. Ohjelmaa varten on koodattu valmiiksi testit, joita ohjelma ei kuitenkaan läpäise. Tehtävänäsi on tutustua testiluokkaan <code>TehtavalistaTest</code>, ja korjata luokka <code>MuistiTehtavalista</code> siten, että ohjelman testit menevät läpi.</p>

  <p>Huom! Tässä tehtävässä sinun ei tarvitse koskea  testiluokkaan <code>TehtavalistaTest</code>.</p>


  <h3>Lukutilasto</h3>

  <p><em>Huom!</em> Tässä tehtävässä on jo mukana testiluokka, johon sinun tulee kirjoittaa lisää testejä. Vastauksen oikeellisuus testataan vasta TMC-palvelimella: tehtävästä saa pisteet vasta kun <em>molemmat</em> tehtävät on suoritettu palvelimella hyväksytysti. Ole tarkka metodien nimennän <em>ja</em> lisättyjen lukujen kanssa.</p>

  <p>Tehtävässä tulee pakkauksessa <code>tilasto</code> sijaitseva luokka <code>Lukutilasto</code>.</p>

<ul>
  <li><code>public void lisaaLuku(int luku)</code><br/>Lisää annetun luvun lukutilastoon.</li>
  <li><code>public int sum()</code><br/>Palauttaa tilastossa olevien lukujen summan.</li>
  <li><code>public int lukujenMaara()</code><br/>Palauttaa tilastossa olevien lukujen maaran.</li>
  <li><code>public boolean sisaltaa(int luku)</code><br/>Palauttaa totuusarvon, joka kertoo onko parametrina annettu luku tilastossa.</li>
</ul>

  <p>Testikansiossa olevassa pakkauksessa <code>tilasto</code> on luokka <code>LukutilastoTest</code>, johon sinun tulee lisätä uusia testimetodeja.</p>

  <h4>Lukujen määrän kasvamisen tarkistus</h4>

  <p>Lisää testiluokkaan testimetodi <code>public void lukujenMaaraKasvaaKahdellaKunLisataanKaksiLukua()</code>, jossa lukutilastoon lisätään values 3 ja 5. Tämän jälkeen metodissa tarkistetaan että lukutilastossa on kaksi lukua käyttäen lukutilaston metodia lukujenMaara. Käytä <code>Assert</code>-luokan <code>assertEquals</code>-metodia palautettujen arvojen tarkastamiseen.</p>

  <h4>Summan tarkistus yhdellä luvulla</h4>

  <p>Lisää testiluokkaan testimetodi <code>public void summaOikeinYhdellaLuvulla()</code>, jossa lukutilastoon lisätään luku 3. Tämän jälkeen metodissa tarkistetaan lukutilaston summa-metodin avulla että tilastossa olevien lukujen summa on 3.  Käytä <code>Assert</code>-luokan <code>assertEquals</code>-metodia palautettujen arvojen tarkastamiseen.</p>
</div>



<h3>Jätkänshakin sovelluslogiikka (pakollinen)</h3>

<p><em>Huom!</em> tämä tehtävä on pakollinen yliopistoon hakeville.</p>

<p><em>Tämä tehtävä on kolmen yksittäisen tehtäväpisteen arvoinen.</em> Tehtävässä toteutetaan sovelluslogiikka jätkänshakille ja harjoitellaan ohjelmarakenteen osittaista omatoimista suunnittelua.</p>

<p>Tehtäväpohjassa tulee mukana käyttöliittymä <a href="http://fi.wikipedia.org/wiki/Ristinolla">jätkänshakille</a>, jossa pelilaudan koko on aina 3x3 ruutua. Käyttöliittymä huolehtii ainoastaan pelilaudalla tehtyihin tapahtumiin reagoimisesta, sekä pelilaudan ja pelitilanteen tietojen päivittämisestä. Pelin logiikka on erotettu <code>JatkanshakinSovelluslogiikka</code>-rajapinnan avulla omaksi luokakseen.</p>

<pre class="sh_java">
package jatkanshakki.sovelluslogiikka;

public interface JatkanshakinSovelluslogiikka {
    char getNykyinenVuoro();
    int getMerkkienMaara();

    void asetaMerkki(int sarake, int rivi);
    char getMerkki(int sarake, int rivi);

    boolean isPeliLoppu();
    char getVoittaja();
}
</pre>


<p>Rajapinnan <code>JatkanshakinSovelluslogiikka</code> lisäksi tehtäväpohjassa on apuluokka, joka määrittelee pelilaudan ruutujen mahdolliset tilat <code>char</code>-tyyppisinä kirjaimina. Ruutu voi olla joko tyhjä, tai siinä voi olla risti tai nolla. Apuluokassa <code>Jatkanshakki</code> on näille määrittelyt:</p>

<pre class="sh_java">
package jatkanshakki.sovelluslogiikka;

public class Jatkanshakki {
    public static final char RISTI = 'X';
    public static final char NOLLA = 'O';
    public static final char TYHJA = ' ';
}
</pre>

<p>Tehtävänäsi on täydentää pakkauksessa <code>jatkanshakki.sovelluslogiikka</code> olevaa rajapinnan <code>JatkanshakinSovelluslogiikka</code> toteuttavaa luokkaa <code>OmaJatkanshakinSovelluslogiikka</code>. Luokka <code>OmaJatkanshakinSovelluslogiikka</code> mahdollistaa jätkänshakin pelaamisen.</p>

<p>Rajapinta <code>JatkanshakinSovelluslogiikka</code> määrittelee seuraavat toiminnot, jotka luokan <code>OmaJatkanshakinSovelluslogiikka</code> tulee toteuttaa:</p>

  <ul>
    <li><strong>char getNykyinenVuoro()</strong> palauttaa pelaajan merkkiä vastaavan arvon: <code>RISTI</code>, <code>NOLLA</code> tai pelin päätyttyä <code>TYHJA</code></li>
    <li><strong>int getMerkkienMaara()</strong> palauttaa pelilaudalle tähän mennessä asetettujen merkkien määrän (välillä 0-9)</li>
    <li><strong>void asetaMerkki(int sarake, int rivi)</strong> asettaa pelaajan vuoron mukaisen merkin annettuun ruutuun sarakkeen (0-2) ja rivin (0-2) perusteella ja antaa vuoron toiselle pelaajalle. Metodi heittää poikkeuksen <code>IllegalArgumentException</code>, jos sarake tai rivi on pelilaudan ulkopuolella tai ruudussa on jo merkki, ja poikkeuksen <code>IllegalStateException</code>, jos peli on jo loppu.</li>
    <li><strong>char getMerkki(int sarake, int rivi)</strong> palauttaa sarakkeen ja rivin määrittelemän ruudun tilan, joka voi olla <code>TYHJA</code>, <code>RISTI</code> tai <code>NOLLA</code>. Metodi heittää poikkeuksen <code>IllegalArgumentException</code>, jos sarake tai rivi on pelilaudan ulkopuolella.</li>
    <li><strong>boolean isPeliLoppu()</strong> palauttaa arvon <code>true</code>, jos toinen pelaajista voitti pelin tai peli päättyi tasapeliin, muutoin metodi palauttaa <code>false</code></li>
    <li><strong>char getVoittaja()</strong> palauttaa arvon <code>TYHJA</code>, jos peli on kesken tai peli päättyi tasapeliin, muutoin metodi palauttaa voittajan merkin: <code>RISTI</code> tai <code>NOLLA</code></ul>

<p>Ensimmäinen pelivuoro on aina merkillä <code>RISTI</code>. Pelin voittaa se pelaaja, joka saa ensimmäisenä kolme merkkiä vaakasuoraan, pystysuoraan tai vinottain. Tasapeli todetaan vasta, kun pelilauta on täynnä merkkejä eli tyhjiä ruutuja ei enää ole.</p>

<p><b>Vinkki:</b> Pelilaudan tilanteen voi esittää esimerkiksi yhdeksän alkion <code>char</code>-taulukolla, jonne talletetaan peliruutujen tilat. Sarakkeen ja rivin perusteella voidaan laskea taulukon indeksi: <code>rivi * 3 + sarake</code>.</p>

</div>



<!-- END SNIP -->

<!-- FLOATING MENU -->
<div id="fl_menu">
  <div class="label">Materiaali</div>
  <div class="menu" id="fl_menu_items">
  </div>
</div>



<script>
//config
$float_speed=0; //milliseconds
$float_easing="easeOutQuint";
$menu_fade_speed=0; //milliseconds
$closed_menu_opacity=0.5;

//cache vars
$fl_menu=$("#fl_menu");
$fl_menu_menu=$("#fl_menu .menu");
$fl_menu_label=$("#fl_menu .label");

$(window).load(function() {
    menuPosition=$('#fl_menu').position().top;
    FloatMenu();
    $fl_menu.hover(
        function(){ //mouse over
            $fl_menu_label.fadeTo($menu_fade_speed, 1);
            $fl_menu_menu.fadeIn($menu_fade_speed);
        },
        function(){ //mouse out
            $fl_menu_label.fadeTo($menu_fade_speed, $closed_menu_opacity);
            $fl_menu_menu.fadeOut($menu_fade_speed);
        }
    );
});

$(window).scroll(function () {
    FloatMenu();
});

function FloatMenu(){
    var scrollAmount=$(document).scrollTop();
    var newPosition=menuPosition+scrollAmount;
    if($(window).height()<$fl_menu.height()+$fl_menu_menu.height()){
        $fl_menu.css("top",menuPosition);
    } else {
        $fl_menu.stop().animate({top: newPosition}, $float_speed, $float_easing);
    }
}
</script>



</body>

</html>


